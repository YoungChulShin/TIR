# 03. 모델 주도 설계
## 들어가기
소프트웨어 개발
- 우리는 어떤 문제를 해결하기 위해서 소프트웨어를 개발한다
- 이를 위해서 비지니스 도메인을 중심으로 소프트웨어 개발을 해야하고, 도메인에 깊이 뿌리내린 모델을 만들어야한다. 
- 모델에 핵심 개념을 잘 반영하기 위해서 유비쿼터스 언어가 사용되어야한다. 

이렇게 모델이 만들어졌으면, 이제 코드로 옮겨야한다. 

분석 모델
- 소프트웨어 분석가는 도메인 전문가와 함께 일하면서, 도메인의 기본 요소를 발견하고 요소들간의 관계를 정리한다. 그리고 도메인을 반영하는 모델을 개발한다. 
- 개발자는 전달받은 모델을 보고 코드로 표현하는데, 코드로 표현될 수 없는 개념이나 관계에 대해서는 자신만의 고유한 설계를 추가하게 된다.
- 개발이 진행되면서 원본 모델과 최종 모델 사이의 간격이 점점 커진다. 
- 즉, 분석적으로 정확한 모델을 가지고 있는것이 모델을 코드로 바로 변환할 수 있다는 것을 의미하지는 않는다. 
- 이러한 방법을 `분석 모델`이라는 설계 기법으로 불리는데, 모델과 개발사이에 발생할 수 있는 간극으로 인해서 코딩이 시작되자마자 폐기되고 만다.
   - 다이어그램과 글로 모델을 표현하더라도, 개발자가 그것을 다 이해하지 못할 가능성은 충분히 있다

__중요한 것은 쉽고 정확하게 코드로 변환할 수 있는 모델을 선택하는 것이다.__

개발자들이 분석가들의 회의에 참여하고, 코드를 설계하기 전에 모델을 명확하게 이해한다면 훨씬 더 생산적인 작업이 될 수 있다. 

모델 주도 설계
- 모델은 소프트웨어 그 자체와 설계 고려 사항에 초점을 맞추어 만들어쟈야한다
- 개발자들은 모델링 프로세스가 진행되는 동안 함께 참여해야한다
- 코드와 모델을 밀접하게 연관시킴으로써, 코드에 의미가 생기게 모델은 실제적으로 중요한 가치를 지니게 된다.
- 개발자가 모델의 피드백 제공자로 참석한다면 모델이 소프트웨어로 구현될 수 있는 것을 보장하고, 초기에 구현의 문제를 잡을 수도 있다.
- 개발자도 모델을 주제로한 일정 수준의 회의에는 참석해야하고, 도메인 전문가와 만나고, 유비쿼터스 언어를 사용해야한다.
   ```
   유비쿼터스언어 --> 모델 --> 설계에 사용할 용어 --> 코드
                      --> 설계 요소
   ```

객체지향 프로그래밍은 구현과 모델이 같은 패러다임에 기초하고 있기 때문에 모델을 구현하기에 적합하다. 
- 모델객체와 그들 사이의 관계를 프로그래밍 영역에서 매핑할 수 있다
- `메시지`를 이용해서 서로 이야기한다
   ```
   오브젝트 책에서는 '협력' 이라는 이름으로 객체사이의 관계를 설명한다. 

   협력에 대한 짧은 이야기
   - 객체는 메시지를 전송, 수신하는 방법으로 서로 상호작용을 한다
   - 수신된 메시지를 처리하는 방법을 메서드(method)라고 한다
   - 메시지를 수신한 객체는 스스로 적절한 메서드를 선택한다. (=구현과 인터페이스의 분리)

   객체지향의 본질은 객체를 지향하는 것이다. 이를 위해서 아래 2가지를 고민해야 한다
   1. 어떤 클래스가 필요한지를 고민하기 전에 어떤 객체들이 필요한지 고민하라
   2. 객체를 독립적인 존재가 아니라 기능을 구현하기 위해 협력하는 공동체의 일원으로 봐야 한다
   ```

## 애그리거트
객체의 생명 주기를 관리하는 패턴
- 애그리거트: 객체의 소유권과 경계를 정의
- 팩토리: 객체의 생성
- 리파지토리: 객체의 저장

도메인 모델은 단순하고 이해하기 쉽게 만들어야한다
- 모델 하나는 굉장히 많은 도메인 객체를 담을 수 있다
- 많은 정보들 속에서 도메인에 대한 깊은 이해를 표현하지 않는 부분이나 관계는 제거한다.
   - 실제 도메인에는 존재하지만, 우리가 구현하는 부분에는 필요하지 않은 것들

그런데 복잡한 도메인은 단순화 시켜도 그 안에서 많은 관계가 존재한다
- 예: 은행 시스템
   - 고객 데이터를 포함하고 처리한다
   - 그 안에는 개인정보, 계좌 번호, 잔액, 수행 오퍼레이션등 많은 관계가 있는데, 고객 데이터를 삭제한다면 이 모든 관계 정보다 함께 삭제되어야한다. 
   - 변경에 대해서도 무결성이 보장되어야한다. 
- 이러한 작업은 DB의 트랜잭션을 통해서 수행되는데, 데이터 무결성에 대한 부분은 모델 수준에서 해결하는 편이 바람직하다
- 하지만 많은 관계 속에서 일관성을 유지하는 것은 어렵다

애그리거트를 사용하자
- 데이터를 변경할 때 하나의 단위로 간주되는 관련된 객체의 집합
- 객체의 외부와 내부를 가르는 경계를 정해서 구분한다
- 애그리거트는 root를 가진다. 
   - root는 외부에서 접근할 수 있는 창구. 다른 객체들은 root를 통해서만 참조할 수 있다
   - 애그리거트 내 객체들에 대한 참조를 담고 있다
   - root를 삭제하면 관련 객체가 모두 삭제되고, root를 변경하면 애그리거트 내 모든 객체에 간접적으로 영향을 주게 된다. 
   - root를 통해서만 변경을 할 수 있기 때문에 불편식을 강제하기가 쉽다
   - 전역 식별자를 가지며, 불변식을 검증할 책임을 가진다
- 오퍼레이션이 완료되면 외부객체가 내부 객체를 더이상 참조하지 못하는 하는 조건을 달아서 root가 내부 객체에 대한 일시적인 참조를 전달하는 것은 가능하다. 
   - 값 객체의 복사본을 외부에 전달하는 방법
   - _info 같은 개념으로 보면 되지 않을까?_

![2-2](/Images/DDDQ/p80.jpg)

## 팩토리
엔티티와 애그리거트는 root엔티티의 생성자를 통해서 생성하기에는 너무 크거나 복잡할 경우가 있다. 
- 생성자를 이용할 경우 객체를 생성하는 동안 객체의 내부 구조, 그 객체가 포함하는 다른 객체와의 연관관계, 생성 규칙등에 대한 지식이 필요할 수 있다
   ```
   항상 그렇다는 것은 아니다.
   ```

하나의 객체를 생성하는 것은 그 자체로 주요 오퍼레이션에 속하지만, 꼭 이 책임을 생성된 객체가 부담하지 않아도 된다. 

복잡한 객체 생성 절차를 캡슐화할 수 있는 개념이 필요한데, 이것이 팩토리이다. 
- 객체 생성에 필요한 지식을 캡슐화하는데 사용되며, 애그리거트를 생성하는데 특히 유용하다
- 팩토리는 root가 생성될 때 모든 객체가 불변식에 맞게 생성될 수 있도하는 책임을 가져야한다
- 팩토리 자체는 도메인 모델 내에서 비지니스 로직에 대한 책임을 지지는 않지만, 도메인 설계의 일부이다. 

팩토리를 구현하는 설계 패턴
- 팩토리 메서드 패턴
- 추상 팩토리 패턴

팩토리 메서드 패턴
- 다른 객체를 생성하는 필요한 지식을 포함하지만, 외부에 드러내지 않는 객체 메서드
- 애그리거트에 속한 객체를 생성하고자 할 때 유용하다. 

추상 팩토리 패턴
- ??

팩토리를 생성할 때에는 객체의 캡슐화를 깨트리기 때문에 매우 주의해서 작업해야한다. 
- 불변식에 영향을 주는 변경이 발생하면 팩토리를 수정해야한다
- 팩토리는 각 객체들사이에 연관관계에 대한 로직이 들어가는데, 이 로직은 어떤 객체에도 속하지 않는 로직이다. 객체 생성에 대한 로직이기 때문이다. 
- __이를 통해서 객체는 좀 더 단순한 상태로 유지되고, 복잡한 생성 로직을 포함하지 않은 본연의 목적(비지니스 로직 수행)에 충실해야한다__

앞에서 말한 내용이지만, 항상 팩토리가 필요한 것은 아니다. 아래 케이스는 생성자를 사용한다
- 생성 작업이 복잡하지 않다
- 객체의 생성이 다른 객체의 생성과 연관되어 있지 않으며, 모든 속성이 생성자를 통해 전달되어야한다. (_AllArgsConstructor겠지_)
- 클라이언트가 구현에 관심이 있어서, 사용한 전략 패턴을 선택하려고한다.
   - _의존성 주입을 이용해서 런타임에 객체를 변경_
- 클래스가 해당 타입이다. 관련된 계층 구조가 없어서 concrete 구현 목록에서 선택할 필요가 없다. 

## 리파지토리(Repository)
```
집합이 실제 값의 집합과 Aggregate로 같이 사용되니 헷갈린다. 여기는 집합, 애그리거트로 구분해서 적어본다. 
클라이언트는 엔티티를 사용하는 클라이언트(application service, domain service)로 생각했다. 설명 내용을 보면 domain service가 좀 더 맞는듯 하다. 
```
Factory가 객체의 생성을 책임진다면, 이미 생성된 체를 참조할 때는 어떻게 해야할까?
- 얘를 들어서 애그리거트의 값 객체를 얻기 위해서는 root의 참조를 얻어야하는데 어떻게 해야할까?
- 항상 메모리에 객체를 보관할 수는 없다. 

데이터베이스 또는 다른 영속적인 형태로 저장된 값을 조회함으로써 얻을 수 있다. 
- 객체가 집합의 root라면 엔티티
- 값 객체라면 엔티티로부터 그 값을 얻을 수 있다.

하지만 클라이언트에서 이 값을 직접 조회하는 것은 문제가 있을 수 있다. 
- 제일 빠르고 간단한 해결책처럼 보이기는 하지만, 설계에는 좋지 않다. 
- 이렇게 되면 도메인 레이어에 DB 관련 코드가 산재하게 된다. 도메인 모델도 도메인의 개념 자체보다는 인프라스트럭처 관련된 부분을 다루게 된다. 
   - 특정 기술에 얽매이게 된다. DB를 변경한다면 어떻게 될까?

__리파지토리__ 를 사용해서 객체의 참조를 얻는 로직을 캡슐화하자. 
- 도메인 객체는 인프라스트럭처를 직접 참조하는게 아니라, 리파지토리를 통해서만 얻을 수 있게 된다. 
- 리파지토리는 전략(strategy) 패턴을 포함할 수도 있는데, 객체에 따라 구현체를 변경하면서 저장영역을 다르게 구성할 수도 있다.
   ![2-2k](/Images/DDDQ/p90.jpg)
- root에 대해서만 리파지토리를 제공한다
   - 애그리거트를 제공하는 메서드를 제공해줘야한다
- __리파지토리는 인프라스트럭처의 구현과 매우 유사하지만, 리파티토리 인터페이스 자체는 순수하게 도메인 모델이다__
   ![2-2](/Images/DDDQ/p94.jpg)
```
89페이지에 7번째줄부터 무슨 말인지 잘 모르겠다;;;
```