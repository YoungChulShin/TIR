# 03. 모델 주도 설계
## 애그리거트
객체의 생명 주기를 관리하는 패턴
- 애그리거트: 객체의 소유권과 경계를 정의
- 팩토리: 객체의 생성
- 리파지토리: 객체의 저장

도메인 모델은 단순하고 이해하기 쉽게 만들어야한다
- 모델 하나는 굉장히 많은 도메인 객체를 담을 수 있다
- 많은 정보들 속에서 도메인에 대한 깊은 이해를 표현하지 않는 부분이나 관계는 제거한다.
   - 실제 도메인에는 존재하지만, 우리가 구현하는 부분에는 필요하지 않은 것들

그런데 복잡한 도메인은 단순화 시켜도 그 안에서 많은 관계가 존재한다
- 예: 은행 시스템
   - 고객 데이터를 포함하고 처리한다
   - 그 안에는 개인정보, 계좌 번호, 잔액, 수행 오퍼레이션등 많은 관계가 있는데, 고객 데이터를 삭제한다면 이 모든 관계 정보다 함께 삭제되어야한다. 
   - 변경에 대해서도 무결성이 보장되어야한다. 
- 이러한 작업은 DB의 트랜잭션을 통해서 수행되는데, 데이터 무결성에 대한 부분은 모델 수준에서 해결하는 편이 바람직하다
- 하지만 많은 관계 속에서 일관성을 유지하는 것은 어렵다

애그리거트를 사용하자
- 데이터를 변경할 때 하나의 단위로 간주되는 관련된 객체의 집합
- 객체의 외부와 내부를 가르는 경계를 정해서 구분한다
- 애그리거트는 root를 가진다. 
   - root는 외부에서 접근할 수 있는 창구. 다른 객체들은 root를 통해서만 참조할 수 있다
   - 애그리거트 내 객체들에 대한 참조를 담고 있다
   - root를 삭제하면 관련 객체가 모두 삭제되고, root를 변경하면 애그리거트 내 모든 객체에 간접적으로 영향을 주게 된다. 
   - root를 통해서만 변경을 할 수 있기 때문에 불편식을 강제하기가 쉽다
   - 전역 식별자를 가지며, 불변식을 검증할 책임을 가진다
- 오퍼레이션이 완료되면 외부객체가 내부 객체를 더이상 참조하지 못하는 하는 조건을 달아서 root가 내부 객체에 대한 일시적인 참조를 전달하는 것은 가능하다. 
   - 값 객체의 복사본을 외부에 전달하는 방법
   - _info 같은 개념으로 보면 되지 않을까?_

![2-2](/Images/DDDQ/p80.jpg)

## 팩토리
엔티티와 애그리거트는 root엔티티의 생성자를 통해서 생성하기에는 너무 크거나 복잡할 경우가 있다. 
- 생성자를 이용할 경우 객체를 생성하는 동안 객체의 내부 구조, 그 객체가 포함하는 다른 객체와의 연관관계, 생성 규칙등에 대한 지식이 필요할 수 있다
   ```
   항상 그렇다는 것은 아니다.
   ```

하나의 객체를 생성하는 것은 그 자체로 주요 오퍼레이션에 속하지만, 꼭 이 책임을 생성된 객체가 부담하지 않아도 된다. 

복잡한 객체 생성 절차를 캡슐화할 수 있는 개념이 필요한데, 이것이 팩토리이다. 
- 객체 생성에 필요한 지식을 캡슐화하는데 사용되며, 애그리거트를 생성하는데 특히 유용하다
- 팩토리는 root가 생성될 때 모든 객체가 불변식에 맞게 생성될 수 있도하는 책임을 가져야한다
- 팩토리 자체는 도메인 모델 내에서 비지니스 로직에 대한 책임을 지지는 않지만, 도메인 설계의 일부이다. 

팩토리를 구현하는 설계 패턴
- 팩토리 메서드 패턴
- 추상 팩토리 패턴

팩토리 메서드 패턴
- 다른 객체를 생성하는 필요한 지식을 포함하지만, 외부에 드러내지 않는 객체 메서드
- 애그리거트에 속한 객체를 생성하고자 할 때 유용하다. 

추상 팩토리 패턴
- ??

팩토리를 생성할 때에는 객체의 캡슐화를 깨트리기 때문에 매우 주의해서 작업해야한다. 
- 불변식에 영향을 주는 변경이 발생하면 팩토리를 수정해야한다
- 팩토리는 각 객체들사이에 연관관계에 대한 로직이 들어가는데, 이 로직은 어떤 객체에도 속하지 않는 로직이다. 객체 생성에 대한 로직이기 때문이다. 
- __이를 통해서 객체는 좀 더 단순한 상태로 유지되고, 복잡한 생성 로직을 포함하지 않은 본연의 목적(비지니스 로직 수행)에 충실해야한다__

앞에서 말한 내용이지만, 항상 팩토리가 필요한 것은 아니다. 아래 케이스는 생성자를 사용한다
- 생성 작업이 복잡하지 않다
- 객체의 생성이 다른 객체의 생성과 연관되어 있지 않으며, 모든 속성이 생성자를 통해 전달되어야한다. (_AllArgsConstructor겠지_)
- 클라이언트가 구현에 관심이 있어서, 사용한 전략 패턴을 선택하려고한다.
   - _의존성 주입을 이용해서 런타임에 객체를 변경_
- 클래스가 해당 타입이다. 관련된 계층 구조가 없어서 concrete 구현 목록에서 선택할 필요가 없다. 

## 리파지토리(Repository)
```
집합이 실제 값의 집합과 Aggregate로 같이 사용되니 헷갈린다. 여기는 집합, 애그리거트로 구분해서 적어본다. 
클라이언트는 엔티티를 사용하는 클라이언트(application service, domain service)로 생각했다. 설명 내용을 보면 domain service가 좀 더 맞는듯 하다. 
```
Factory가 객체의 생성을 책임진다면, 이미 생성된 체를 참조할 때는 어떻게 해야할까?
- 얘를 들어서 애그리거트의 값 객체를 얻기 위해서는 root의 참조를 얻어야하는데 어떻게 해야할까?
- 항상 메모리에 객체를 보관할 수는 없다. 

데이터베이스 또는 다른 영속적인 형태로 저장된 값을 조회함으로써 얻을 수 있다. 
- 객체가 집합의 root라면 엔티티
- 값 객체라면 엔티티로부터 그 값을 얻을 수 있다.

하지만 클라이언트에서 이 값을 직접 조회하는 것은 문제가 있을 수 있다. 
- 제일 빠르고 간단한 해결책처럼 보이기는 하지만, 설계에는 좋지 않다. 
- 이렇게 되면 도메인 레이어에 DB 관련 코드가 산재하게 된다. 도메인 모델도 도메인의 개념 자체보다는 인프라스트럭처 관련된 부분을 다루게 된다. 
   - 특정 기술에 얽매이게 된다. DB를 변경한다면 어떻게 될까?

__리파지토리__ 를 사용해서 객체의 참조를 얻는 로직을 캡슐화하자. 
- 도메인 객체는 인프라스트럭처를 직접 참조하는게 아니라, 리파지토리를 통해서만 얻을 수 있게 된다. 
- 리파지토리는 전략(strategy) 패턴을 포함할 수도 있는데, 객체에 따라 구현체를 변경하면서 저장영역을 다르게 구성할 수도 있다.
   ![2-2k](/Images/DDDQ/p90.jpg)
- root에 대해서만 리파지토리를 제공한다
   - 애그리거트를 제공하는 메서드를 제공해줘야한다
- __리파지토리는 인프라스트럭처의 구현과 매우 유사하지만, 리파티토리 인터페이스 자체는 순수하게 도메인 모델이다__
   ![2-2](/Images/DDDQ/p94.jpg)
```
89페이지에 7번째줄부터 무슨 말인지 잘 모르겠다;;;
```