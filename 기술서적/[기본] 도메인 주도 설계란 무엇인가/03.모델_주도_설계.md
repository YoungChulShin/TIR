# 03. 모델 주도 설계
## 들어가기
소프트웨어 개발
- 우리는 어떤 문제를 해결하기 위해서 소프트웨어를 개발한다
- 이를 위해서 비지니스 도메인을 중심으로 소프트웨어 개발을 해야하고, 도메인에 깊이 뿌리내린 모델을 만들어야한다. 
- 모델에 핵심 개념을 잘 반영하기 위해서 유비쿼터스 언어가 사용되어야한다. 

이렇게 모델이 만들어졌으면, 이제 코드로 옮겨야한다. 

분석 모델 설계
- 소프트웨어 분석가는 도메인 전문가와 함께 일하면서, 도메인의 기본 요소를 발견하고 요소들간의 관계를 정리한다. 그리고 도메인을 반영하는 모델을 개발한다. 
- 개발자는 전달받은 모델을 보고 코드로 표현하는데, 코드로 표현될 수 없는 개념이나 관계에 대해서는 자신만의 고유한 설계를 추가하게 된다.
- 개발이 진행되면서 원본 모델과 최종 모델 사이의 간격이 점점 커진다. 
- 즉, 분석적으로 정확한 모델을 가지고 있는것이 모델을 코드로 바로 변환할 수 있다는 것을 의미하지는 않는다. 
- 이러한 방법을 `분석 모델`이라는 설계 기법으로 불리는데, 모델과 개발사이에 발생할 수 있는 간극으로 인해서 코딩이 시작되자마자 폐기되고 만다.
   - 다이어그램과 글로 모델을 표현하더라도, 개발자가 그것을 다 이해하지 못할 가능성은 충분히 있다

__중요한 것은 쉽고 정확하게 코드로 변환할 수 있는 모델을 선택하는 것이다.__

개발자들이 분석가들의 회의에 참여하고, 코드를 설계하기 전에 모델을 명확하게 이해한다면 훨씬 더 생산적인 작업이 될 수 있다. 

__모델 주도 설계__
- 모델은 소프트웨어 그 자체와 설계 고려 사항에 초점을 맞추어 만들어쟈야한다
- 개발자들은 모델링 프로세스가 진행되는 동안 함께 참여해야한다
- 코드와 모델을 밀접하게 연관시킴으로써, 모델은 실제적으로 중요한 가치를 지니게 된다.
- 개발자가 모델의 피드백 제공자로 참석한다면 모델이 소프트웨어로 구현될 수 있는 것을 보장하고, 초기에 구현의 문제를 잡을 수도 있다.
- 개발자도 모델을 주제로한 일정 수준의 회의에는 참석해야하고, 도메인 전문가와 만나고, 유비쿼터스 언어를 사용해야한다.
   ```
   유비쿼터스언어 --> 모델 --> 설계에 사용할 용어 --> 코드
                      --> 설계 요소
   ```

객체지향 프로그래밍은 구현과 모델이 같은 패러다임에 기초하고 있기 때문에 모델을 구현하기에 적합하다. (_모델이 행동과 속성을 모두 가지기 때문에_)
- 모델객체와 그들 사이의 관계를 프로그래밍 영역에서 매핑할 수 있다
- `메시지`를 이용해서 서로 이야기한다
   ```
   오브젝트 책에서는 '협력' 이라는 이름으로 객체사이의 관계를 설명한다. 

   협력에 대한 짧은 이야기
   - 객체는 메시지를 전송, 수신하는 방법으로 서로 상호작용을 한다
   - 수신된 메시지를 처리하는 방법을 메서드(method)라고 한다
   - 메시지를 수신한 객체는 스스로 적절한 메서드를 선택한다. (=구현과 인터페이스의 분리)

   객체지향의 본질은 객체를 지향하는 것이다. 이를 위해서 아래 2가지를 고민해야 한다
   1. 어떤 클래스가 필요한지를 고민하기 전에 어떤 객체들이 필요한지 고민하라
   2. 객체를 독립적인 존재가 아니라 기능을 구현하기 위해 협력하는 공동체의 일원으로 봐야 한다
   ```

## 모델 주도 설계를 위한 블록
_한번 보고, 챕터가 끝난뒤에 한번 더 보자_
![54](/Images/DDDQ/p53.jpg)

## 계층형 아키텍처
프로그램을 개발하면서 도메인은 전체 코드에 비해서 상대적으로 작은 부분일 수 있는데, __편하다는 목적__ 으로 하나의 객체에 UI, DB 등 도메인과 직접 연관이 없는 코드를 넣으면 유지보수에 어려움이 있을 수 있다. 

유지보수를 하기 어렵다는 것은 변경에 취약하다는 말과도 상통할 수 있는데, UI를 변경하는데 비지니스 로직에 영향을 줄 수도 있다. 
- 그리고 가독성도 떨어지고
- 의존관계가 많아서 테스트도 어렵다

따라서 복잡한 프로그램을 '레이어'로 분할하는 방법이 있다. 
   - 도메인 레이어에 도메인과 관련된 코드를 집중시켜서, 다른 코드들로부터 독립적으로 만들어야한다
   ![55](/Images/DDDQ/p54.jpg)

계층형 아키텍처
- Presentation
   - 사용자에게 정보를 보여주고 사용자의 명령을 해석하는 책임
- Application
   - 애플리케이션의 활동을 조율하는 얇은 레이어
   - 업무 로직을 포함하지 않는다
   - 비지니스 객체의 상태는 보관하지 않지만, 애플리케이션의 처리 상태는 보관한다
- Domain
   - 도메인 정보를 포함하고, 비지니스 객체의 상태를 보관한다
   - 핵심
   - 영속성은 Infrastructure에 위임한다
- Infrastrucure
   - 다른 레이어 모두를 지원하는 라이브러리
   - 비지니스 객체의 영속성을 구현
   - 사용자 인터페이스 레이어의 라이브러리를 포함한다

계층형 아키텍처의 의존성 역전
- 계층형 아키텍처에서 계층간 의존성은 아래를 가리킨다. 영속성 계층에 대한 도메인 계층의 의존성 때문에 영속성 계층을 변경할 때마다 잠재적으로 도메인 계층도 변경해야한다.  
   - 하지만 도메인 코드는 애플리케이션에서 가장 중요하기 때문에 영속성 계층이 변경 될 때마다 도메인 계층까지 변경하고 싶지는 않다. 
- 의존성 역전 원칙(DIP)를 적용하면 의존성의 방향을 바꿀 수 있다. 
   - 이를 통해서 영속성 계층이 도메인 계층에 의존하도록 할 수 있다. 
   - 핵심은 interface를 이용하는 것이다. 컴파일 타임에는 영속성 계층이 도메인을 의존하지만, 런타임에는 의존성이 반대로 된다. 
   ![2-2](/Images/만들면서배우는클린아키텍쳐/2-2.jpg)
   ![2-2](/Images/DDDQ/dip_layer.jpg)

계층형 아키텍처의 단점
- https://github.com/YoungChulShin/TIR/blob/master/기술서적/%5B기본%5D%20만들면서%20배우는%20클린아키텍쳐/01.계층형_아키텍쳐의_문제는_무엇일까.md

## 엔티티
개념
- 소프트웨어가 여러 상태를 거치는 동안에도 동일한 값을 유지하는 식별자를 지니는 유형의 객체
- 예: 은행 계좌
   - 각 계좌별로 가지는 고유한 계좌 번호가 있다
   - 시스템의 생명 주기 동안 변경되지 않으며, 지속성이 보장된다
   - 계좌 정보가 어떤 형태를 취하느냐는 중요하지 않으며 계좌 번호는 동일하게 유지된다
- 엔티티를 만드는 것은 식별자를 만들어내는 작업이라고 해도 과언이 아니다

고유한 식별자
- 모듈에 의해서 생성되는 ID
- DB에서 유일성을 보장하는 테이블의 기본 키
- 사용자에 의해서 정의 (예: 공항 코드)

그럼 모든 객체를 엔티티로 만들어야할까? 모두 식별자를 가지도록 해야할까?
## 값 객체
식별자를 가지는 것은 그만큼의 비용이 든다
- 유일한 식별자를 가지도록 보장할 책임이 있다

식별자나 영속성없이 정보를 표현하기 위한 객체도 있다
- 예: 점이나 선을 그릴 때 관련 정보를 표시하는 Point 클래스는 좌표 정보만 가지고 있으면 된다

값 객체
- 도메인의 특정 요소에 속성을 포함해야하는 경우
- 객체 자체가 아니라 그 객체가 가지는 속성에만 관심이 있는 경우
- 값 객체의 속성들은 하나하나가 개념적으로 완벽한 의미를 가져야한다
- 예: Address

값 객체의 사용
- 식별자가 없기 때문에 아무래도 쉽게 만들고 폐기할 수 있다
- 설계를 단순하게 만든다
- 불변
   - 수정할 수 없게 만든다. 생성자를 통해서 생성되고 그 이후에는 상태가 변경되지 않는다. 
   - 다른 값을 지난 값 객체가 필요하다면, 다른 값 객체를 하나 더 만들어준다
   - 불변이면 동시성 문제에서 안전하다

_책의 비행예제는 좀 이상한것 같은데 이야기해보자_

## 서비스
_우선 여기서의 서비스는 도메인 서비스를 말하는것 같다_

배경
- 도메인의 행위 가운데 어떤 행동이나 일부 동사는 어떤 객체에도 속하지 않는게 있다. 하지만 중요해서 무시할 수는 없고, 그렇다고 특정 엔티티에 넣어 버릴 수도 없다
- 행위는 한 객체에 포함되어야만 하는데, 때때로 이런 유형의 행위가 여러개의 서로다른 클래스에 걸쳐서 동작하기도한다. 
   - 예: 계좌 이체. source/destination 어디에 있어야할까? 
- 이런 유형의 행위가 도메인에서 식별되었을 때 좋은 해결은 행위를 서비스로 정의하는 것이다. 

서비스 객체
- 내부적인 상태는 가지지 않으면서 도메인에 기능을 제공하는 목적을 지닌다. 
- 엔티티와 값 객체에 기여하는 관련된 기능들을 묶을 수 있다. 하나의 개념을 캡슐화한 것이고, 도메인에서 명확하게 구분되어야 하기 때문에 명시적으로 선언하는 것이 좋다. 
   - 많은 객체가 관계를 맺는 지점이 된다

서비스 특징
1. 서비스에 의해 수행되는 오퍼레이션은 일반적으로 엔티티 또는 값 객체에 속할 수 없는 도메인의 개념을 나타낸다
2. 수행되는 오퍼레이션은 도메인의 다른 객체를 참조한다
3. 오퍼레이션은 상태를 저장하지 않는다

위치
- 서비스는 애플리케이션 레이어에 속할 수도 있는데, 이러한 서비스들은 도메인 레이어에 속하는 서비스들과 구분이 어렵다.
   - _계층이 구분되고, 이름으로 구분할 수도 있고, 애노테이션도 구분할 수도 있지 않을까?_
- 오퍼레이션이 개념적으로 애플리케이션 레이어에 속하는 일을 수행한다면 애플리케이션 레이어에 속하는 것이 맞다. 만약에 오퍼레이션이 도메인 객체에 관한 것이고, 도멘인과 연관되어 있다면 도메인 레이어에 속한다. 
   ```
   예를 들어서 계좌 이체를 한다고 할때, 
   - 애플리케이션 레이어
      1. 계좌 이체를 한다
      2. 계좌 이체 결과를 카카오톡 알람으로 전달한다
         -> 인프라를 호출할 수도 있고, 도메인 서비스를 통해서 인프라를 호출할 수도 있고 이건 구현에 따라서 다를듯하다
   - 도메인 레이어
      1. 계좌 이체를 한다
         1-1: A계좌에서 돈을 차감한다
         1-2: B계좌에 돈을 입금한다
   ```

## 모듈
_읽어도 잘 모르겠다...패키지의 개념으로 생각하고 접근하니 이해가 되었다_

배경
- 애플리케이션이 크고 복잡할 경우 모델은 점점 커지는 경향이 있다. 어떤 지점에 다다르면 모델 전체를 가지고 이야기하는게 어려워지게 된다
- 이를 위해서 모델을 모듈로 나누어 구조화할 필요가 있다. 
- 모듈화란 관련된 개념과 작업을 조직화하여 복잡도를 감소시키는 기법이다. 

모듈화를 하면 밀접한 관계를 지닌 클래스들을 하나의 모듈로 정의하는 방법이 권장되기 때문에, 코드 레벨에서 응집도를 높일 수도 있다. 
- 통신 응집도: 모듈의 일부가 같은 데이터를 다룰 때 얻을 수 있다
- 기능 응집도: 모듈의 모든 부분이 잘 정의된 임무를 함께 수행하고 있을 때 얻어진다.

모듈의 이름도 유비쿼터스언어에서 만들어진다. 

[이해에 도움을 받았던 아티클](https://www.culttt.com/2014/12/10/modules-domain-driven-design)
```
A Module serves as a container for a specific set of classes of your application. 
// 애플리케이션 모델은 특별한 클래스들을 묶어주기 위한 컨테이너 같은 개념을 제공한다
In PHP this would be a specific namespace that contains all of the related classes for that specific concept.
// PHP에서는 네임스페이스의 개념이라고 보면 된다

The name of the Module should be derived directly from the Ubiquitous Language and should reflect an important concept from the Domain. 
// 모듈의 이름은 유비쿼터스 언어로부터 나와야하고, 도메인의 중요한 컨셉을 반영(투엉)해야한다.
Any member of the team should be able to tell you what role and responsibilities any particular Module should possess, given it’s name.
// 그래서 팀원 누구라도 해당 모듈의 이름을 보고 모듈의 역할이나 책임을 설명할 수 있어야한다.

So instead of grouping the code around users under a Users namespace, instead use the word that is directly derived from the Ubiquitous Language, so anyone on the team will understand what this specific Module is used for.
// 그래서 User와 관련된 클래스들을 Users라는 네임스페이스에 넣는것 대신에 유비쿼터스 언어를 바탕으로 만들어져야 한다. 
// 그로인해서 팀원 누구라도 특정 모듈이 어디에 쓰이는 것을 모듈 이름을 보고 이해할 수 있다. 

A Module will typically contain one, or sometimes multiple Aggregates that are highly cohesive. 
// 모듈은 전형적으로는 1개의 애그리거트를 가지지만, 때때로 애그리거트들 사이에 응집성이 있다면 이들은 하나의 모듈에 같이 포함될 수 있다. 
If you have multiple Aggregates in a Module, but one is not cohesive with the others, it’s time to break it out into its own Module.
// 그래서 만약에 하나의 모듈에 2개 이상의 애그리거트가 있을 때, 특정 애그리거트가 다른 애그리거트들과 관련이 없다면 다른 모듈로 분리해야한다. 

Modules should be organised by concepts from the Domain, and not by the type of class. 
// 모듈은 클래스의 타입이 아니라, 도메인의 컨셉을 기준으로 구성요소를 묶어야한다.
For example, don’t group all of your Aggregates, Services and Factories into different Modules based upon the type of class.
// 예를 들어서, 클래스의 타입이 다르다고 해서 애그리거트, 서비스, 팩토리 들을 서로 다른 모듈에 넣지 말아야한다. 
Instead, each Module should have the appropriate classes to model the concept and functionality of that specific aspect of the Domain.
// 대신에, 각 모듈은 도메인의 컨셉이나 기능의 관점에서 적절한 클래스들을 가지고 있어야한다

Most organisations will have such a large Domain Model it is important to split it into multiple Bounded Contexts. 
// 대부분의 큰 도메인 모델을 가지고 있는 조직들에게는, 도메인 모델을 복수의 바운디드 컨텍스트에 나누어서 넣는게 중요하다. 
This keeps the context and integrity of the internal concepts inside the Bounded Context consistent and unified.
// 이는 바운디드 컨텍스트 내부의 컨텍스트나 무결성을 일관되고 통일되도록 유지시켜준다. 
Inside the Bounded Context, each concept should be broken down into Modules. A Module will represent the related classes of a specific concept of that Bounded Context.
// 바운디드 컨텍스트 안에서 각각의 컨셉들은 모듈로 분리될 수 있는데, 이러한 모듈은 컨셉과 연관된 클래스들을 포함한다. 
So Modules represent important concepts inside of Bounded Contexts.
// 따라서 모듈은 바운디드 컨텍스트 안에서, 바운디드 컨텍스트의 중요한 컨셉을 표현하는데 사용된다. 
```

## 애그리거트
객체의 생명 주기를 관리하는 패턴
- 애그리거트: 객체의 소유권과 경계를 정의
- 팩토리: 객체의 생성
- 리파지토리: 객체의 저장

도메인 모델은 단순하고 이해하기 쉽게 만들어야한다
- 모델 하나는 굉장히 많은 도메인 객체를 담을 수 있다
- 많은 정보들 속에서 도메인에 대한 깊은 이해를 표현하지 않는 부분이나 관계는 제거한다.
   - 실제 도메인에는 존재하지만, 우리가 구현하는 부분에는 필요하지 않은 것들

그런데 복잡한 도메인은 단순화 시켜도 그 안에서 많은 관계가 존재한다
- 예: 은행 시스템
   - 고객 데이터를 포함하고 처리한다
   - 그 안에는 개인정보, 계좌 번호, 잔액, 수행 오퍼레이션등 많은 관계가 있는데, 고객 데이터를 삭제한다면 이 모든 관계 정보다 함께 삭제되어야한다. 
   - 변경에 대해서도 무결성이 보장되어야한다. 
      - _예를 들어서 출금 오퍼레이션은 처리 되었는데, 잔액이 변경이 안되어 있으면 안된다_
- 이러한 작업은 DB의 트랜잭션을 통해서 수행되는데, 데이터 무결성에 대한 부분은 모델 수준에서 해결하는 편이 바람직하다
- 하지만 많은 관계 속에서 일관성을 유지하는 것은 어렵다

애그리거트를 사용하자
- 데이터를 변경할 때 하나의 단위로 간주되는 관련된 객체의 집합
- 객체의 외부와 내부를 가르는 경계를 정해서 구분한다
- 애그리거트는 root를 가진다. 
   - root는 외부에서 접근할 수 있는 창구. 다른 객체들은 root를 통해서만 참조할 수 있다
   - 애그리거트 내 객체들에 대한 참조를 담고 있다
   - root를 삭제하면 관련 객체가 모두 삭제되고, root를 변경하면 애그리거트 내 모든 객체에 간접적으로 영향을 주게 된다. 
   - root를 통해서만 변경을 할 수 있기 때문에 불편식을 강제하기가 쉽다
   - 전역 식별자를 가지며, 불변식을 검증할 책임을 가진다
- 오퍼레이션이 완료되면 외부객체가 내부 객체를 더이상 참조하지 못하는 하는 조건을 달아서 root가 내부 객체에 대한 일시적인 참조를 전달하는 것은 가능하다. 
   - 값 객체의 복사본을 외부에 전달하는 방법
   - _info 같은 개념으로 보면 되지 않을까?_

![2-2](/Images/DDDQ/p80.jpg)
![2-2](/Images/DDDQ/dddstart-3-3.jpg)
![2-2](/Images/DDDQ/dddstart-3-7.jpg)

## 팩토리
엔티티와 애그리거트는 root엔티티의 생성자를 통해서 생성하기에는 너무 크거나 복잡할 경우가 있다. 
- 생성자를 이용할 경우 객체를 생성하는 동안 객체의 내부 구조, 그 객체가 포함하는 다른 객체와의 연관관계, 생성 규칙등에 대한 지식이 필요할 수 있다
   ```
   항상 그렇다는 것은 아니다.
   ```

하나의 객체를 생성하는 것은 그 자체로 주요 오퍼레이션에 속하지만, 꼭 이 책임을 생성된 객체가 부담하지 않아도 된다. 

복잡한 객체 생성 절차를 캡슐화할 수 있는 개념이 필요한데, 이것이 팩토리이다. 
- 객체 생성에 필요한 지식을 캡슐화하는데 사용되며, 애그리거트를 생성하는데 특히 유용하다
- 팩토리는 root가 생성될 때 모든 객체가 불변식에 맞게 생성될 수 있도하는 책임을 가져야한다
- 팩토리 자체는 도메인 모델 내에서 비지니스 로직에 대한 책임을 지지는 않지만, 도메인 설계의 일부이다. 

팩토리를 구현하는 설계 패턴
- 팩토리 메서드 패턴: [Wikipedia](https://ko.wikipedia.org/wiki/%ED%8C%A9%ED%86%A0%EB%A6%AC_%EB%A9%94%EC%84%9C%EB%93%9C_%ED%8C%A8%ED%84%B4)
- 추상 팩토리 패턴: [Wikipedia](https://ko.wikipedia.org/wiki/%EC%B6%94%EC%83%81_%ED%8C%A9%ED%86%A0%EB%A6%AC_%ED%8C%A8%ED%84%B4)

팩토리를 생성할 때에는 객체의 캡슐화를 깨트리기 때문에 매우 주의해서 작업해야한다. 
- 불변식에 영향을 주는 변경이 발생하면 팩토리를 수정해야한다
- 팩토리는 각 객체들사이에 연관관계에 대한 로직이 들어가는데, 이 로직은 어떤 객체에도 속하지 않는 로직이다. 객체 생성에 대한 로직이기 때문이다. 
- __이를 통해서 객체는 좀 더 단순한 상태로 유지되고, 복잡한 생성 로직을 포함하지 않은 본연의 목적(비지니스 로직 수행)에 충실해야한다__

앞에서 말한 내용이지만, 항상 팩토리가 필요한 것은 아니다. 아래 케이스는 생성자를 사용한다
- 생성 작업이 복잡하지 않다
- 객체의 생성이 다른 객체의 생성과 연관되어 있지 않으며, 모든 속성이 생성자를 통해 전달되어야한다. (_AllArgsConstructor겠지_)
- 클라이언트가 구현에 관심이 있어서, 사용한 전략 패턴을 선택하려고한다.
   - _의존성 주입을 이용해서 런타임에 객체를 변경_
- 클래스가 해당 타입이다. 관련된 계층 구조가 없어서 concrete 구현 목록에서 선택할 필요가 없다. 

## 리파지토리(Repository)
```
집합이 실제 값의 집합과 Aggregate로 같이 사용되니 헷갈린다. 여기는 집합, 애그리거트로 구분해서 적어본다. 
클라이언트는 엔티티를 사용하는 클라이언트(application service, domain service)로 생각했다. 설명 내용을 보면 domain service가 좀 더 맞는듯 하다. 
```
Factory가 객체의 생성을 책임진다면, 이미 생성된 체를 참조할 때는 어떻게 해야할까?
- 예를 들어서 애그리거트의 값 객체를 얻기 위해서는 root의 참조를 얻어야하는데 어떻게 해야할까?
- 항상 메모리에 객체를 보관할 수는 없다. 

데이터베이스 또는 다른 영속적인 형태로 저장된 값을 조회함으로써 얻을 수 있다. 
- 객체가 집합의 root라면 엔티티
- 값 객체라면 엔티티로부터 그 값을 얻을 수 있다.

하지만 클라이언트에서 이 값을 직접 조회하는 것은 문제가 있을 수 있다. 
- 제일 빠르고 간단한 해결책처럼 보이기는 하지만, 설계에는 좋지 않다. 
- 이렇게 되면 도메인 레이어에 DB 관련 코드가 산재하게 된다. 도메인 모델도 도메인의 개념 자체보다는 인프라스트럭처 관련된 부분을 다루게 된다. 
   - 특정 기술에 얽매이게 된다. DB를 변경한다면 어떻게 될까?

__리파지토리__ 를 사용해서 객체의 참조를 얻는 로직을 캡슐화하자. 
- 도메인 객체는 인프라스트럭처를 직접 참조하는게 아니라, 리파지토리를 통해서만 얻을 수 있게 된다. 
- 리파지토리는 전략(strategy) 패턴을 포함할 수도 있는데, 객체에 따라 구현체를 변경하면서 저장영역을 다르게 구성할 수도 있다.
   ![2-2k](/Images/DDDQ/p90.jpg)
- root에 대해서만 리파지토리를 제공한다
   - 애그리거트를 제공하는 메서드를 제공해줘야한다
- __리파지토리는 인프라스트럭처의 구현과 매우 유사하지만, 리파티토리 인터페이스 자체는 순수하게 도메인 모델이다__
   ![2-2](/Images/DDDQ/p94.jpg)
```
89페이지에 7번째줄부터 무슨 말인지 잘 모르겠다;;;
```

## 마지막으로 모델 주도 설계를 위한 블록 한번 더
![54](/Images/DDDQ/p53.jpg)