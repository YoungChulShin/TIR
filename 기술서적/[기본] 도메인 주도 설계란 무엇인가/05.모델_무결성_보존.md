# 모델 무결성 보존

이 장에서는 여러팀이 공동 작업이 필요한 대규모 프로젝트를 다룬다. 
- 보통 여러팀이 작업을 하게 되고, 각 팀의 모델의 특정 부분을 할당 받아 작업하는 방법으로 병렬적으로 수행한다.
- 하지만 모델이 크기 때문에 전체 모델을 완벽하게 이해하지는 못한다. 

좋은 모델에서 불일치가 많은 쪽으로 변질되기는 쉽고, 대형 프로젝트 전체를 커버하는 모델의 무결성을 지키려는 작업은 너무 어려운 일이다. 

결국에는 쪼개질 큰 모델을 유지하려고 노력하는 대신, 의도적으로 여러개의 모델로 분리하는 시도를 해보자. 
- 모델들은 각각 지켜야하는 계약들을 준수하는 한 잘 통합될 것이다. 
- 모델들의 경계가 명확히 구분되어야하고, 모델들 간의 관계는 정밀하게 맺어져야한다. 

아래 그림은 모델의 무결성을 유지하기 위한 기술의 집합과 관계이다. 
- ![109](/Images/DDDQ/p109.jpg)

## 분할된 컨텍스트(Bounded Context)
모델은 각각 하나씩 컨텍스트가 있다. 
- 모델의 컨텍스트란 모델 안에서 사용된 용어들이 특정한 의미를 가지는 것을 보장할 수 있도록 적용되는 조건들의 집합이라고 할 수 있다

대규모 시스템은 내부에서 각 모델이 섞일 가능성이 있기 때문에 컨텍스트를 정의할 필요하가 있다.
- 일반적인 작은 시스템과는 다르다
- 서로 다른 모델에 기반한 코드를 결합할 경우, 소프트웨어가 이해하게 어렵게 되고 팀 멤버들간에 의사소통이 어려워진다
- 모델은 하나의 팀에 할당하기에 적합할 만큼 작아야한다

모델의 범위를 정의하는 작업
- 기본 개념은 모델의 범위를 정하고, 컨텍스트간 경계를 명시적으로 설정한 다음, 모델이 통합된 상태를 최대한 유지하는 것
- 경계 내에서 모델을 엄격하게 유지하되, 밖에서 등장한 이슈에 의해서 산만해지면 안된다

분할된 컨텍스트
- 발전하는 모델에 담길 논리적 프레임
- 모듈은 구성요소들을 조직화기 위해서 사용. 바운디드 컨텍스트는 모듈을 포함하는 개념
- 우리는 바운디드 컨텍스트 안에서 머물며, 모델의 순수성, 일관성, 통일성을 지키기위해 노력한다.

여러 모델을 가지기 위한 대가
- 모델 간의 경계와 관계를 정의해야한다
- 이를 위해서 부가적인 노력과 설계에 노력을 기울여야한다

전자 상거래 시스템 예시
- 요구 사항
   - 쇼핑몰 서비스 (고객 관리, 로그인, 구매, 주문)
   - 이메일 발송
   - 보고서 생성
- 모델
   - 처음에는 전자상거래시스템이라는 하나의 모델에서 출발
   - 조금만 더 고민해보면 쇼핑몰 시스템과 보고서 시스템은 연관되지 않음을 발견하게 된다
   - 최종적으로 전자상거래 전반과 보고서 모델을 별도로 만들고, 애플리케이션도 별도로 만들어질 수 있다

## 지속적인 통합
한번 분할된 컨텍스트가 정의되면, 우리는 이것을 건강한 상태로 유지시켜야한다. 

만약에 하나의 팀에서 분할된 컨텍스트로 작업을 한다면, 모델의 각 구성요소가 어떻게 동작하는지 확실히 이해하기 위해서 의사소통을 계속 할 필요가 있다. 
- 이해도가 떨어진다면 원래 의도와 다른 방향으로 코드가 수정될 수 있다

모델은 초기부터 완벽할 수 없기 때문에, 개발 프로세스 동안 계속 피드백을 받고 새로운 요소가 추가될 수 있다. 
- 이러한 변경은 지속적으로 통합이 되어야한다
- 그리고 코드가 올바르게 구현될 수 있도록 보장할 수 있는 통합된 프로세스가 필요하다. 

프로세스
- 일일 단위의 통합
- 자동화 빌드
- 자동화 테스트

## 컨텍스트 맵
컨텍스트 맵
- 서로 다른 분할된 컨텍스트들과 그들의 관계에 대한 개요를 표현한 문서
- 양식은 다이어그램일 수도 있고 다른 문서일 수도 있다
![117](/Images/DDDQ/p117.jpg)
- __중요한 것은 모든 사람이 컨텍스트 맵을 공유하고 이해하는 것__
   
각 모델의 기능은 전체적인 시스템의 일부이기 때문에 반드시 통합되어야한다. 컨텍스트가 명확하게 정의되어 있지 않다면 서로 중복되었을 확률이 높다.

각 분할된 컨텍스트는 유비쿼터스 언어의 일부인 고유한 이름이 있어야한다. 

패턴
- 공유 커널(shared kernel)
- 고객-공급자 패턴
- 분할 방식
- 오픈 호스트 서비스
- 변질 방식

### 패턴 #1 - 공유 커널
상황
- 분할된 컨텍스트를 기반으로 팀을 여럿으로 나눴다
- 애플리케이션에서 서로 밀접하게 관련되어 있는 팀이 있는데, 협조가 잘 안된다

문제
- 한동안은 앞으로 달려나갈 수 있지만, 특정 시점부터 결과물들이 잘 들어맞지 않는 문제가 생긴다.
- 번역을 담당할 계층을 만들고 개발을 할 것이고, 노력이 중복으로 들어가고, 공통 유비쿼터스 언어의 장점이 사라지게 된다. 
   - _잘 들어맞지 않아서 맞추려는 노력_

방법
- 도메인 모델의 일부를 두 팀이 공유한다
   - 도델의 부분 뿐 아니라 코드 및 데이터베이스의 설계 일부도 포함한다
   - _프라임과 라스트마일간에 상점, 지점 정보?_
   ![120](/Images/DDDQ/p120.jpg)

주의점
- 다른팀과 협의하지 않고 변경해서는 안되는 공유요소가 생기게 된댜
- 팀 내의 지속적인 통합보다는, 그 빈도를 덜 하게 한다
- 통합 과정에서는 양팀 모두의 테스트가 수행되어야한다
- 목적은 중복을 줄이는 것이지만, 분할된 컨텍스트는 유지되어야한다

### 패턴 #2 - 고객 공급자
상황
- 두 서브시스템에서 한쪽이 다른 한쪽에 완전히 의존하는 방식. 한쪽의 처리 결과가 다른 한쪽에 반영되는 경우 (=의존 방향이 단방향)
- 공유커널도 없다. 
- 예: 전자 상거래 시스템에서 '쇼핑 시스템', '리포팅 시스템'의 관계
   ```
   쇼핑 시스템 <---- 리포팅 시스템
   
   쇼핑 시스템은 애플리케이션 관련해서 데이터 상으로 어떤 일이 일어나는지는 상관없다. 상품을 구매하기 위해서 둘러보는 웹 환경을 제공한다. 
   리포팅 시스템은 쇼핑 애플리케이션에 의해 저장된 데이터에 관심이 많고, 이를 사용한다. 
   ```
문제
- 2개의 시스템이 하나의 모델로 되어 있다면, 모델이 변경될 때 수시로 병목이 발생하고, 논쟁의 근원이 될 수 있다. 
- 두 팀이 단일 관리 체계하에 있을 때 잘 동작한다. (같은 팀, 같은 조직))

두 시스템의 연결
- 공급자 서비시스템(쇼핑 시스템)은 소비자 서비시스템(리포팅 시스템)에게 필요한 어떤 명세를 구현해야한다. 
- 만약에 같은 DB를 사용한다면?
   - 한 시스템이 독단적으로 스키마를 변경하는게 어려워진다. (두 팀이 단일 관리 체계하에 있을 때 잘 동작한다)
- 순응적(conformity) 테스트 수트가 만들어져야한다

### 순응
고객-공급자 관계는 양쪽 팀이 관계에 관심이 있을 때 성공할 수 있다. 

상황
- 공급자가 고객의 요구사항을 빠르게 대응하지 못하거나, 무관심하다.
   - 관계가 서로 다른 회사일 경우에 더 그럴 수 있다. 
- 이로 인해서 고객 시스템에서는 일정 지연이 발생한다

고객-공급자 관계에서 공급자가 고객팀의 요구사항을 만족시켜주지 않는다면, 고객팀은 무기력에 빠질 수 밖에 없다. 

고객팀의 선택 - 스스로 자신의 모델과 설계에 최선을 다해야한다
1. 공급자로부터 분리된 필요한 것을 직접 만드는 방식
   - 상황
      - 공급자 서브시스템으로부터 제공되는 이익이 문제를 안고 갈만큼 가치있지 않을 때
   - 항상 옳은 답은 아니다
2. 변역 계층 
   - 상황
      - 공급자팀이 (고객팀과 협의 없이) 모델을 변경할 때
      - 공급자팀의 모델이 사용하기 매우 불편할 때 
   - 자신을 보호하고, 두 컨텍스트를 연결하기 위한 번역계층. (부패 방지 레이어)
3. 순응
   - 상황
      - 고객이 공급자의 모델을 사용해야하고, 모델이 잘 만들어진 경우
   - 고객팀은 전적으로 공급자를 따른다. 
   - 공유 커널과 유사할 수 있지만, 고객은 커널에 변경을 가할 수 없다. 

### 변질 방지 레이어
상황
- 레거시 소프트웨어 또는 분리된 애플리케이션과 상호작용을 해야한다
- 레거시 소프트웨어는 모델링이 잘 되어 있지 않고, 혼란스럽다. 
- 그럼에도 불구하고 우리 모델과 레거시 모델은 일정 수준으로 통합되어야한다. 

상호 작용 방법
1. 네트워크 연결
   - 양쪽 애플리케이션이 동일한 네트워크 통신 프로토콜을 사용
   - 클라이언트는 외부 시스템을 사용하기 위해서 해당 인터페이스에 밀착되어야한다. 
2. 데이터베이스
   - 클라이언트 시스템에 동일한 데이터베이스를 사용한다
   - 원시데이터는 모델에 대한 어떤 정보도 담고 있지 않는다.
      - 관계형 데이터베이스는 그 이면에 많은 의미가 숨어있고, 다른 데이터와 연결관계를 통해서 복잡한 관계망을 형성하고 있다. 

해야하는것
- 외부 모델의 일부분을 DB반영하고
- 외부 방식을 우리의 모델에 적용한다

이 과정에서 우리 모델이 외부 모델로부터 독립되도록 주의해야한다. 

변질 방지 레이어 (Anticorruption Layer)
- 클라이언트 모델과 외부 모델 사이에 존재
- 외부 모델에게 클라이언트 언어가 외닌 외부 언어로 말한다. 번역자 역할. 
- 이를 통해서 클라이언트 모델이 외부로부터 받는 오염없이 순수하고 일관된 형태로 남을 수 있다. 

구현
- 클라이언트 모델 관점에서는 하나의 서비스로 본다
- Facade 패턴
- 어댑터 패턴을 필요로한다 (외부클래스의 인터페이스를 우리가 사용할 수 있는 방법으로 변환)
   ![132](/Images/DDDQ/p132.jpg)


### 분할 방식
지금까지 통합을 하는 방법에 대해서 알아봤다. 통합할 때에는 이로 인해서 생길 이익을 면밀히 검토해야 하고, 가치가 있을 때에만 진행되어야한다. 

통합의 가치가 파생되는 문제점보다 작다고 결론짓는다면 분할 방식으로 가야한다. 

분할 방식 패턴
- 기업 애플리케이션을 몇개의 작은 애플리케이션으로 쪼개에 만들고자 할 때 사용한다
- 쪼개진 작은 애플리케이션 간에는 모델이라는 관점에서 볼 때 거의 또는 전혀 공통점이 없어야한다
- 요구 사항을 공통점이 없는 2개 이상의 집합으로 나눌 수 있는지 잘 살펴보고, 가능하다면 별도의 컨텍스트를 만들고 독립적으로 모델링 할 수 있다
- 독립적으로 분할된 방식은 통합하기는 매우 어렵기 때문에, 다시 통합되지 않는다는 확신이 필요하다. 

### 오픈 호스트 서비스
배경
- 두 시스템을 통합할 때, 번역을 위한 레이어가 만들어진다.
   ```
   A system 이 B system을 사용한다고 할 때, 
   - A system: 클라이언트 시스템
   - B system: 외부 서브시스템

   클라이언트 시스템 --> Translator -->  외부 서브시스템
   ```
- 외부 서비시스템을 사용하는 클라이언트 시스템이 많다면?
   - 전체 클라이언트 시스템을 위한 번역 레이어가 만들어진다
   - 이러한 번역 레이어는 반복적이고 유사한 코드를 많이 포함한다
      ```
      클라이언트 시스템 #1 --> Translator #1 -->  
      클라이언트 시스템 #2 --> Translator #2 -->  외부 서브시스템
      클라이언트 시스템 #3 --> Translator #3 -->  
      ```

외부 서브시스템을 서비스의 제공자로 바라보자
- 외부 서브시스템을 특정 서비스를 통해서만 접근 가능하도록 하는 방식. (책에서는 '외부서브시스템을 서비스로 감싼다'라고 표현)
   ```
   클라이언트 시스템 #1 --> 
   클라이언트 시스템 #2 --> 서비스 -->  외부 서브시스템
   클라이언트 시스템 #3 --> 
   ```
- 외부 서브시스템에 접근할 수 있는 프로토콜을 서비스의 집합으로 만들고 공개해서, 외부 서비시스템과 통합할 클라이언트 시스템은 이 프로토콜을 따르면 통합을 할 수 있는 방법으로 처리
   - _Port & Adaptor 패턴이 생각났다_
   - _외부 클라이언트에서 사용할 수 있는 표준 API를 공개할 수도 있고, 라이브러리를 제공하는 방식으로 할 수도 있을 것 같다_

### 증류(Distillation)
배경
- 도메인의 규모가 크면, 재정의하고 추상화 작업을 거친다고해도 대규모로 표현될 수 있다
- 도메인을 핵심 도메인과 서브 도메인으로 구분하는 작업을 해야한다
- 이 직압을 증류(=혼합체로부터 특별한 물질을 분리하는 것) 라고 표현한다

항공 관제 시스템 예시 - 항로
- 항로 개념
   ```
   비행 계획 -> 설계횐 항로 -> 비행기가 준수해야하는 길
   ```
- 항로는 여러 도메인에서 사용되며, 일반적인 모델로 설계할 수 있다. 관제 시스템의 핵심 도메인은 아니다.
- 항공 관제 시스템의 핵심 도메인은 '데이터를 기반으로 비행기의 궤적을 조화시키는 것'으로 이를 통해서 비행기의 충돌을 막아야한다.
   - 경로 및 경로들간의 의관 관계를 검토하는 것이 핵심
   - 항로는 서브 도메인

하나의 애플리케이션에서 핵심 도메인이라도 다른 애플리케이션에서는 서브도메인이 될 수 있다.
- 각 애플리케이션에 맞게 관계를 결정하는 것이 중요하다

중요한 것은, 핵심 도메인을 찾아서 가치있고 특화된 개념을 강조하고, 작게 유지하는 것이다. 
- 모델에 관련성이 없는 내용이 포함되어 있다면 복잡도만 증가시킬 수 있다.
- 이러한 응집도가 높은 서브도메인을 식별하고 분리하는 작업을 해야한다
   - _우리는...지오 코딩? 메시지 서비스?_

서브 도메인 구현
1. 상용 솔루션 사용
2. 아웃 소싱
3. 기존 모델: 이미 만들어진 모델을 사용하는 것. (_잘 모르겠다)_)
4. 사내 개발: 높은 통합을 이룰 수 있지만, 유지보수 비용이 올라간다

