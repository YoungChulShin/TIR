# 모델 무결성 보존

이 장에서는 여러팀이 공동 작업이 필요한 대규모 프로젝트를 다룬다. 
- 보통 여러팀이 작업을 하게 되고, 각 팀의 모델의 특정 부분을 할당 받아 작업하는 방법으로 병렬적으로 수행한다.
- 하지만 모델이 크기 때문에 전체 모델을 완벽하게 이해하지는 못한다. 

좋은 모델에서 불일치가 많은 쪽으로 변질되기는 쉽고, 대형 프로젝트 전체를 커버하는 모델의 무결성을 지키려는 작업은 너무 어려운 일이다. 

결국에는 쪼개질 큰 모델을 유지하려고 노력하는 대신, 의도적으로 여러개의 모델로 분리하는 시도를 해보자. 
- 모델들은 각각 지켜야하는 계약들을 준수하는 한 잘 통합될 것이다. 
- 모델들의 경계가 명확히 구분되어야하고, 모델들 간의 관계는 정밀하게 맺어져야한다. 

아래 그림은 모델의 무결성을 유지하기 위한 기술의 집합과 관계이다. 
- ![109](/Images/DDDQ/p109.jpg)

## 분할된 컨텍스트(Bounded Context)
모델은 각각 하나씩 컨텍스트가 있다. 
- 모델의 컨텍스트란 모델 안에서 사용된 용어들이 특정한 의미를 가지는 것을 보장할 수 있도록 적용되는 조건들의 집합이라고 할 수 있다

대규모 시스템은 내부에서 각 모델이 섞일 가능성이 있기 때문에 컨텍스트를 정의할 필요하가 있다.
- 일반적인 작은 시스템과는 다르다
- 서로 다른 모델에 기반한 코드를 결합할 경우, 소프트웨어가 이해하게 어렵게 되고 팀 멤버들간에 의사소통이 어려워진다
- 모델은 하나의 팀에 할당하기에 적합할 만큼 작아야한다

모델의 범위를 정의하는 작업
- 기본 개념은 모델의 범위를 정하고, 컨텍스트간 경계를 명시적으로 설정한 다음, 모델이 통합된 상태를 최대한 유지하는 것
- 경계 내에서 모델을 엄격하게 유지하되, 밖에서 등장한 이슈에 의해서 산만해지면 안된다

분할된 컨텍스트
- 발전하는 모델에 담길 논리적 프레임
- 모듈은 구성요소들을 조직화기 위해서 사용. 바운디드 컨텍스트는 모듈을 포함하는 개념
- 우리는 바운디드 컨텍스트 안에서 머물며, 모델의 순수성, 일관성, 통일성을 지키기위해 노력한다.

여러 모델을 가지기 위한 대가
- 모델 간의 경계와 관계를 정의해야한다
- 이를 위해서 부가적인 노력과 설계에 노력을 기울여야한다

전자 상거래 시스템 예시
- 요구 사항
   - 쇼핑몰 서비스 (고객 관리, 로그인, 구매, 주문)
   - 이메일 발송
   - 보고서 생성
- 모델
   - 처음에는 전자상거래시스템이라는 하나의 모델에서 출발
   - 조금만 더 고민해보면 쇼핑몰 시스템과 보고서 시스템은 연관되지 않음을 발견하게 된다
   - 최종적으로 전자상거래 전반과 보고서 모델을 별도로 만들고, 애플리케이션도 별도로 만들어질 수 있다

## 분할 방식
지금까지 통합을 하는 방법에 대해서 알아봤다. 통합할 때에는 이로 인해서 생길 이익을 면밀히 검토해야 하고, 가치가 있을 때에만 진행되어야한다. 

통합의 가치가 파생되는 문제점보다 작다고 결론짓는다면 분할 방식으로 가야한다. 

분할 방식 패턴
- 기업 애플리케이션을 몇개의 작은 애플리케이션으로 쪼개에 만들고자 할 때 사용한다
- 쪼개진 작은 애플리케이션 간에는 모델이라는 관점에서 볼 때 거의 또는 전혀 공통점이 없어야한다
- 요구 사항을 공통점이 없는 2개 이상의 집합으로 나눌 수 있는지 잘 살펴보고, 가능하다면 별도의 컨텍스트를 만들고 독립적으로 모델링 할 수 있다
- 독립적으로 분할된 방식은 통합하기는 매우 어렵기 때문에, 다시 통합되지 않는다는 확신이 필요하다. 

## 오픈 호스트 서비스
배경
- 두 시스템을 통합할 때, 번역을 위한 레이어가 만들어진다.
   ```
   A system 이 B system을 사용한다고 할 때, 
   - A system: 클라이언트 시스템
   - B system: 외부 서브시스템

   클라이언트 시스템 --> Translator -->  외부 서브시스템
   ```
- 외부 서비시스템을 사용하는 클라이언트 시스템이 많다면?
   - 전체 클라이언트 시스템을 위한 번역 레이어가 만들어진다
   - 이러한 번역 레이어는 반복적이고 유사한 코드를 많이 포함한다
      ```
      클라이언트 시스템 #1 --> Translator #1 -->  
      클라이언트 시스템 #2 --> Translator #2 -->  외부 서브시스템
      클라이언트 시스템 #3 --> Translator #3 -->  
      ```

외부 서브시스템을 서비스의 제공자로 바라보자
- 외부 서브시스템을 특정 서비스를 통해서만 접근 가능하도록 하는 방식. (책에서는 '외부서브시스템을 서비스로 감싼다'라고 표현)
   ```
   클라이언트 시스템 #1 --> 
   클라이언트 시스템 #2 --> 서비스 -->  외부 서브시스템
   클라이언트 시스템 #3 --> 
   ```
- 외부 서브시스템에 접근할 수 있는 프로토콜을 서비스의 집합으로 만들고 공개해서, 외부 서비시스템과 통합할 클라이언트 시스템은 이 프로토콜을 따르면 통합을 할 수 있는 방법으로 처리
   - _Port & Adaptor 패턴이 생각났다_
   - _외부 클라이언트에서 사용할 수 있는 표준 API를 공개할 수도 있고, 라이브러리를 제공하는 방식으로 할 수도 있을 것 같다_

## 증류(Distillation)
배경
- 도메인의 규모가 크면, 재정의하고 추상화 작업을 거친다고해도 대규모로 표현될 수 있다
- 도메인을 핵심 도메인과 서브 도메인으로 구분하는 작업을 해야한다
- 이 직압을 증류(=혼합체로부터 특별한 물질을 분리하는 것) 라고 표현한다

항공 관제 시스템 예시 - 항로
- 항로 개념
   ```
   비행 계획 -> 설계횐 항로 -> 비행기가 준수해야하는 길
   ```
- 항로는 여러 도메인에서 사용되며, 일반적인 모델로 설계할 수 있다. 관제 시스템의 핵심 도메인은 아니다.
- 항공 관제 시스템의 핵심 도메인은 '데이터를 기반으로 비행기의 궤적을 조화시키는 것'으로 이를 통해서 비행기의 충돌을 막아야한다.
   - 경로 및 경로들간의 의관 관계를 검토하는 것이 핵심
   - 항로는 서브 도메인

하나의 애플리케이션에서 핵심 도메인이라도 다른 애플리케이션에서는 서브도메인이 될 수 있다.
- 각 애플리케이션에 맞게 관계를 결정하는 것이 중요하다

중요한 것은, 핵심 도메인을 찾아서 가치있고 특화된 개념을 강조하고, 작게 유지하는 것이다. 
- 모델에 관련성이 없는 내용이 포함되어 있다면 복잡도만 증가시킬 수 있다.
- 이러한 응집도가 높은 서브도메인을 식별하고 분리하는 작업을 해야한다
   - _우리는...지오 코딩? 메시지 서비스?_

서브 도메인 구현
1. 상용 솔루션 사용
2. 아웃 소싱
3. 기존 모델: 이미 만들어진 모델을 사용하는 것. (_잘 모르겠다)_)
4. 사내 개발: 높은 통합을 이룰 수 있지만, 유지보수 비용이 올라간다

