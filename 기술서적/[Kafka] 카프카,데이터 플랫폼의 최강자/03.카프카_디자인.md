## 3.1 카프카 디자인의 특징
등장 배경 및 기능
- 분산된 파이프라인을 표준화 및 통합을 원했고 처리량에 중점을 두고 설계
- 그 결과 높은 처리량, 빠른 메시지 전송, 운영 효율화 등을 위한 분산 시스템, 페이지 캐시, 배치 전송 처리 등의 기능이 구현되었다

### 3.1.1 분산 시스템
분산 시스템 장점
- 다른 시스템보다 높은 성능을 얻을 수 있다
   - CPU 처리량을 분산 시킬 수 있다
- 하나의 서버 또는 노드 등에 장애가 발생하면 다른 서버 또는 노드가 대신 처리한다
- 시스템 확장이 용이하다

### 3.1.2 페이지 캐시
페이지 케시
- OS는 물리적 메모리에 애플리케이션이 사용하는 부분을 할당하고 남은 잔여 메모리 일부를 페이지 캐시로 유지해서 OS의 성능을 높인다
- 결국 처리 속도가 빠르기 때문에 전체적인 성능 향상을 시킬 수 있따
- 카프키 <-> 페이지 캐시 <-> 디스크

JVM 힙사이즈
- 기본 값으로 1GB의 힙메모리를 사용하고, 설정파일에서 변경 가능하다
- 컨플루언트 사의 도큐먼트에 따르면 카프카는 초당 메[시지 단위, 메가비트 단위를 처리함에 있어 5GB의 힙 메모리면 충분하고, 남은 메모리로 페이지캐시를 사용하기를 권장한다

### 3.1.3 배치 전송 처리
작은 I/O를 묶어서 한번처리할 수 있도록 한다
- 예를 들어 A,B,C,D의 메시지를 보내는데 각 1초라고 하면, 4개는 4초가 걸리는데, 이를 묶어서 1초에 한번에 보내는 방식

## 3.2 카프카 데이터 모델
### 3.2.1. 토픽의 이해
토픽
- 카프카 클러스터는 토픽이라고 불리는 곳에 데이터를 저장한다
- 기능 단위로만 토픽을 구분하기 보다, '접두어 + 기능' 형식으로 이름을 구성하는게 좋다

### 3.2.2. 파티션의 이해
파티션
- 메시지를 다시 구분해서 보내는 방법
- 토픽을 파티션으로 나누면 그만큼 한번에 보낼 수 있는 메시지의 양이 늘어난다
- 따라서 파른 전송을 위해서는 토픽의 파티션수를 늘려줘야 하며, 그만큼 프로듀서 수도 늘려야 제대로 된 효과를 볼 수 있다

무조건 파티션 수를 늘리는 것은 좋지 않다
- 파일 핸들러의 낭비
- 장애 복구 시간 증가
   - 한 예로, 리플리케이션을 이용한다고 할 때, 내부적으로 장애가 발생하면 이를 해결하기 위해서 진행하는 리더 선출 작업에서 시간이 만힝 걸린다

파티션 수의 증가는 지원하지만, 반대로 줄이는 것은 지원하지 않는다

### 3.2.3 오프셋과 메시지 순서
오프셋
- 각 파티션마다 메시지가 저장되는 위치
- 파티션 내에서 유일하고 순차적으로 증가하는 숫자형태

## 3.3 카프카의 고가용성과 리플리케이션
### 3.3.1 리플리케이션 팩터와 리더, 팔로워의 역할
리플리케이션
- 데이터를 파티션끼리 복제 공유하는 방법
- 특정 파티션이 다운되었을 때 다른 파티션에서 이어서 작업을 해줄 수 있다

리플리케이션 팩터
- 리플리케이션 관리 숫자
- 기본 값은 1이며, 수정 가능하다

리더
- 모든 읽기와 쓰기는 리더를 통해서 일어난다

팔로워
- 리더의 데이터를 그대로 리플리케이션만 한다

리플리케이션 단점
- 그만큼의 저장소가 추가로 필요하다
- 리소스 사용량 증가. 동기화를 위해서 백그라운드에서 작업이 계속 일어날 것이기 때문에

### 3.3.2 리더와 팔로워의 관리
리더와 팔로워의 관계
- 팔로워는 리더를 주기적으로 보면서 자신에게 없는 데이터를 리더로부터 가져오는 방법으로 리플리케이션을 유지한다
- 리더가 다운되면 팔러워 중에서 다시 리더를 선출해서 작업을 이어나갈 수 있다
- ISR(In Sync Replica)
   - 현재 리플리케이션 되고 있는 리플리케이션 그룹
   - 리더는 그룹 내에서 특정 팔로워가 정상적으로 동작하는지 체크하는데, 이 과정에서 이상이 있음을 감지하면 ISR 그룹에서 추방시킨다

모든 브로커가 다운된다면
1. 마지막 리더가 살아나기를 기다린다
2. ISR에서 추방되었지만 먼저 살아나면 자동으로 리더가 된다
   - 그 사이에 발생하는 메시지에는 손실이 발생한다
   - 올드 리더가 살아났을 때 이미 다른 리더가 존재한다면, 올드리더는 팔로워로 바뀌고 새로운 리더를 동기화한다

## 3.5 카프카에서 사용되는 주키퍼 지노드 역할
지노드 내에서 폴더의 사용
- 기본적으로 폴더를 설정하지 않으면 지노드 최상단에 구성이 되는데, 이 경우 여러 애플리케이션이 동일한 지노드를 사용하게 되면 충돌이 발생할 수 있다
- 이를 구분해주기 위해서 하위 폴더를 사용한다

controller
- 클러스터의 컨트롤러 정보 확인
- 클러스터 내 블로커 중 하나를 컨트롤러로 선정하고, 브로커 레벨에서 실패를 감지 및 리더 변경의 책임을 가진다
- 컨트롤러 브로커가 다운되면 새로운 브로커가 컨트롤러가 된다

brokers
- 브로커 관련 정보가 저장되며, 카프카 설치시 설정한 브로커 id를 확인할 수 있다

consumers
- 컨슈머 정보가 저장되며, 컨슈머가 각각의 파티션에 대해 어디까지 읽었는지 오프셋 정보가 저장된다

config
- 설정 정보가 저장