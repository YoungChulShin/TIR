# 동시 성능 기법
잘만든 애플리케이션은 멀티코어에 애플리케이션 부하를 고루 분산해서 처리할 수 있다. JVM 같은 애플리케이션 실행 플랫폼음 JIT 컴파일처럼 여러 프로세서 코어를 십분 활용할 수 있는 VM 스레드가 항상 떠 있다.

## 병렬성이란
### 자바 동시성 기초
아래 코드는 멀티스레드 환경에서는 값이 잘못 계산될 수 있다
```java
public class Counter {
    private int i = 0;

    public int increment() {
        // 컴파일 이후에 바이트코드를 보면 'i = i + 1' 코드는 3번의 연산으로 이루어진다
        // 1. i를 읽어온다
        // 2. i에 1을 더한다
        // 3. i를 쓴다
        // 
        // 멀티스레드 환경에서 1이 동시에 수행된다면 최종 결과가 잘못 계산 될 수 있다
        return i = i + 1;
    }   
}
```
- `voatile`을 사용한다고 해도 이 부분은 막을 수 없다. volatile은 가장 최신의 값을 읽어오는 것까지 보장한다. 

Java5 이전에는 synchonized가 유일했는데, synchonized만 추가하면 오히려 성능이 느려질 수도 잇기 때문에 신중히 접근해야한다. 

## 동시성 라이브러리 구축
Java5부터는 언어 수준에서 지원하는 기능에서 탈피해서 고급 동시성 라이브러리와 툴을 자바 클래스라이브러리의 일부로 표준화하려는 움직임이 확산되는 추세이다. 

`java.util.concurrent` 패키지 라이브러리
- 종류
   - 락, 세마포어
   - 아토믹스
   - 블로킹 큐
   - 래치
   - executor
- OS품에서 벗어나 가급적 유저 공간에서 더 많은 일을 하려고한다.
   - OS마다 존재하는 차이점 때문에, 조금 더 넓은 범위에서 일관성을 제공해주려는 목적
- 일부 라이브러리(락, 아토믹스)는 CAS(compare and swap)라는 기법을 구현하기 위해서 저수준 프로세서 명령어 및 OS별 특성을 활용한다
   - CAS: '예상되는 현재 값'과 '원하는 새 값' 그리고 메모리 위치를 전달받아 아래 2가지 일을 처리한다
      1. 예상되는 현재 값을 메모리 위치에 있는 콘텐츠에 비교한다
      2. 두 값이 일치하면 현재 값을 새로운 값으로 교체한다

### unsafe
특징
- 내부 구현 클래스 (jdk.internal.misc)

할 수 있는 일
- 객체는 할당하지만 생성자는 실행되지 않는다
- 원메모리(raw memory)에 엑세스하고 포인터 수준의 연산을 수행한다
- 프로세서별 하드웨어 특성(예: CAS)를 이용한다

이를 통해 아래 작업이 가능해진다
- 신속한 (역)직렬화
- 스레드-안전한 네이티브 메모리 엑세스
- 아토믹 메모리 연산
- 효율적인 객체/메모리 레이아웃
- 커스템 메모리 펜스(연산의 실행 순서를 CPU나 컴파일러가 함부로 못바꾸게 강제하는 기능)
- 네이티브 코드와의 상호작용
- JNI에 관한 다중 운영체제 대체물
- 배열원소에 volatile하게 엑세스

자바 SE 공식 표준은 아니지만, 활용도가 높아서 표준처럼 사용된다

### 아토믹스와 CAS
아토믹스
- 값을 더하고 증감하는 복합 연산을 한다
- 두 개별 스레드가 증분 연산을 하면 currentValue + 1과 currentValue + 2가 반환된다
- volatile의 확장판이라고 할 수 있지만, volatile보다 더 유연하게 사용할 수 있다
- AtomicInteger는 Integer를 상속한 클래스가 아니다

락-프리하기 때문에 데드락은 있을 수 없다
- Unsafe 내부에서 CAS 작업을 반복적으로 시도한다
- 업데이트를 위해서 여러차례 재시도를 할 경우, 재시도 횟수만큼 성능이 나빠진다

### 락과 스핀락
인트린직락(Intricsic lock)
- 고유락
- 유저코드에서 OS를 호출하고, OS를 이용해서 스레드가 따로 신호를 줄 때까지 무한정 기다리게 만드는 것
- 경합중인 리소스가 극히 짧은 시간 동안만 사용할 경우 이런 방식은 막대한 오버헤드를 유발할 수 있다
   - _잠깐만 멈추면 되는데, OS로부터 다시 신호를 받을 때까지 대기하기 때문에 오버헤드를 유발할 수 있다는 것 같다_

스핀락(spinlock)
- 블로킹된 스레드를 CPU에 활성상태로 놔두고, 락을 얻을 때까지 재시도하게 만드는 방법
- 완전히 상호 베타적(mutual-exclusion)인 락보다 가볍게 쓰자는 의도
- 최신 시스템은 대부분 하드웨어가 지원하리라 가정하고 CAS로 스핀락을 구현한다

## 동시 라이브러리 정리
java.util.concurrent 패키지에 동시성 관련 클래스들이 위치한다
### java.util.concurrent 락
`java.util.concurrent.locks.Lock` 인터페이스가 자바5부터 추가되었다
- 인티린직 락보다 더 많은일을 할 수 있다

### 읽기/쓰기 락
읽기와 쓰기의 락을 분리해서 읽기에서는 블로킹을 하지 않도록 설정하면, 읽기 스레드가 상당히 많을 때 스레드 처리율이 올라가고 락킹이 줄어들게 할 수 있다
- 쓰기vs쓰기: 블로킹
- 쓰기vs읽기: 블로킹
- 읽기vs읽기: 논블록

예: java.util.concurrent.locks.ReentrantReadWriteLock

