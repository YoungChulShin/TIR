# 동시 성능 기법
잘만든 애플리케이션은 멀티코어에 애플리케이션 부하를 고루 분산해서 처리할 수 있다. JVM 같은 애플리케이션 실행 플랫폼음 JIT 컴파일처럼 여러 프로세서 코어를 십분 활용할 수 있는 VM 스레드가 항상 떠 있다.

## 병렬성이란
### 자바 동시성 기초
아래 코드는 멀티스레드 환경에서는 값이 잘못 계산될 수 있다
```java
public class Counter {
    private int i = 0;

    public int increment() {
        // 컴파일 이후에 바이트코드를 보면 'i = i + 1' 코드는 3번의 연산으로 이루어진다
        // 1. i를 읽어온다
        // 2. i에 1을 더한다
        // 3. i를 쓴다
        // 
        // 멀티스레드 환경에서 1이 동시에 수행된다면 최종 결과가 잘못 계산 될 수 있다
        return i = i + 1;
    }   
}
```
- `voatile`을 사용한다고 해도 이 부분은 막을 수 없다. volatile은 가장 최신의 값을 읽어오는 것까지 보장한다. 

Java5 이전에는 synchonized가 유일했는데, synchonized만 추가하면 오히려 성능이 느려질 수도 잇기 때문에 신중히 접근해야한다. 

## 동시성 라이브러리 구축
Java5부터는 언어 수준에서 지원하는 기능에서 탈피해서 고급 동시성 라이브러리와 툴을 자바 클래스라이브러리의 일부로 표준화하려는 움직임이 확산되는 추세이다. 

`java.util.concurrent` 패키지 라이브러리
- 종류
   - 락, 세마포어
   - 아토믹스
   - 블로킹 큐
   - 래치
   - executor
- OS품에서 벗어나 가급적 유저 공간에서 더 많은 일을 하려고한다.
   - OS마다 존재하는 차이점 때문에, 조금 더 넓은 범위에서 일관성을 제공해주려는 목적
- 일부 라이브러리(락, 아토믹스)는 CAS(compare and swap)라는 기법을 구현하기 위해서 저수준 프로세서 명령어 및 OS별 특성을 활용한다
   - CAS: '예상되는 현재 값'과 '원하는 새 값' 그리고 메모리 위치를 전달받아 아래 2가지 일을 처리한다
      1. 예상되는 현재 값을 메모리 위치에 있는 콘텐츠에 비교한다
      2. 두 값이 일치하면 현재 값을 새로운 값으로 교체한다

### unsafe
특징
- 내부 구현 클래스 (jdk.internal.misc)

할 수 있는 일
- 객체는 할당하지만 생성자는 실행되지 않는다
- 원메모리(raw memory)에 엑세스하고 포인터 수준의 연산을 수행한다
- 프로세서별 하드웨어 특성(예: CAS)를 이용한다

이를 통해 아래 작업이 가능해진다
- 신속한 (역)직렬화
- 스레드-안전한 네이티브 메모리 엑세스
- 아토믹 메모리 연산
- 효율적인 객체/메모리 레이아웃
- 커스템 메모리 펜스(연산의 실행 순서를 CPU나 컴파일러가 함부로 못바꾸게 강제하는 기능)
- 네이티브 코드와의 상호작용
- JNI에 관한 다중 운영체제 대체물
- 배열원소에 volatile하게 엑세스

자바 SE 공식 표준은 아니지만, 활용도가 높아서 표준처럼 사용된다

### 아토믹스와 CAS
아토믹스
- 값을 더하고 증감하는 복합 연산을 한다
- 두 개별 스레드가 증분 연산을 하면 currentValue + 1과 currentValue + 2가 반환된다
- volatile의 확장판이라고 할 수 있지만, volatile보다 더 유연하게 사용할 수 있다
- AtomicInteger는 Integer를 상속한 클래스가 아니다

락-프리하기 때문에 데드락은 있을 수 없다
- Unsafe 내부에서 CAS 작업을 반복적으로 시도한다
- 업데이트를 위해서 여러차례 재시도를 할 경우, 재시도 횟수만큼 성능이 나빠진다

### 락과 스핀락
인트린직락(Intricsic lock)
- 고유락
- 유저코드에서 OS를 호출하고, OS를 이용해서 스레드가 따로 신호를 줄 때까지 무한정 기다리게 만드는 것
- 경합중인 리소스가 극히 짧은 시간 동안만 사용할 경우 이런 방식은 막대한 오버헤드를 유발할 수 있다
   - _잠깐만 멈추면 되는데, OS로부터 다시 신호를 받을 때까지 대기하기 때문에 오버헤드를 유발할 수 있다는 것 같다_

스핀락(spinlock)
- 블로킹된 스레드를 CPU에 활성상태로 놔두고, 락을 얻을 때까지 재시도하게 만드는 방법
- 완전히 상호 베타적(mutual-exclusion)인 락보다 가볍게 쓰자는 의도
- 최신 시스템은 대부분 하드웨어가 지원하리라 가정하고 CAS로 스핀락을 구현한다

## 동시 라이브러리 정리
java.util.concurrent 패키지에 동시성 관련 클래스들이 위치한다
### java.util.concurrent 락
`java.util.concurrent.locks.Lock` 인터페이스가 자바5부터 추가되었다
- 인티린직 락보다 더 많은일을 할 수 있다
   - lock()을 이용해서 잠금을 획득하고, unlock()을 통해서 해제할 수 있다.
   - tryLock()은 lock을 획득하려고 시도해볼 수 있다. 타임아웃도 설정 가능하다. 
   

### 읽기/쓰기 락
읽기와 쓰기의 락을 분리해서 읽기에서는 블로킹을 하지 않도록 설정하면, 읽기 스레드가 상당히 많을 때 스레드 처리율이 올라가고 락킹이 줄어들게 할 수 있다
- 쓰기vs쓰기: 블로킹
- 쓰기vs읽기: 블로킹
- 읽기vs읽기: 논블록

예: java.util.concurrent.locks.ReentrantReadWriteLock
```java
  private final ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();
  private final Lock readLock = rwl.readLock();
  private final Lock writeLock = rwl.writeLock();
  private Map<String, Integer> ageCache = new HashMap<>();

  public Integer getAge(String name) {
    readLock.lock();
    try {
      return ageCache.get("name");
    } finally {
      readLock.unlock();
    }
  }

  public void updateAge(String name, int newAge) {
    writeLock.lock();
    try {
      ageCache.put(name, newAge);
    } finally {
      writeLock.unlock();
    }
  }
```
- 원하는 블록에 Lock을 걸어서 조금 더 유연하게 처리할 수 있다
- readlock과 writelock을 분리할 수 있다
   - 단일 lock보다 성능이 훨씬 좋아진다

### 세마포어
특징
- 최대 n개 객체까지만 엑세스를 허용한다. 
- 'acquire()' 메서드로 퍼밋을 가져오고, 'release()' 메서드로 반납한다. 
- 공정모드(fair mode, 순서대로 처리)로 설정해서 순차적으로 처리되도록 한다.
- 퍼밋이 1개라면 뮤텍스와 동등하다. 
   - 뮤텍스는 뮤텍스가 걸린 스레드만 해제할 수 있지만, 세머포어는 비소유 스레드도 해제할 수 있다

코드
```java
private Semaphore poolPermits = new Semaphore(2, true);
```

### 래치와 배리어
특징
- 스레드 세트의 실행을 제어하는 유용한 방법.
- count 값을 설정하고, 해당 값이 0이 될 때까지 연관된 스레드를 대기할 수 있도록 한다.
- 한번만 사용할 수 있고, 재사용할 수 없다.

메서드
- `countdown()`: 호출할 때마다 count 값을 1씩 감소한다
- `await()`: count가 0이 될 때 까지 대기한다

## 실행자(Executor)와 태스크 추상화
### 비동기 실행
ExecutorService
- 관리되는 스레드 풀에서 태스크 실행 매커니즘을 규정한 인터페이스
- 풀에 담긴 스레드를 어떻게 관리하고 몇개까지 둘지를 규졍한다
- `submit()` 메서드를 통해서 Runnable, Callable 객체를 전달 받는다

Executors
- 헬퍼 클래스로 스레드풀을 생성하는 팩토리 메서드 시리즈를 제공한다
- 팩토리 메서드
   - newFixedThreadPool(int nThreads)
      - 크기가 고정된 스레드 풀을 지닌 ExecutorService를 생성한다
      - 스레드가 모두 사용중이면, 새 태스크는 큐에 보관한다
   - newCachedThreadPool()
      - 필요한만큼 스레드를 생성하되 가급적 스레드를 재사용한다
      - 생성된 스레드는 60초간 유지되며, 그 이후에는 캐시에서 삭제된다
      - 소규모 비동기 태스크의 성능을 향상시킬 수 있다
   - newSingleThreadExecutor()
      - 스레드 1개만 가동되는 ExecutorService를 생성한다
      - 동시 실행 태스크를 제한해야 하는 경우 사용

일단 태스크가 제출되면 비동기로 실행된다. 
- submit()을 호출하면 Future가 반환되는데, get()을 통해서 블로킹 하거나 isDone()을 통해서 논블로킹 호출을 할 수 있다.

### 포크/조인
ForkJoinPool
- 자바7부터 새로운 ExecutorService 구현체.
- 특징
   1. 하위 분할 태스크를 효율적으로 처리할 수 있다.
   2. 작업 빼앗기(work-strealing) 알고리즘을 구현한다. 
- 어떤 스레드가 자신에게 할당 받은 작업을 모두 마쳤는데 다른 스레드에 백로그가 남아있으면 바쁜 스레드 큐에서 작업을 몰래 가져와서 실행할 수 있다. 

