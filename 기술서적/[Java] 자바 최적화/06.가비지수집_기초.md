# 가바지 수집 기초
가비지 수집의 요채
- 시스템에 있느 모든 객체의 수명을 정확히 몰라도 런타임이 대신 추척하며 쓸모없는 객체를 알아서 제거해주는 것
- 기본 원칙 2가지
   - 알고리즘은 반드시 모든 가비지를 수집한다
   - 살아 있는 객체는 절대로 수집해서는 안된다

## 마크 앤 스위프 (mark and sweep)
자바에서 가비지 수집은 '마크 앤 스위프' 알고리즘을 기초한다. 

개념
1. 할당 리스트를 순회하면서 마크 비트를 지운다
2. GC 루트로부터 살아 있는 개체를 탐색한다
3. 탐색 과정에서 찾은 객체는 마크 비트를 지운다
5. 할당 리스트를 순회하면서 마크 비트가 세팅되지 않은 객체를 찾는다. (=사용되지 않는 객체를 찾는다)
   - 힙에서 메모리를 회수해서 프리 리스트에 되돌린다
   - 할당 리스트에서 객체를 제거한다

힙 상태 보기
1. 명렁어
   ```
   jmap --histo
   ```

2. 'VisualVM' 도구 사용

## 핫프랏 런타임 개요
자바는 역참조 매커니즘(=C에서의 포인트)이 없다. 
- 오프셋 연사자(. 연산자)로 필드에 엑세스 하거나
- 객체 레퍼런스의 메서드를 호출할 수 있다

__내용을 잘 이해하지 못해서 스킵__

## 할당과 수명
가비지 수집이 일어나는 주된 원인
1. 할당률: 일정 단위 기간(보통 MB/s) 새로 생성된 객체가 사용한 메모리양
2. 객체 수명: 측정하기가 어렵다

### 약한 세대별 가설(week generation hyphothesis)
개념
- JVM 및 유사 소스트웨어 시스템에서 객체 수명은 이원적인 분표 양상을 보인다.
- 거의 대부분의 객체는 아주 짧은 시간만 살아 있지만, 나머지 객체는 기대 수명이 훨씬 길다

이를 바탕으로 가비지를 수집하는 힙은 
1. 단명 객체를 쉽고 빠르게 수집할 수 있게 설계되어야하며
2. 장수 객체와 단명 객체를 완전히 떼어놓는게 좋다

핫스팟의 특징
- 객체마다 세대 카운터(generational count)를 센다
- 큰 객체를 제외한 나머지 객체는 '에덴' 공간에 생성한다. 여기서 살아남은 객체는 다른 곳으로 옮긴다. 
- 장수했다고 할 정도로 충분히 오래 살아남은 객체들은 별도의 메모리 영역에 보관한다

## 핫스팟의 가비지 수집
자바는 C/C++ 계열의 환경과 달리 OS를 이용해서 동작으로 메모리를 관리하지 않는다. 대신, 프로세스가 시작되면 JVM은 메모리를 할당하고 유저 공간에서 연속된 단일 메모리 풀을 관리한다. 
- 단일 메모리풀은 목적에 따라 서로 다른 영역으로 구성된다
- 수집기가 객체를 계속 이동시키기 때문에 객체의 주소는 시간이 흐르면서 바뀐다

### 스레드 로컬 할당
JVM의 에덴 영역 관리
- 객체가 생성되는 장소이기 때문에 특별히 잘 관리해야한다
- 에덴을 여러 버퍼로 나누어서 각 애플리케이션 스레드가 새 객체를 할당하는 구역으로 활용하도록 배포한다. 이렇게하면 각 스레드는 다른 스레드가 자신의 버퍼에 객체를 할당하지는 않을까 염려할 필요가 없다. 
- 이 구역을 `스레드 로컬 할당 버퍼(TLAB)` 라고 한다

### 반구형 수집(hemispheric evacuating collector)
개념
- 장수하지 못한 객체를 임시 수용소에 담아두자는 아이디어
- 단명 깨체가 테뉴어드 세대를 어지럽히지 않게 하고 풀 GC 발생 빈도를 줄일 수 있다
- 핫스팟에서는 `서바이버` 공간이라고 한다

특징
- 수집기가 라이브 반구를 수집할 때 객체들은 다른 반구로 압착시켜서 옮기고 수집된 반구는 비워둔다
- 절반의 공간은 항상 비운다
- 서바이버 공간은 에덴 공간보다 작으며, 역할은 각 영세대의 수집을 교환하는 것이다

## 병렬 수집기
특징
- 자바8 이번까지의 기본 가비지 수집기
- 처리율에 최적화 되어 있다. 영 GC, 풀 GC ahen STW를 일으킨다
- 애플리케이션 스레드를 모두 중단시킨 다음, 가용 CPU코어를 총동원에서 가능한 빨리 메모리를 수집한다.

### 영 세대 병렬 수집
ParallelGC가 사용

발생 시점
- 스레드가 에덴에 객체를 할당하려는데 자신이 할당받은 TLAB 공간은 부족하고, JVM은 새 TLAB를 할당할 수 없을 때 발생한다

동작
1. 전체 애플리케이션 스레드를 중단한다
2. 영세대(에덴 및 비어있지 않은 서바이버 공간)을 뒤져서 가비지 아닌 객체를 골라낸다
3. 살아남은 객체를 비어있는 서바이버 공간으로 이동하고, 세대 카운트를 늘린다
4. 에덴과 객체를 방출시킨 서바이버 공간을 재사용 가능한 빈 공간으로 표시한다
5. 애플리케이션 스레드를 재시작해 TLAB를 애플레키이션 스레드에 배포하는 프로세르를 재개한다

### 올드 세대 병렬 수집
특징
- ParallelOld GC가 기본
- 풀 GC 사이클 내내 CPU를 점유하는 대가로 메모리는 아주 효율적으로 배치된다

동작
1. 올드 세대에 더이상 방출할 공간이 없으면 병렬 수집기는 올드 세대 내부에서 객체들을 재배치해서 늙은 객체가 죽고 버려진 공간을 회수한다

### 병렬 수집기의 한계
풀 STW를 유발한다
- 영 수집에서는 큰 문제가 되지 않는다
   - 영 병렬 수집기는 설계상 죽은 객체를 건드리지 않기 때문에 마킹 단계 소요 시간은 생존 객체 수에 비례한다. 
   - 극소수의 객체만 사라남기 때문
- 올드 세대는 시간이 오래 걸린다
   - 디폴트 크기 자체가 영세대의 7배이다
   - 올드 객체는 장수 객체이므로 이들 중 상당수는 살아남을 공산이 크다
   - STW 시간이 힙 크기에 비례한다. 힙이 커질수록 중단 시간도 나빠진다

## 할당의 역할
자바는 유입된 메모리 할당 요청을 수용하기에 메모리가 부족할 때 동작하기 때문에, GC 사이클은 그때그때 필요에 의해서 발생한다. 

