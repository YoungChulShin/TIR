# 02. 스레드 안정성
스레드에 안전한 코드를 작성하는 것은 근본적으로는 상태, 특히 공유되고 변경될 수 있는 상태에 대한 접근을 관리하는 것이다. 

스레드 안정성이 마치 코드를 보호하는 것처럼 이해하는 경우가 많지만, 실제로는 데이터 제어 없이 동시에 접근하는 걸 막으려는 의미임을 알아두자. 

여러 스레드가 변경할 수 있는 상태 변수를 동기화 없이 접근할 때, 프로그램을 고치는 방법. 
1. 해당 상태 변수를 스레드 간에 공유하지 않는다. 
2. 해당 상태 변수를 변경할 수 없도록 만든다. 
3. 해당 상태 변수에 접근할 때 언제나 동기화를 사용한다. 

## 스레드 안정성이란?
여러 스레드가 클래스에 접근할 때 계속 정확하게 동작하면 해당 클래스는 안전하다. 

스레드 안전한 클래스는 클라이언트 쪽에서 별도로 동기화할 필요가 없도록 동기화 기능을 캡슐화한다. 

상태 없는 객체는 항상 스레드 안전하다. 
- 여러 스레드가 상태를 공유하지 않기 때문에 사실상 서로 다른 인터스턴스 접근하는 것과 같다. 

## 단일 연산
경쟁 조건(race condition)
- 경쟁 조건은 상대적인 시점이나 또는 JVM이 여러 스레드를 교차해서 실행하는 상황에 따라 계산의 정확성이 달라질 때 나타난다. 다시 말하자면, 타이밍이 딱 맞았을 때만 정답을 얻는 경우를 말한다. 
- 가장 일반적인 경쟁 조건 형태는 잠재적으로 유효하지 않는 값을 참조해서 다음에 뭘 할지를 결정하는 점검 후 행당(check-then-act) 형태의 구문이다. 

복합동작
- 경쟁 조건을 피하려면 변수가 수정되는 동안 다른 스레드가 해당 변수를 사용하지 못하도록 막을 방법이 있어야 하며, 이런 방법으로 보호해두면 특정 스레드에서 변수를 수정할 때 다른 스레드는 수정 도중이 아닌 수정 이전이나 이후에만 읽거나 변경을 가할 수 있다. 
- `java.util.concurrent.atomic` 패키지에는 숫자나 객체 참조 값에 대해 상태를 단일 연산으로 변경할 수 있도록 atomic variable 클래스가 준비돼 있다. 

## 락
암묵적인 락
- 자바에는 단인 연산 특성을 보장하기 위해서 `synchronized` 라는 구문으로 사용할 수 있는 락을 제공한다. 
- `synchronized` 구문은 락으로 사용될 객체의 참조 값과 해당 락으로 보호하려는 코드 블록으로 구성된다. 
- 모든 객체는 락으로 사용할 수 있다. 이와 같이 자바에 내장된 락을 암묵적인 락(instinc lock) 혹은 모니터링 락(monitoring lock)이라고 한다. 
- 자바에서 암묵적인 락은 뮤텍스로 동작한다. 즉 한 번에 한 스레드만 락을 소유할 수 있다. 

재진입성
- 스레드가 다른 스레드가 가진 락을 요청하면 해당 스레드는 대기 상태에 들어간다. 하지만 암묵적인 락은 재진입 가능(reentrant)하기 때문에 특정 스레드가 자기가 이미 획득한 락을 다시 확보할 수 있다. 
- 재진입성은 확보 요청 단위가 아닌 스레드 단위로 락을 얻는 것을 의미한다. 이를 구현하려면 각 락마다 확보 횟수와 확보한 스레드를 연결시켜둔다. 
   - 0: 락 해제
   - 1: 락 획득
   - 2.. : 재진입으로 2회 이상 락 획득

## 락으로 상태 보호하기
특정 객체의 락을 얻는다고 해도 다른 스레드가 해당 객체에 접근하는 걸 막을 순 없다. 락을 얻으면 단지 다른 스레드가 동일한 락을 얻지 못하게할 수 있을 뿐이다. 

락을 활용함에 있어 일반적인 사용 예는 먼저 모든 변경 가능한 변수를 객체 안에 캡슐화하고, 해당 객체의 암묵적인 락을 사용해 캡슐화한 변수에 접근하려는 모든 코드 경로를 동기화함으로써 여러 스레드가 동시에 접근하는 상태에서 내부 변수를 보호하는 방법이다. 
- 모든 데이터를 락으로 보호해야 하는 건 아니고, 변경 가능한 데이터를 여러 스레드에서 접근해 사용하는 경우에만 해당한다.

무차별적으로 `synchronized`를 적용하면 동기화가 너무 과도하거나 심지어는 부족할 수 있다. 

## 활동성과 성능
`synchronized`의 범위를 정하는 작업은 중요하다. 
- 범위가 너무 넓으면(예: 메서드 전체) 코드 단위의 안정성은 확보할 수 있겠지만, 요청이 많아질 경우 속도에 문제가 생길 수 있다. 
- 락을 얻고 놓는 작업만으로도 어느 정도의 부하가 따른다. 따라서 단일 연산 구조에 문제가 생기지 않는다해도 `synchronized`블록을 너무 잘게 쪼개는 것도 바람직하지 못하다. 

락을 사용할 땐 블록 안의 코드가 무엇을 하는지, 수행하는데 얼마나 걸릴지를 파악해야 한다. 복잡하고 오래 걸리는 계산 작업, 네트워크 작업, 사용자 입출력 같이 빨리 끝나지 않을 수 있는 작업을 하는 부분에서는 가능한 한 락을 잡지 말아라. 