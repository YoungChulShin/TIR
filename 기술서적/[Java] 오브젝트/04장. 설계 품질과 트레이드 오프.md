# 4장. 설계 품질과 트레이드오프
훌륭한 설계란 합리적인 비용 안에서 변경을 수용할 수 있는 구조를 만드는 것이다
- 이런 설계는 응집도가 높고 서로 느슨하게 결합돼 있는 요소로 구성된다
- 결합도와 응집도를 합리적인 수준으로 유지하는 방법이 있는데, 이는 객체의 상태가 아니라 행동에 초점을 맞추는 것이다

## 01. 데이터 중심의 영화 예매 시스템
객체 분할 방법
1. 상태를 분할의 중심축으로 삼는 방법
   - 객체는 자신이 포함하고 있는 데이터를 조작하는 데 필요한 오퍼레이션을 정의한다
2. 책임을 분할의 중심축으로 삼는 방법
   - 객체는 다른 객체가 요청할 수 있는 오퍼레이션을 위해 필요한 상태를 보관한다

### 데이터를 준비하자
데이터 중심 설계
- 객체가 포함되어 야하는 데이터에 집중한다
- 이 객체가 포함해야 하는 데이터는 무엇인가? 라는 질문의 반복에 휩쓸려 있으면 데이터 중심의 설계에 매몰돼 있을 확률이 높다

구현순서
1. 데이터를 정하기
   - 데이터 중심 설계는 객체가 내부에 저장해야 하는 '데이터가 무엇인가'를 묻는 것으로 시작한다
   ~~~java
   public class Movie {
       private String title;
       private Duration runningTime;
       private Money fee;
       private List<DiscountCondition> discountConditions; // 할인 조건의 목록이 Movie에 구현된다

       private MovieType movieType;  // movieType에 따라 discountAmount 또는 discountPercent를 사용한다
       private Money discountAmount;   // 외부에 구현되어 있던 할인 방식이 Movie 내부로 들어왔다
       private double discountPercent;
   }
   ~~~
2. 캡슐화를 위해서 접근자를 설정한다
   ~~~java
   public Money getFee() {
       return fee;
   }
   ~~~

![4-1](/Images/오브젝트/4-1.png)

## 02. 설계 트레이드오프
### 캡슐화
배경
- 상태와 행동을 하나의 객체 안에 모으는 이유는 객체의 내부 구현을 외부로부터 감추가 위해서이다
- 여기서 구현이란 나중에 변경될 가능성이 높은 어떤 것을 가리킨다. 
- 변경될 가능성이 높은 부분을 '구현' 이라고 부르고, 상대적으로 안정적인 부분을 '인터페이스'라고 부른다
- 객체를 설계하기 위한 기본적인 아이디어는 변경의 정도에 따라 구현과 인터페이스를 분리하고 외부에서는 인터페이스에만 의존하도록 관계를 조절하는 것이다

캡슐화
- 변경 가능성이 높은 부분을 객체 내부로 숨기는 방법
- 변경될 수 있는 어떤 것이라도 캡슐화 해야 한다

### 응집도와 결합도
응집도
- 모듈에 포함된 내부 요소들이 연관돼 있는 정도
- 모듈 내의 요소들이 하나의 목적을 위해 긴밀하게 협력한다면 그 모듈은 높은 응집도를 가진다
- 객체지향 관점에서는 객체 또는 클래스에 얼마나 관련 높은 책임들을 할당했는지를 나타낸다

결합도
- 의존성 정도
- 다른 모듈에 대해서 얼마나 많은 지식을 갖고 있는지를 나타내는 척도
- 객체지향 관점에서는 협력에 필요한 적절한 수준의 관계만을 유지하고 있는지를 나타낸다

좋은 설계
- 오늘의 기능을 수행하면서 내일의 변경을 수용할 수 있는 설계
- 높은 응집도와 낮은 결합도를 추구해야 한다

결합도가 높아도 상관없는 경우
- 일반적으로는 인터페이스에 의존하는 코드를 작성해야 낮은 결합도를 얻을 수 있다
- 하지만 변경될 가능성이 매우 적은 안정적인 모듈에 의존하는 것은 문제가 되지 않는다
   - 표준 라이브러리에 포함된 모듈
   - 성숙 단계에 접어든 프레임워크에 의존하는 경우

## 03. 데이터 중심 시스템의 문제점
### 캡슐화 위반
'getFee', 'setFee'를 보면 Money type의 fee라는 이름의 인스턴스 변수가 존재한다는 사실을 노골적으로 드러낸다
- 캡슐화를 어기게 된 근본적인 원인은 객체가 수행할 책임이 아니라 내부에 저장할 데이터에 초점을 맞췄기 때문이다
- 설계할 때 협력에 관해 고민하지 않으면 캡슐화를 위반하는 과도한 접근자와 수정자를 가지게 되는 경향이 있다

### 높은 결합도
'ReservationAgency' 클래스 예시
- 코드
   ~~~java
   Money fee;
   ...
   fee = movie.getFee();
   ~~~
- fee의 타입이 변경되면, 
   - getFee()의 반환타입이 변경되고
   - ReservationAgency의 fee 타입이 변경된다
   - fee의 타입변경으로 협력하는 클래스가 변경되기 때문에 getFee 메서드는 fee를 정상적으로 캡슐화하지 못한다
- ReservationAgency가 모든 데이터 객체에 의존하고 있다
   - 연관된 데이터 객체가 변경되면 ReservationAgency도 같이 변경되어야 한다

### 낮은 응집도
문제
- 하나의 모듈에 변경과 상관 없는 코드들이 있다
   - ReservationAgency에 할인 정책을 선택하는 코드와 할인 조건을 판단하는 코드가 함께 있기 때문에 할인 정책에 대한 변경이 할인 조건에도 영향을 줄 수 있다
- 하나의 요구사항을 변경하기 위해서 동시에 여러 모듈을 수정해야 한다
   - 새로운 할인 정책을 추가하려면 'MovieType'에 새로운 정책을 추가하고, ReservationAgency의 reserve() 메서드의 switch 문에도 변경이 필요하다

## 04. 자율적인 객체를 향해
### 캡슐화를 지켜라
'Rectangle' 예시
- 속성을 통해서 변경하는 것이 아니라, 객체 내부에 책임을 이동시킴으로서 객체가 스스로를 책임지도록 했다
   ~~~java
   // Before
   retangle.setRight(rectangle.getRight() * mulitple);
   retangle.setLeft(rectangle.getLeft() * mulitple);

   // After
   public void enlarge(int multiple) {
       right *= multiple;
       bottom *= multiple;
   }
   ~~~

### 스스로 자신의 데이터를 책임지는 객체
우리가 상태와 행동을 객체라는 하나의 단위로 묶는 이유는 객체 스스로 자신의 상태를 처리할 수 있게 하기 위해서다. 


## 06. 데이터 중심 설계의 문제점
1. 객체의 행동보다는 상태에 초점을 맞춘다
   - 설계를 시작하는 단계부터 데이터에 관해 결정하도록 강요하기 때문에 너무 이른 시기에 내부 구현에 초점을 맞추게 한다
   - 이 방법에 익숙한 개발자들은 일반적으로 데이터와 기능을 분리하는 절차적 프로그래밍 방식을 따른다
   - 데이터 중심 관점에서 객체는 그저 단순한 데이터의 집합체일 뿐이다
2. 객체를 고립시킨 채 오퍼레이션을 정의하도록 만든다
   - 올바른 객체 지향의 무게 중심은 객체의 내부가 아니라 외부에 맞춰져 있어야 한다. (객체들간의 협력이 중요하다)
   - 하지만 데이터 중심은 설계 초점이 외부가 아니라 내부로 향한다
   - 객체의 구현이 결정된 상태에서 다른 객체와의 협력 방법을 고민하기 때문에 이미 구현된 객체의 인터페이스를 억지로 끼워맞출수밖에 없다



