# 6장. 메시지와 인터페이스
클래스 사이의 정적인 관계에서 메시지 사이의 동적인 흐름으로 초점을 전화하는 것은 미숙함을 벗어나 숙련된 객체지향 설꼐자로 성장하기 위한 첫걸음이다.

## 01. 협력과 메시지
### 클라이언트-서버 모델
클라이언트-서버 모델에서의 협력 관계
- 클라이언트: 메시지를 전송하는 객체
- 서버: 메시지를 수신하는 객체

하지만 협력의 관점에서 보면 객체는 메시지를 수신하는 역할과 전송하는 역할을 동시에 가진다
- `Movie`
   - 수신: 가격을 계산하라. (Return 예매 요금)
   - 전송: 할인 여부를 판단하라 (Return 할인 요금)

### 메시지와 메시지 전송
메시지 전송(메시지 패싱)
- 정의: 한 객체가 다른 객체에게 도움을 요청하는 것
- 구성
   - 메시지: 오퍼레이션명, 인자
   - 메시지 수신자
- 표기법
   - Java: condition.isSatisfiedBy(screening);
      - condition: 수신자
      - isSatisfiedBy: 오퍼레이션 명
      - screening: 인자

### 메시지와 메서드
메서드: 메시지를 수신했을 때 실제로 실행되는 함수 또는 프로시저
- 코드 상에서 동일한 이름이 변수에게 동일한 메시지를 전송하더라도 객체의 타입에 따라 실행되는 메서드가 달라질 수 있다<br>
예: `condition`이 `PeriodCondtion`의 인스턴스라면 `PeriodCondtion`에 구현된 `isSatisfiedBy`가 실행되고, `SequenceCondtion`의 인스턴스라면 `SequenceCondtion`에 구현된 `isSatisfiedBy`가 메서드가 실행된다.
- 객체는 메시지와 메서드라는 두 가지 서로 다른 개념을 실행 시점에 연결해야 하기 때문에 컴파일 시점과 실행 시점의 의미가 달라질 수 있다.

메시지와 메서드의 구분은 메시지 전송자와 메시지 수신자가 느슨하게 결합될 수 있게 한다
- 메시지 전송자는 자신이 어떤 메시지를 전송해야 하는지만 알면 된다
- 메시지 수신자도 누가 메시지를 전송하는지 알 필요가 없다. 단지 메시지가 도착했다는 사실만 알면 된다. 

### 퍼블릭 인터페이스와 오퍼레이션
퍼블릭 인터페이스
- 외부의 객체는 객체가 공개하는 메시지를 통해서만 상호작용할 수 있다
- 이처럼 객체가 의사소통을 위해 외부에 공개하는 메시지의 집합을 퍼블릭 인터페이스라고 부른다

오퍼레이션 (Operation)
- 퍼블릭 인터페이스에 포함된 메시지를 오퍼레이션이라고 부른다
- 추상화

메서드
- 메시지를 수신했을 때 실제로 실행되는 코드

|Class|기능|타입|
|-----|----|---|
|DiscountCondition|isSatisfiedBy|Operation|
|SequenceCondtion|isSatisfiedBy|Method|
|PeriodCondtion|isSatisfiedBy|Method|
- 퍼블릭 인터페이스는 오퍼레이션의 집합
- 메서드는 오퍼레이션의 구현 중 하나

### 시그니처
시그니처
- 오퍼레이션의 이름과 파라미터 목록을 합쳐서 시그니처라고 부른다

객체가 수신할 수 있는 메시지가 퍼블릭 인터페이스와 그 안에 포함될 오퍼레이션을 결정한다. 결국 메시지가 객체의 품질을 결정한다. 

## 02. 인터페이스 설계 품질
좋은 인터페이스
- 최소한의 인터페이스와 추상적인 인터페이스라는 조건을 만족해야 한다
   - 최소한의 인터페이스: 꼭 필요한 오퍼레이션만을 포함한다
   - 추상적인 인터페이스: 어떻게 수행하는지가 아니라 무엇을 수행하는지를 포함한다
- 가장 좋은 방법은 책임 주도 설계 방식을 따르는 것이다
   - 책임 주도 설계 방법은 메시지를 먼저 선택함으로써 협력과는 무관한 오퍼레이션이 인터페이스에 스며드는 것을 방지한다

### 퍼블릭 인터페이스의 품질에 영향을 미치는 원칙과 기법
디미터 법칙
- 정의: 객체의 내부 구조에 강하게 결합되지 않도록 협력 경로를 제한하는 것. "오직 인접한 이웃하고만 말하라"
   - C#의 도트(.)를 이용해 메시지를 표현하는 언어에서는 "오직 하나의 도트만 사용하라"로 요약된다
- 이를 위해서는 클래스가 특정한 조건을 만족하는 대상에게만 메시지를 전송하도록 프로그래밍해야 한다.
   - 모든 클래스 C와 C에 구현된 모든 메서드 M에 대해서, M이 메시지를 전송할 수 있는 객체는 아래와 같다
      1. M의 인자로 전달된 클래스 (C 자체를 포함)
      2. C의 인스턴스 변수의 클래스
- 좋은 점은 메시지 전송자가 더 이상 메시지 수신자의 내부 구조에 관해 묻지 않게 된다

__묻지 말고 시켜라__
- 메시지 전송자는 메시지 수신자의 상태를 기반으로 결정을 내린 후 메시지 수신자의 상태를 바꿔서는 안 된다.<br>
   객체의 외부에서 해당 객체의 상태를 기반으로 결정을 내리는 것은 객체의 캡슐화를 위반한다
- 상태를 묻는 오퍼레이션을 행동을 요청하는 오퍼레이션으로 대체함으로써 인터페이스를 향상시켜야한다.
- 객체는 자신이 내부적으로 보유하고 있는 정보나 메시지 전송의 결과로 얻게 되는 정보만 사용해서 의사결정을 내리게된다. 

__의도를 드러내는 인터페이스__
- 메서드의 이름을 지을때는 '어떻게'가 아니라 '무엇'을 하는지를 드러내야 한다. 
- 어떻게 수행하는지를 드러내는 이름은 메서드의 내부 구현을 설명하는 이름이다. 결과적으로 협력을 설계하기 시작하는 이른 시기부터 클래스의 내부 구현에 관해 고민할 수 밖에 없다
- 무엇을 하는지를 드러내는 이름은 객체가 협력 안에서 수행해야 하는 책임에 관해 고민해야 한다.
- _하나의 구현을 가진 메시지의 이름을 일반화 하도록 도와주는 간단한 훈련 방법을 소개하겠다. 매우 다른 두 번째 구현을 상상하라. 그러고는 해당 메서드에 동일한 이름을 붙인다고 상상해보라. 그렇게 하면 아마도 그 순간에 여러분이 할 수 있는 가장 추상적인 이름을 메서드에 붙일 것이다. (Kent Beck, "Smalltalk Best Practice Patterns", 1989)_

명령-쿼리 분리

## 03. 원칙의 함정
__설계의 트레이드 오프__
- 원칙이 현재 상황에 부적합하다고 판단된다면 과감하게 원칙을 무시하라. 
- 원칙을 아는 것보다 더 중요한 것은 언제 원칙이 유용하고 언제 유용하지 않은지를 판단할 수 있는 능력을 기르는 것이다. 

### 디미터 법칙은 하나의 도트(.)를 강제하는 규칙이 아니다
- 디미터 법칙은 결합도와 관련된 것이다. 이 결합도가 문제되는 것은 객체의 내부 구조가 외부로 노출되는 경우로 한정된다. 
- 하나 이상의 도트를 사용하더라도 객체의 내부 구현에 대한 어떤 정보도 외부로 노출하지 않는다면 디미터 법칙을 준수하는 것이다. 
```java
Instream.of(1, 15, 20, 3, 9).filter(x -> x > 10).distinct().count(); // 모두 동일한 클래스의 인스턴스를 반환한다
```

### 결합도와 응집도의 충돌
- 위임 메서드를 통해서 객체의 내부 구조를 감추는 것은 협력에 참여하는 개체들의 결합도를 낮추는 동시에 응집도를 높이는 가장 효과적인 방법이다.
- 하지만 묻지 말고 시켜라와 미디터 법칙을 준수하는 것이 항상 긍정적인 결과로 귀결되는 것은 아니다. 모든 상황에서 맹목적으로 위임 메서드를 추가하면 같은 퍼블릭 인터페이스 안에 어울리지 않는 오퍼레이션들로 공존하게 되고 응집도가 낮아진다.
   - 클래스는 하나의 변경 원인만을 가져야 한다
   - 위임메서드를 사용해서 책임을 넘겼을 때, 책임을 받는 대상에게 이 책임이 올바른 것인지를 확인해야 한다. 그렇지 않으면 응집도가 낮아진다


## 04. 명령-쿼리 분리 원칙
루틴(routine)
- 정의: 어떤 절차를 묶어 호출 가능하도록 이름을 부여한 기능 모듈을 루틴이라 부른다. 
- 루틴은 프로시저(procedure)와 함수(function)로 구분할 수 있다.
   - 프로시저: 정해진 절차에 따라 내부의 상태를 변경하는 루틴의 한 종류. Command
   - 함수: 어떤 절차에 따라 필요한 값을 계산해서 반환하는 루틴의 한 종류. Query

명령과 쿼리분리
- 요지: 오퍼레이션은 부수효과를 발생시키는 명령이거나 부수효과를 발생시키지 않는 쿼리 중 하나여야 한다<br>어떤 오퍼레이션도 명령인 동시에 쿼리여서는 안된다
- 두가지 규칙
   1. 객체의 상태를 변경하는 명령은 반환값을 가질 수 없다
   2. 객체의 정보를 반환하는 쿼리는 상태를 변경할 수 없다

참조 투명성
- "어떤 표현식 e가 있을 때 e의 값으로 e가 나타내는 모든 위치를 교체하더라도 결과가 달라지지 않는 특성"을 의미한다
- 부수효과가 없는 불변의 세상에서는 모든 로직이 참조 투명성을 만족시킨다. 따라서 불변성은 부수효과 발생을 방지하고 참조 투명성을 만족시킨다. 
- 장점
   - 모든 함수를 이미 알고있는 하나의 결과값으로 대체할 수 있기 때문에 식이 쉽게 계산할 수 있다
   - 모든 곳에서 함수의 결과값이 동일하기 때문에 식의 순서를 변경하더라도 식의 결과가 달라지지 않는다