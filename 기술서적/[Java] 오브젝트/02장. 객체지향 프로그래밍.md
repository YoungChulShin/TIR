# 2장. 객체지향 프로그래밍
## 01. 영화 예매 시스템
기능 설명
- 예매
- 할인
   - 할인 기준
      - 금액 할인 (일정 금액을 할인)
      - 비율 할인 (일정 비율을 할인)
   - 할인 조건
      - 순번 조건 (특정 순번을 할인)
      - 기간 조건 (특정 기간동안 할인)

## 02. 객체지향 프로그래밍을 향해
### 협력, 객체, 클래스
객체지향의 본질
- 대부분의 사람들은 클래스를 결정한 후에 클래스에 어떤 속성과 메서드가 필요한지 고민한다. 이는 객제지향의 본질과는 거리가 멀다
- 객체지향의 본질은 객체를 지향하는 것이다
- 이를 위해서 아래 2가지를 고민해야 한다
   1. 어떤 클래스가 필요한지를 고민하기 전에 어떤 객체들이 필요한지 고민하라
   2. 객체를 독립적인 존재가 아니라 기능을 구현하기 위해 협력하는 공동체의 일원으로 봐야 한다

### 도메인의 구조를 다르는 프로그램 구조
도메인
- 문제를 해결하기 위해 사용자가 프로그램을 사용하는 분야를 도메인이라고 부른다
- 영화 예매 시스템의 목적은 영화를 좀 더 쉽고 빠르게 예매하려는 사용자의 문제를 해결하는 것이다

도메인 구현
- 도메인 개념들을 구현하기 위해 클래스를 사용한다
- 클래스의 이름은 대응되는 도메인 개념의 이름과 동일하거나 적어도 유사하게 지어야 한다
- 클래스 사이의 관계도 최대한 도메인 개념 사이에 맺어진 관계와 유사하게 만들어서 프로그램의 구조를 이해하고 예상하기 쉽게 만들어야 한다
   ![2-3](/Images/오브젝트/2-3.png)

### 클래스 구현
자율적인 객체
- 객체는 상태와 행동을 가지는 복합적인 존재
   - 캡슐화, 접근제어
- 객체는 스스로 판단하고 행동하는 자율적인 존재
- 퍼블릭 인터페이스를 이용해서 외부에서 접근 가능한 부분을 구현하고, 내부에서 이를 구현하는 코드를 둔다

### 협력하는 객체들의 공동체
- 예시에서의 Money 타입
- 장점
   - Long으로도 구현할 수 있는 금액관련 선언을 Money로 선언함으로써 금액과 관련이 되어 있다는 명확한 의미를 전달할 수 있다
   - 금액 관련 로직이 서로 다른 곳에 중복 구현된어 있는 것을 막을 수 있다
- 비록 개념이 하나의 인스턴스 변수만 포함하더라도 개념을 명시적으로 표현하는 것은 전체적인 설계의 명확성과 유연성을 높이는 첫걸임이다

### 협력에 대한 짧은 이야기
- 객체는 메시지를 전송, 수신하는 방법으로 서로 상호작용을 한다
- 수신된 메시지를 처리하는 방법을 메서드(method)라고 한다
- 메서드를 전송한다는 표현
   - `Screening -> Movie` 의 흐름을 보자
   - 지금까지는 Screening이 Movie의 calcuateMovieFee 메서드를 호출한다고 말했다
   - 사실은 Screening이 Movie에게 calcuateMovieFee 메시지를 전송한다는 말이 더 적합하다
- 메시지를 수신한 객체는 스스로 적절한 메서드를 선택한다. (=_구현과 인터페이스의 분리_)


## 03. 할인 요금 구하기
![2-6](/Images/오브젝트/2-6.png)

```java
Movie avatar = new Movie(
   "아바타",
   Money.wons(1000),
   new AmountDiscountPolicy(
      Money.wons(800),
      new SequenceConditon(1),
      new SequenceConditon(10),
      new PeriodCondition(....),
      new PeriodCondition(....)
      )
);
```

## 04. 상속과 다형성
### 컴파일 타임 의존성과 런타임 의존성
코드는 컴파일 타임과 란타임에 의존성이 다를 수 있다
- 예시 코드에서 Movie와 DiscountPolicy와의 관계
   - 컴파일 타임: DiscountPolicy
   - 런타임: AmountDiscountPolicy or PecentDiscountPolicy

단점
- 코드를 이해하기 어려워 진다
- 디버깅이 어렵다

장점
- 코드가 유연하고 확장가능해진다
- 유연성과 가독성 사이에서 고민을 해야 한다


### 상속과 인터페이스
AmountDiscountPolicy와 PercentDiscountPolicy가 DiscountPolicy를 대신해서 사용할 수 있는 이유
- Movie입장에서는 협력하는 객체가 calculateDiscountAmount 메시지를 이해할 수만 있으면 된다
- 자식클래스는 상속을 통해서 부모 클래스의 인터페이스를 물려받기 때문에 부모에서 정의한 메시지를 사용할 수 있고, 부모클래스 대신 사용될 수 있다
- 자식클래스가 부모클래스를 대신하는 것을 업캐스팅이라고 부른다

### 다형성
정의
- 동일한 메시지를 전송하지만 실제로 어떤 메서드가 실행될지는 메시지를 수신하는 객체의 클래스가 무엇이냐에 따라 달라진다. 이를 다형성이라고 한다. 
- 다형성은 객체지향 프로그램의 컴파일 타임 의존성과 런타임 의존성이 다를 수 있다는 사실을 기반으로 한다

구현
- 다형적인 협력에 참여하는 객체들은 모두 같은 메시지를 이해할 수 있어야 한다
- 이를 위해서는 인터페이스 통일이 필요한데, 이를 위해 사용한 방법이 상속이다. (책의 뒤에 나오지만 인터페이스를 이용한 추상화를 통해서도 가능하다)

### 인터페이스와 다형성
인터페이스
- 구현에 대한 고려 없이 다형적인 협력에 참여하는 클래스들이 공유 가능한 외부 인터페이스를 정의한 것

인터페이스와 다형성
- 인터페이스를 통해서도 업캐스팅이 적용되며 다형적으로 될 수 있다

## 05. 추상화와 유연성
### 추상화의 힘
추상화의 장점
1. 추상화 계층만 따로 떼어 놓고 살펴보면 요구사항의 정책을 높은 수준에서 서술할 수 있다
   - 세부 내용에 억눌리지 않고 상위 개념만으로 도메인 개념을 설명할 수 있다
2. 설계가 좀 더 유연해진다
   - 'NoneDiscountPolicy 예시'. 기존의 Movie와 DiscountPolicy는 수정하지 않고 새로운 클래스를 추가하는 것으로 확장이 가능하다
      ~~~java
      public class NoneDiscountPolicy extends DiscountPolicy { ... }

      Movie starWars = new Movie(...., new NoneDiscountPolicy());
      ~~~

### 상속과 인터페이스의 트레이드오프
상속을 사용하면 부모클래스와의 개념적으로 결합이 발생한다
- 이를 제거하기 위해서는 추상클래스를 인터페이스로 변경해서 결합을 제거하는 것이다
- 하지만 인터페이스를 추가하는 것이 이상적으로는 좋지만, 현실적으로는 조금 과하다고 느낄 수도 있다. 

![2-15](/Images/오브젝트/2-15.png)

### 상속
상속은 객체지향에서 코드를 재사용하기 위해서 널리 사용된다

문제점
1. 캡슐화를 위반한다. 
   - 자식클래스를 구현할 때 부모클래스의 로직을 알고 있어야 한다. (= 부모클래스 로직이 자식클래스에게 노출된다)
   - 결합이 발생할 수 있어서 과도한 상속을 사용한 코드는 변경하기도 어려워진다. 
2. 설계가 유연하지 않다
   - 상속보다는 인스턴스 변수로 관계를 연결한 설계가 더 유연하다

### 합성
정의
- 인터페이스에 정의된 메시지를 통해서만 코드를 재사용하는 방법

상속의 문제점을 해결한다
- 인터페이스에 정의된 메시지를 통해서만 재사용이 가능하기 때문에 구현을 캡슐화 할 수 있다
- 상속은 클래스를 통해서 강하게 결합되는데, 합성은 메시지를 통해서 느슨하게 결합된다. 

코드 재사용을 위해서는 상속보다는 합성이 더 좋은 방법이다