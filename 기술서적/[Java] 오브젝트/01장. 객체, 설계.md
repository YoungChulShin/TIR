# 1장. 객체, 설계

## 01. 티켓 판매 애플리케이션 구현하기
![1-1](/Images/오브젝트/1-1.png)

~~~java
public void enter(Audience audience) {
    if (audience.getBag().hasInvitation()) {
        Ticket ticket = ticketSeller.getTicketOffice().getTicket();
    } else {
        Ticket ticket = ticketSeller.getTicketOffice().getTicket();
        audience.getBag().minusAmount(ticket.getFee());
        ticketSeller.getTicketOffice().plusAmount(ticket.getFee());
        audience.getBag().setTicket(ticket);
    }
}
~~~

## 02. 무엇이 문제인가
소프트웨어 모듈이 가져야 할 세가지 기능/목적 (by. 로버트 마틴, 클린 소프트웨어)
1. 실행중에 제대로 동작하는 것
2. 간단한 작업으로도 변경이 가능해야 한다. (변경하기 어려운 모듈은 변경하기 쉽도록 개선해야 한다)
3. 쉽게 읽고 이해할 수 있어야 한다
- 이를 예제 프로그램에 적용해 보면 첫번째 내용은 맞지만, 변경 용이성과 의사소통이라는 목적은 만족시키지 못한다

### 예상을 빗나가는 코드
코드의 문제점
- 관람객(Audience)과 판매원(TicketSeller)가 소극장의 통제를 받는 수동적인 존재
   - 기존의 코드는 소극장에서 enter() 메서드를 통해서 관객과 판매원을 모두 관리한다
   - 현실에서는 관람객, 판매원이 서로 커뮤니케이션을 하면서 진행된다
- 하나의 클래스에서 너무 많은 세부 사항을 다루기 때문에 코드를 작성하는 사람뿐 아니라 읽는 사람도 많은 세부 사항을 알고 있어야 한다
- 변경에 취약하다. Audience와 TicketSeller를 변경할 경우 Theater도 함께 변경해야 한다

### 변경에 취약한 코드
- 객체사이에 의존성이 많아서 기능이 변경될 때 수정해야 할 곳이 많다
- 의존성을 완전히 없애는 것이 답은 아니다. 목표는 최소한의 의존성만 유지하고 불필요한 의존성을 제거하는 것이다

## 03. 설계 개선하기
### 자율성을 높이자
Theater class 수정
- Theater가 원하는 것은 관람객이 소극장에 입장하는 것 뿐이기 때문에, 나머지 기능은 올바른 책임을 가져야 하는 곳으로 옮겨준다
   - Audience와 TicketSeller를 Theater에 의존적인 존재가 아니라 자율적인 존재로 만들어 준다
   - Audience가 스스로 가방안의 현금과 초대장을 처리하도록 수정한다
   - TicketSeller가 티켓과 판매 요금을 다루게 수정한다
        ~~~java
        public void enter(Audience audience) {
            ticketSeller.sellTo(audience);
        }
        ~~~
- 변경된 코드에서 Theater는 TicketSeller의 인터페이스에만 의존한다
   - __객체를 인터페이스와 구현으로 나누고 인터페이스만을 공개하는 것은 객체 사이의 결합도를 낮추고 변경하기 쉬운 코드를 작성하기 위해 따라야 하는 가장 기본적인 설계 원칙이다__

### 무엇이 개선되었는가
수정된 Audience와 TicketSeller는 자신이 가지고 있는 소지품을 스스로 관리한다.
- 우리가 예상한 현실세계의 동작과 일치한다. 코드를 읽는 사람과의 의사소통이라는 관점에서 개선이 되었다
- Audience와 TicketSeller의 내부 구현을 변경해도 Theater를 함께 변경할 필요가 없어졌다

### 응집도
응집도가 높은 객체
- 밀접하게 연관된 작업만을 수행하고 연관성 없는 작업은 다른 객체에게 위임하는 객체

응집도를 높이기 위해서
- __객체 스스로 자신의 데이터를 책임져야 한다__ (= 자율적인 존재여야 한다)
- 외부의 간섭을 최대한 배제하고 메시지를 통해서만 협력하는 자율적인 객체들의 공동체를 만드는 것이 훌륭한 객체지향 설계를 얻을 수 있는 지름길이다

### 절차지향과 객체지향
절차적 프로그래밍 (Procedual Programming)
- 프로세스(=Theater의 enter)와 데이터(Audience, TicketSeller 등)를 별도의 모듈에 위치시키는 방식
- 우리의 직관과는 위배된다
- 데이터의 변경에 대한 영향을 지역적으로 고립시키기 어렵다

객체지향 프로그래밍 (Object-Oriented Programming)
- 데이터와 프로세스가 동일한 모듈 내부에 위치하도록 하는 방식
- 훌륭한 객치지향 설계의 핵심은 캡슐화를 이용해 의존성을 적절히 관리함으로써 객체 사이의 결합도를 낮추는 것이다.<br>
일반적으로 객체지향이 절차지향에 비해 변경이 좀 더 유연하다고 말하는 이유가 바로 이것이다.

### 책임의 이동
![1-8](/Images/오브젝트/1-8.png)

__여러분의 코드에서 데이터와 데이터를 사용하는 프로세스가 별도의 객체에 위치하고 있다면 절차적 프로그래밍 방식을 따르고 있을 확률이 높다__


## 04. 설계 개선하기
좋은 설계란
- 우리는 오늘 완성해야 하는 기능을 구현하는 코드를 짜야하는 동시에 내일 쉽게 변경할 수 있는 코드를 짜야한다
- 좋은 설계란 오늘 요구하는 기능을 온전히 수행하면서 내일의 변경을 매끄럽게 수용할 수 있는 설계다
- __변경을 수용할 수 있는 설계가 중요한 이유는 요구사항이 항상 변경되기 때문이다__