# 6장. 객체 분해
분해(decomposition)
- 큰 문제를 해결 가능한 작은 문제로 나누는 작업

## 01. 프로시저 추상화와 데이터 추상화
현대적인 언어의 특징을 결정 짓는 두 가지 추상화 메커니즘
- 프로시저 추상화: 소프트웨어가 무엇을 해야하는지를 추상화
   - 기능 분해(functional decomposition)
- 데이터 추상화: 소프트웨어가 무엇을 알아야 하는지 추상화
   - (데이터를 중심으로) 타입 추상화(type abstraction): 추상 데이터 타입
   - (데이터를 중심으로) 프로시저 추상화 (procedure abstraction): 객체지향

_책에서 설명하는 추상화의 단계_
1. 프로시저 추상화
2. 모듈 
3. 데이터 추상화 (추상화 타입)
4. 절차 추상화 (클래스)

_그럼 객체지향이 전통적인 기능분해 방법에 비해서 뭐가 더 효과적인지 알아보자_

## 02. 프로시저 추상화와 기능 분해
기능 분해
- 시스템을 기능 단위로 분해하는 것
- 기능 분해의 관점에서 추상화의 단위는 프로시저

프로시저 추상화
- 프로시저란
   - 반복적으로 실행되거나 거의 유사하게 실행되는 작업들을 하나의 장소에 모아놓음으로써 로직을 재사용하고 중복을 방지할 수 있는 추상화 방법
- 내부의 상세한 구현은 모르더라도 인터페이스만 알면 프로시저를 사용할 수 있기 때문에 프로시저 추상화라고 한다
- Top-down 방식을 따른다
   - 최상위 기능을 정의하고, 이 기능을 좀더 작은 단위로 분해해 나간다

기능 분해의 과정
- 먼저 필요한 기능을 생각하고, 이 기능을 분해하고 정제하는 과정에서 필요한 데이터의 종류와 저장 방식을 식별한다

문제점
- 하나의 메인 함수라는 비현실적인 아이디어
   - 어떤 시스템도 처음 릴리즈 했던 모습을 유지하지는 않는다. 이는 기능 분해가 하나의 메인함수로만 구현된다는 개념과는 맞지 않는다
   - 처음에는 중요하게 생각했던 메인 함수가 시간이 지나면 동등하게 중요한 여러 함수들 중 하나로 전락하고 만다
- 메인 함수의 번번한 재설계
   - 새로운 기능을 추가할 때마다 메인 함수를 수정해야 한다 (_분기 문이 계속 추가되겠지_)
- __비지니스 로직과 사용자 인터페이스의 결합__
   - 급여 계산 기능: "사용자로 부터 소득세율을 입력받아 급여를 계산한 후 계산된 결과를 화면에 출력한다"
      - `비지니스 로직`: 급여를 계산한다
      - `사용자 인터페이스`: 소득세율을 입력받는다, 결과를 화면에 출력한다
   - 문제는 '비지니스 로직'과 '사용자 인터페이스'의 변경 빈도가 다르다. 
      - '사용자 인터페이스'가 훨씬 많이 변경이 되며, 1개의 비지니스 로직이 n개의 사용자 인터페이스와 대응될 수도 있다
   - 회면 출력이 방법이 변경되었을 때 `calculatePay`함수를 수정하지 않을수 있을까?
      ```ruby
      def calculatePay(name)
         taxRate = getTaxRate()
         pay = calculatePayFor(name, taxRate)
         puts(describeResult(name, pay))
      end
      ```

- 성급하게 결정된 실행 순서
   - `무엇(what)` 보다는 `어떻게(how)`에 집중하도록 만든다
   - 프로그램에서 함수의 제어 구조는 빈번한 변경의 대상인데, 기능이 변경될 때마다 이 부분들이 같이 변경되어야 한다
- 데이터 변경으로 인한 파급효과
   - 어떤 데이터를 어떤 함수가 사용하고 있는지를 추적하기 어렵다. (_이 부분은 요즘 IDE에서는 대응이 되지 않을까?_)
   - 데이터의 변경 포인트가 여러곳에 흩어져 있어서 모두 관리하는데 어려움이 있고, 놓칠경우 버그가 발생한다
   - __데이터 변경으로부터 영향을 최소화 화려면 데이터와 함께 변경되는 부분과 그렇지 않은 부분을 명확히 분리해야 한다__
      - 데이터와 함께 변경되는 부분을 하나의 구현 단위로 묶고 (응집도), 외부에서는 인터페이스를 통해서만 데이터에 접근해야 한다

__하양식 분해가 유용한 경우__
- 이미 해결된 알고리즘을 문서화 하고 서술할 때
- 실제로 동작하는 커다른 소프트웨어에는 적합하지 않다

## 03. 모듈
_정보 은닉이 핵심. namespace 개념으로 분리하고, 분리된 코드에 대해서는 함수를 통해서만 접근해라_

정보 은닉
- 시스템을 모듈 단위로 분해하기 위한 기본 원리
- 자주 변경되는 부분을 상대적으로 덜 변경되는 안정적인 인터페이스 뒤로 감춰야 한다

무엇을 감춰야 하나?
- 복잡성
   - 모듈이 너무 복잡하면 사용하기 어렵다
   - 모듈을 추상화 할 수 있는 인터페이스를 제공해서 복잡도를 낮춘다
- 변경 가능성
   - 변경이 낮은 부분을 모듈안으로 넣어서 응집도를 높여라

책 예시
```ruby
module Employees 
   $employees = ["직원정보"]
   ## 중간 생략

   def Employees.calculatePay(name, taxRate)
      if (Employees.hourly?(name)) then
         pay = Employees.calculateHourPayFor(name, taxRate)
      else
         pay = Employees.calculatePayFor(name, taxRate)
      end
   end
```
- `$employees`를 이용해서 `Employees` 모듈 내부로 숨겼다
- 외부에서는 `Employees`가 제공하는 함수를 통해서만 내부 변수를 조작할 수 있다

모듈의 장점
- 모듈 내부의 변수가 변경되어도 모듈 내부에만 영향을 미친다
- 비지니스 로직과 사용자 인터페이스에 대한 관심사를 분리한다
- 전역 변수와 전역 함수를 제거함으로써 네임스페이스 오염을 방지한다

모듈의 단점
- 인스턴스 개념을 제공하지 않는다
- `Employees` 는 직원 전체의 개념을 나타내는데, 좀 더 높은 추상화를 위해서는 개별 직원을 독립적인 단위로 다룰 수 있어야 한다

## 04. 데이터 추상화와 추상 데이터 타입
_모듈에서 한단계 더 나아가서 개별 인스턴스를 만들 수 있다. 어려면 좀 더 세부적인 추상화가 가능하다_

배경
- 프로시저 추상화로는 프로그램의 표현력을 향상시키는데 한계가 있다
- 리스코프(Barbara Liskov)가 `데이터 추상화`의 개념을 제안
   - 오퍼레이션을 이용해서 추상 데이터 타입을 정의할 수 있다 (_오퍼레이션을 포함하는 데이터 타입을 만들 수 있다_)
   - 추상 데이터 객체를 사용한다

책 예시
```ruby
# 구현
Employee = Struct.new(:name, :basePay, :hourly, :timeCard) do
   def calculatePay (taxRate)\
      if (hourly) then
         return calcaulateHourlyPay(taxRate)
      end 
         return calcaulateSalariedPay(taxRate)
   end

# 선언
$employees = [
    Employee.new("직원A", 400, false, 0),
    Employee.new("직원B", 300, false, 0),
    ..
]

# 사용
for each in employees
   if (each.name == name) .. 생략
```

장점
- 사람들이 세상을 바라보는 방식에 좀 더 근접해지도록 추상화 수준을 향상시킨다

주의점 (_이 부분은 잘 이해가 안되었음_)
- p.244 

## 05. 클래스
_드디어 클래스가 등장합니다. 클래스는 다형성을 통해서 한단계 더 추상화를 할 수 있습니다_

__클래스와 추상데이터 타입__
- 추상데이터 타입: 다형성 지원하지 않음
- 클래스: 다형성 지원함
- 추상데이터 타입은 타입을 추상화환 것이고, 클래스는 절차를 추상화한 것<br>(_타입 안에 절차가 있으니 클래스가 한단계 더 추상화 한다는 것일까?)__
   - 타입을 추상화 한다
      - 하나의 대표적인 타입이 다수의 세부적인 타입을 감추고 있다. 그렇기 때문에 오퍼레이션을 기준으로 타입을 통합하는 방법이다
   - 절차를 추상화 한다
      - 타입을 기준으로 오퍼레이션을 묶는다. 
      - 외부에서 보이는 인스턴스는 같이 보이지만, 내부에서 수행되는 절차는 다르다(_타입의 추상화 보다 한단계 더 추상화하는 개념이 맞는듯_)

다형성
```ruby
class Empoyee 
   def calculpatePay(taxRate)
      # 구현 없음
   end

class SalariedEmployee < Empoyee
   def calculpatePay(taxRate)
      # 정직원의 금액 계산
   end

class HourlyEmployee < Empoyee
   def calculpatePay(taxRate)
      # 아르바이트 금액 계산
   end

# 선언
$employees = [
    SalariedEmployee.new("직원A", 400),
    HourlyEmployee.new("직원B", 300),
    ..
]

# 사용 - 클라이언트 입장에서는 동일한 것
for each in employees
   result += each.monthlyBasePay() .. 생략
```

__그래서 객체지향__
- 그렇기 때문에 인스턴스 변수에 저장된 값을 기반으로 매서드 내에서 타입을 명시적으로 구분하는 방식은 객체지향을 위반하는 것
   - 변경에 대한 유연성 확보
- 객체지향에서는 타입 변수를 이용한 조건문을 다형성으로 대체한다
- 클라이언트가 객체의 타입을 확인한 후 적절한 메서드를 호출하는 것이 아니라 객체가 메시지를 처리할 메서드를 선택한다
- Open-Closed Principle, OCP
   - 기존 코드에 아무런 영향도 미치지 않고 새로운 객체 유형과 행위를 추가할 수 있는 객체지향 특성
   - _확장에는 열려있고, 수정에는 닫혀있어야 한다_

객체지향과 추상 데이터 타입에서 무엇을 선택해야 할까?
- 타입이 추가: 객체지향
- 오퍼레이션 추가: 추상 데이터 타입
- _객체지향은 타입을 추상화 한 것이고, 추상 데이터 타입은 오퍼레이션을 추상화한 것이니까 딩얀한듯?_
- _C#에서는 그럼 다형성이 필요없다고 생각되면 클래스로 만들고 이후에 필요하면 그때 분리하는 방식으로 하면 될듯하다_