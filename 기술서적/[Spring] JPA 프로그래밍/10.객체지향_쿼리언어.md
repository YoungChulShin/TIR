### 객체지향 쿼리 소개
종류
- JPQL
- Criteria 쿼리
   - JPQL을 편하게 사용하도록 해주는 빌더 클래스
   - 사용 방법이 복잡하다
- Native SQL
   - JPA에서 JQPL대신 직접 쿼리를 작성
   - 특정 DB에 특화된 기능을 사용할 때 필요하지만, DB가 바뀌면 또 변경을 해야 한다
- QuieryDSL
   - Criteria 처럼 JQPL쿼리를 만들어주는 빌더 클래스
   - 사용이 더 편해서 많이 사용된다
- JDBC 직접 사용, MyBatis 같은 매퍼 프레임워크 사용

### JQPL 소개
Typed Query<T>, Query
- 반환 타입이 명확하면 Typed Query를, 그렇지 않으면 Query를 사용

파라미터 바인딩
- 이름 기준: 바인딩 항목에 이름을 명시
   ~~~java
   em.createQuery("SELECT m FROM Member m WHERE m.username = :username", Member.class)
   .setParameter("username", usernameParam)
   .getResultList();
   ~~~
- 위치 기준: 바인딩 항목에 순서를 명시
   ~~~java
   em.createQuery("SELECT m FROM Member m WHERE m.username = ?1", Member.class)
   .setParameter(1, usernameParam)
   .getResultList();
   ~~~
- 이름 기준을 사용하는게 더 명확하다

NEW 명령어
- JQPL을 작성할 때 정해진 타입이 아니면 Object[]를 받아서 처리하게 된다. <br>
하지만 이 값이 명확하지 않기 때문에 실무에서는 DTO를 이용해서 변경해서 처리한다. 
- DTO 변환 과정에서 직접 값을 할당해주는 방법도 있지만, new 명령어를 사용하면 Select query에서 바로 DTO로 변환하는 방법도 가능하다
    ~~~java
    List<UserDTO> resultList = 
        em.createQuery("select new jpabook.jpql.UserDTO(m.userName, m.age) 
                        from   Member m", UserDTO.class);
    ~~~
- 주의점
   - 패키지 명을 포함한 전체 클래스 명을 입력해야 한다
   - 순서와 타입이 일치하는 생성자가 필요하다

페이징 API
- setFirstResult(int startPosition): 조회 시작 위치
- setMaxResults(int maxResult): 조회할 데이터 수

조인
- 내부 조인
   - 샘플 코드
    ~~~java
    String query = "select m from Member m inner join m.team t where t.name = :teamName";
    List<Member> members = em.createQuery(query, Member.class)
        .setParameter("teamName", teamName)
        .getResultList();
    ~~~
   - 조인한 엔티티를 모두 사용하려면 쿼리 절에 m, t 같이 모두 넣으면 된다.<br>
   이렇게 되면 TypedQuery를 사용할 수 없어서 Object[] 로 받아야 한다
- 페치 조인(fetch join)
   - 샘플 코드 
    ~~~java
    String 
    ~~~
   - 성능 최적화를 위해서 연관된 엔티티나 컬렉션을 한 번에 같이 조회하는 기능
   - 값을 조회 시점에 가져오기 때문에 지연로딩이 발생하지 않는다