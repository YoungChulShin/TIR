### 트랜잭션 범위의 영속성 컨텍스트
스프링 컨테이너 기본 전략
- 트랜잭션 범위의 영속성 컨텍스트 전략을 기본으로 한다
- 이 말은 트랜잭션의 범위와 영속성 컨텍스트의 생존 범위가 같다는 것을 의미한다
- @Transactional 애노테이션
   - 이 애노테이션이 있으면 메서드를 호출하기 직전에 Transaction AOP가 동작한다
   1. 메소드 호출 직전에 트랜잭션 시작
   2. 메소드가 종료될 때
      - 영속성 컨텍스트를 Flush = DB에 저장
      - 트랜잭션을 커밋한다
         - 그렇기 때문에 트랜잭션이 종료될 때 영속성 컨텍스트의 값이 DB에 저장된다
- EntityManger가 2개 이상이라도 트랜잭션이 같으면 같은 영속성 컨텍스트를 사용한다
- 이 말은 1개의 EntityManager를 2개의 Thread가 사용해도, Transaction이 다르기 때문에 다른 영속성 컨텍스트를 사용한다

### 준영속 상태와 지연로딩
프레젠테이션 계층
- 프레젠테이션 계층은 트랜잭션이 없기 때문에 엔티티는 준영속상태를 가진다
- 이 경우 지연로딩을 사용하면 에러가 발생한다

준영속 상태의 지연로딩 문제를 해결하는 방법
1. View가 필요한 엔티티를 미리 로딩해 두는 방법
   1. Fetch 전략을 EagerLoading으로 변경하는 방법
      - N+1 문제가 발생할 수 있기 때문에 조심해야 한다
      - 기본적인 조회는 문제되지 않는데, JPQL을 사용해서 조회하면 문제가 발생한다
      - 예를 들어서 Order를 조회하는데 Member를 함께 조회한다고 하면, Order가 10개일 때 Member도 10번 실행해서 조회한다
   2. JPQL에서 fetch join을 사용하는 방법
      - 이 경우에는 join 대상을 한번에 조회한다
        ~~~SQL
        select o
        from Order o
        join fetch o.member
        ~~~
      - 무분별하게 사용하면 화면에 맞춘 repository method가 늘어날 수 있다
   3. 강제 초기화
      - 지연로딩 항목을 Service 계층에서 참조하면서 강제 초기화 하는 방법
   4. FACADE 계층 추가
      - Controller와 Service 사이에 Transaction을 가지는 Facade 계층을 추가
      - 이 계층은 트랜잭션을 가지면서 View를 위한 값을 제공해준다
2. OSIV를 사용해서 프레젠테이션에서 영속 상태를 유지하는 방법
   1. OSVI
      - 영속성 컨텍스트를 View 영역까지 열어두는 것
   2. 스프링의 OSIv
      - 영속성 컨텍스트는 View를 포함하지만, 트랜잭션 범위는 Service까지 유지한다
      - View에서 영속성 상태를 조회 가능. 수정은 불가능
      - Viwe에서 수정한 이후에, Transaction이 다시 호출되면 flush가 발생하기 때문에 주의해야 한다
   