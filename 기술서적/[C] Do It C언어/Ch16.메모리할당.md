## 16.1 프로세스와 메모리
프로세스
- CPU가 실행파일(*.exe)에 있는 명령들을 실행하려면 먼저 운영체제가 실행 파일의 명령들을 읽어서 메모리에 재구성하게 되는데, 이것을 프로세스라고 한다
- 메모리에 프로세스가 구성되면 CPU는 프로세스에 저장된 명령들을 실행할 수 있다
- 프로세스를 '실행 중인 프로그램'이라고도 한다

프로세스 구성
- 세그먼트의 집합으로 구성
   - 세그먼트: 64Kbytes 이하의 메모리 블록
- 코드 세그먼트, 데이터 세그먼트, 스택 세그먼트로 구성
1. Code Segment, CS
   - 기계어 명령문
2. Data Segment, DS - 프로그램이 시작해서 끝날 때까지 사용되는 데이터
   - 문자열 상수
   - 전역벽수 (0으로 초기화)
   - static 전역 변수 (초기화 안됨)
3. Stack Segment, SS 
   - 지역 변수 (stack)
   - 동적 메모리 할당 (Heap)

정적 메모리 할당
- 컴파일러가 코드를 기계어로 변역하는 시점에 변수를 저장할 메모리 위치를 배정하는 것을 정적 메모리 할당(Static Memory Allocation)이라고 한다
- 메모리 할당 기준이 C언어 코드가 기계어로 변역되는 시점에 결정되기 때문에 정적 할당된 메모리 크기나 개수를 변경하려면 코드를 변경하고 다시 컴파일 해야 한다. 
- 프로그램이 실행 될 때 메모리의 크기가 정해져있으며, 실행 중간에 변경할 수는 없는 메모리

지역 변수 메모리 관리
- 같은 함수에 사용되는 변수들은 순차적으로 메모리에 관리된다. (=메모리 그룹으로 관리)
- A함수에서 B함수를 호출하면 B함수는 A함수의 뒤에 메모리 위치

## 16.2 지역 변수와 스택
스택
- 2개의 포인터(BasePointer-BP-, StackPointer-SS)로 데이터 관리
- PUSH: 데이터를 추가하는 작업
- POP: 데이터를 꺼내는 작업

스택 - assembly
   ```assembly
   move ax, 4   // ax 레지스터에 4를 저장
   push ax      // ax 저장된 값을 스택에 추가하고 SP 4 감소
   pop ax       // 스택에서 값 4를 꺼내서 ax 레지스터에 저장하고, SP 4 증가
   ```
- 위와 같이 되면 변수를 3번 선언한다면 Push가 3번 일어나고, 완료 시점에는 Pop이 3번 일어나게 된다.<br>
지역 변수가 많아 질 수록 당연히 효율적이지 않기 때문에 컴파일러는 이 방법을 사용하지 않는다
- 컴파일러는 sub, add 명령어를 사용해서 StackPointer를 필요한 공간 만큼 한번에 이동해서 메모리 공간을 확보한다

**컴파일러가 스택에 할당된 지역 변수를 사용하는 원리**
- CPU는 변수 (예: abc)에 할당된 메모리 공간에 직접 값을 넣거나 빼지 않는다.<br>
필요시 스택에서 값을 가져와서 레지스터를 통해서 값을 읽거나 쓴다
- a, b, c 순서로 있는 스택에서 b 값을 5로 변경하려고 하면 아래의 순서를 따른다
   1. POP 명령으로 c를 꺼내서 ax 레지스터에 넣는다
   2. POP 명령으로 b를 꺼내서 bx 레지스터에 넣는다
   3. bx레지스터에서 값을 5로 변경한다
   4. bx레지스터 값을 PUSH한다
   5. ax레지스터 값을 PUSH한다

   ```assembly
   pop ax
   pop bx
   move bx, 5
   push bx
   push ax
   ```

함수를 호출할 때 스택 메모리가 변화하는 과정
- 함수가 3개 (main, a, b) 있을 때 호출되는 방법
1. main 함수에 대한 스택 메모리 구성
   - BP(Base Pointer)
   - 지역 변수
   - SP(Stack Pointer)
2. main 함수가 a함수를 호출하는 시점에 메모리 구성
   - SP 뒤에 IP(Instruction Pointer)와 main함수의 BP가 저장
      - IP는 a함수가 실행되고 다시 main함수로 돌아왔을 때 main함수가 실행되어야 하는 실행 위치
      - main함수의 BP는 다시 main함수로 돌아왔을 때, main함수의 BP 위치 


## 16.3 동적 메모리 할당 및 해제
스택 메모리 크기
- 컴파일러 설정을 변경하지 않는다면, 1Mbyte

힙 메모리
- 스택 세그먼트에 위치
- Gbyte까지 할당할 수 있다
- _메모리 공간 재 공부_
   1. 코드 세그먼트
      1. 기계어 명령문
   2. 데이터 세그먼트
      1. 문자열 상수
      2. 전역 변수
      3. static 전역 변수
   3. 스택 세그먼트
      1. 동적 메모리(Heap)
      2. 지역 변수(Stack)

malloc (Memory Allocation)
- 동적 메모리 할당을 지원하는 C표준 함수
- 함수 원형: void *malloc(size_t  size)
   ```c
   void *p = malloc(100);  // 100바이트의 메모리를 할당하여 포인터 p에 저장
   ```
- void형을 사용하면 매번 형 변환(casting)을 해 주어야 하기 때문에, malloc함수를 사용하는 시점에 미리 형 변환을 사용하는 것이 좋다
   ```c
   short *p = (short *)malloc(100);   // 2바이트 50개 그룹이 생성

   int *p = (int *)malloc(100);   // 4바이트 25개 그룹이 생성

   int *p = (int *)malloc(sizeof(int) * 3)   // sizeof 연산자를 사용해서 메모리 사용 단위까지 대응 가능
   ```
- 한번에 너무 많은 크기(2Gb 이상)를 명시하거나, 계속된 메모리할당으로 힙에 공간이 부족하면 메모리 할당에 실패할 수도 있다
- malloc.h 를 추가해줘야 한다
- 동적할당은 Heap메모리 크기 + Heap주소를 가지는 포인터 4바이트로 구성된다

free
- 할당된 메모리 해제
   ```c
   free(p);
   ```

## 16.4 동적 메모리 사용
배열과 비슷한 형식으로 동적 메모리 사용하기
- 포인터의 데이터 타입보다 큰 동적 메모리의 경우에는 주소 값을 증가하면서 접근 및 사용이 가능하다
   ```c
   int *p = (int *)malloc(12);   // 12바이트 할당

   // 아래와 같이 접근 가능
   *p = 1;
   *(p+1) = 2;
   *(p+2) = 3; 
   ```