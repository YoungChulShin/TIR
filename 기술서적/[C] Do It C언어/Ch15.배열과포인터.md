## 15.1 배열과 포인터 표기법
배열과 포인터의 표기법
   ```c
   // 배열 -> 포인터
   char data[5];
   data[1] = 5;
   // 동일
   *(data + 1) = 5;

   // 포인터 -> 배열
   char data;
   char *p = &data;
   *p = 3;
   // 동일
   p[0] = 3;
   ```
배열 표기법에는 한계가 있어서 이를 포인터를 사용해서 대응할 수 있다
- 한계의 예시: 아래와 같이 data변수를 선언했을 때, data[0]에 0x78 값을 변경하려고 하면 배열 접근법으로는 방법이 없다
   ```c
   int data[2] = {0x12345678, 0x12345678};
   ```
- 포인터를 이용한 대응
   ```c
   //*(data + 1) = 0x22;  - 이렇게 하면 data[0]을 0x22로 변경하는 코드
   *(char *)(data + 1) = 0x22
   ```

## 15.2 배열 시작 주소
배열 변수의 이름은 배열의 시작주소
   ```c
   char data[4];
   char *p = &data[0];
   char *p = &*(data + 0); 
   char *p = &*(data); 
   char *p = data; 
   ```

배열이 포인터처럼 작동한다고 해서 완벽하게 포인터가 될 수는 없다
- 문법적으로 포인터는 다른 변수의 주소를 저장할 수 있지만 배열은 컴파일러가 제공하는 메모리 그룹화 기술
- 배열 이름은 변수처럼 보이지만 내부를 들여다보면 실제로는 상수화된 주소

## 15.3 배열을 사용하는 포인터
포인터로 배열의 주소를 저장하고 사용하면, 특정 배열의 값을 n번 참조할 때 발생하는 추가적인 연산을 줄일 수 있다
- 예제 코드
   ```c
   for (int i = 0; i < 10; i++) sum = sum + *(data + select)
   ```
- 추가적인 연산: data + select를 위한 연산이 계속 수행됨
- 대응법: data + select를 포인터 변수로 저장하고 대응
   ```c
   char *p = data + select;   // = &data[select]와 동일
   for (int i = 0; i < 10; i++) sum = sum + *p
   ```

## 15.4 배열과 포인터의 합체
```c
char *p[5]
```
위 코드는 연산자 우선순위에 의해서 *(p[5])이라고 선언한 것과 같다. 5개의 항목을 가지는 배열이 되고, *코드에 의해서 char*라고 정해진다.<br>

2차원 배열과 포인터를 통한 접근
```c
char data[3][5];
char (*p)[5]; // char[5]크기를 가지는 포인터를 선언
p = data;
```