# 아이템 49 - 매개변수가 유효한지 검사하라
메서드가 실행되기 전에 매개변수의 유효성을 검사해서 잘못된 값이 프로그램에 영향을 주거나, 잘못된 결과를 만들어내는 것을 막아야한다. 

'Public', 'Private' 메서드는 잘못된 매개변수가 왔을 때 던지는 예외를 문서화해야한다. 
```java
 /**
   * @throws ArithmeticException m이 0보다 작거나 같으면 발생한다
   */
public BigInteger mod(BigInteger m) {
```

`java.util.Objects.requireNonNull` 
- null 검사를 수동으로 할 필요 없이 이 메서드를 사용하자
- 입력을 그대로 반환하기 때문에 입력을 받아서 처리해도 되고, 반환 값은 무시하고 null 체크에 사용해도 된다

private 메서드는 'assert'를 활용해서 유효성을 검증할 수 있다

# 아이템 50 - 직시에 방어적 복사본을 만들라
불변식을 지키지 못하면 클라이언트 동작으로 코드가 깨질 수 있다. 

Date 예시
- 샘플 코드
   ```java
   public final class Period {
    private final Date start;
    private final Date end;

    public Period(Date start, Date end) {
        if (start.compareTo(end) > 0) {
        throw new IllegalArgumentException(start + "가 " + end + "보다 늦다");
        }
        this.start = start;
        this.end = end;
    }

   // 호출
   Date start = new Date();
   Date end = new Date();
   Period period = new Period(start, end);
   // Period가 수정될 수 있다
   start.setYear(2024);
   ```
- Date를 불변 아이템인 Instant, LocalDateTime, ZonnedDateTime으로 변경하면 해결할 수 있다

방어적 복사 
- Period를 사용하면서 불변식을 지키려면 어떻게 해야할까?
- 샘플 코드
   ```java
   public MutableToImmutablePeriod(Date start, Date end) {
    // 방어적 복사를 먼저 해서 코드가 오염되는 것을 막는다
    // 멀티쓰레드 환경에서는 유효성을 검사하고 복사본을 만드는 과정에서 값이 변경될 수 있기 때문에 복사를 먼저한다
    // Clone을 사용하면 해당 클래스가 다른 하위 클래스에서 재정의 되었을 수 있기 때문에 Clone을 사용하면 안된다
    this.start = new Date(start.getTime());
    this.end = new Date(end.getTime());

    if (this.start.compareTo(this.end) > 0) {
      throw new IllegalArgumentException(start + "가 " + end + "보다 늦다");
    }
   }

   public Date start() {
       // 접근자는 내부에서 어떤 타입을 쓰는지 명확하기 때문에 clone을 사용해도 된다
       return (Date)this.start.clone();
   }

   public Date end() {
       return (Date)this.end.clone();
   }
   ```
- 방어적 복사는 성능 저하가 따르고 항상 쓸 수 있는 것은 아니다. 호출자가 컴포넌트 내부를 수정하지 않는다는 확신이 있으면 생략할 수 있다