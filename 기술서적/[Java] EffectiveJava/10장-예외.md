# 아이템 69 - 예외는 진짜 예외 상황에만 사용하라
예외는 오직 예외 상황에서만 써야한다. 절대로 일상적인 제어흐름용으로 쓰면 안된다. 

잘 설계된 API라면 클라이언트가 정상적인 제어 흐름에서 예외를 사용할 일이 없게 해야 한다. 이를 위해서 '상태 의존' 메서드와 '상태 검사' 메서드를 제공해야한다

# 아이템 70 - 복구할 수 있는 상황에는 검사 예외를, 프로그램 오류에는 런타임 예외를 사용하라
자바 예외 구조
   - Throwable (checked)
      - Error (unchecked)
      - Exception (checked)
         - RuntimeException (unchecked)

호출하는 쪽에서 복구할 수 있다고 여겨지는 상황이라면 Checked Exception을 던져서 catch로 잡아 처리할 수 있도록 하자.
- 검사 예외는 에러 메시지를 조금 더 자세히하고, 복구하는데 필요한 정보를 알려주는 메서드를 함께 제공하는 것이 중요하다

비검사 예외나 에러를 던졌다는 것은 복구가 불가능하니 더 실행해봐야 득보다 실이 많다는 뜻이다. 프로그램 오류를 나타낼 때에는 런타임 예외를 사용하자. 

# 아이템 71 - 필요 없는 검사 예외 사용은 피하라
검사 예외는 API 사용자 입장에서 catch로 잡아서 처리하는 로직을 넣어야하기 때문에 비검사 예외보다는 부담을 준다. 물론 복구할 수 있는 경우라면 코드의 안정성을 높여준다. 

검사 예외를 피하라면 아래 2가지 방법을 검토해볼 수 있다. 
1. Optional을 반환하는 방법
   - 에러 정보를 검사 예외보다는 자세히 알려줄 수 없다
2. boolean으로 상태를 먼저 체크하고 true일 경우에 메서드를 실행하는 방법
   - 동시성 문제가 발생할 수 있다

# 아이템 72 - 표준 예외를 사용하라
표준 예외를 사용하면 다른 사람이 익히고 사용하기 쉬워질 수 있다. 

메서드가 던지는 모든 예외를 뭉뚱그를 수도 있지만, 특수한 일부는 따로 구반해서 쓰는게 보통이다. 
- 예: null 값을 허용하지 않는 메서드에 null을 던지면, IllegalArgumentException이 아닌 NullPointerException을 던진다.

Exception, RuntimeException, Throwable, Error는 추상 클래스라고 생각하고 직접 재사용하지 말자. 다른 예외들의 상위 클래스로 여러 성격의 예외를 포괄하는 클래스이기 때문에 안정적으로 테스트하기 어렵다. 

자주 사용하는 예외
- IllegalArgumentException: 허용하지 않는 값이 인수로 전달 되었을 때. null은 따로 NullPointerException을 사용한다
- IllegalStateException: 객체가 메서드를 수행하기에 적절하지 않을 상황일 때
   - 예: 초기화 되지 않은 객체를 사용하려 할 때
- NullPointerException: null을 허용하지 않는 메서드에 null을 던질 때
- IndexOutOfBoundsException: 인덱스가 허용 범위를 넘어섰을 때
- ConcurrentModificationException: 허용하지 않는 동시 수정이 발견되었을 때 
- UnsupportedOperationException: 호출한 메서드를 지원하지 않을 때
   - 예: 특정 Interfacef를 사용했지만, 구현체에서 그 기능을 지원하지 않을 때 

예외는 직렬화를 할 수 있는데, 직렬화에는 부담이 많이 따르기 때문에 표준 예외를 재사용할 수 있으면 재사용하자.
