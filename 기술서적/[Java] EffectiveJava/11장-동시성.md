# 아이템 78 - 공유중인 가변 데이터는 동기화해서 사용하라
동기화의 기능
- 배타적 실행
- 일관성 있는 읽기

Java에서는?
- synchronized
   - 배타적 실행
   - 일관성 있는 읽기
- Atomic (Lock이 아니라 CAS 방식을 사용해서 성능이 더 뛰어나다)
   - 배타적 실행
   - 일관성 있는 읽기
- volatile
   - 일관성 있는 읽기

불변 데이터만 공유하거나 가변 데이터는 단일 스레드에서만 쓰도록 하자. 

# 아이템 79 - 과도한 동기화는 피하라
과도한 동기화는 성능을 떨어뜨리고, 교착상태에 빠뜨리고, 예측할 수 없는 동작을 낳기도 한다.

동기화된 영역 안에서는 재정의할 수 있는 메서드는 호출하면 안되고, 클라이언트가 넘겨준 함수 객체를 호출해서도 안된다.
- 동기화된 영역 관점에서는 이런 메서드는 모두 바깥에서 온 외계인이기 때문에 어떻게 동작할 지 알 수 없다

동기화 영역에서는 가능하면 일을 적게하자.

# 아이템 80 - 스레드보다는 Executor, Task, Stream을 애용하라
스레드를 직접 다르면 Thread가 작업 단위와 수행 매커니즘 역할을 모두 수행하게 된다. Executor Framework에서는 이 2개가 분리된다. 

작업 단위
- Task
   - Runnable
   - Callable (Runnable과 비슷하지만 값을 반환하고 임의의 예외를 던질 수 있다)

수행 매커니즘
- Executor Service
   - 특정 태스크가 완료되기를 기다릴 수 있다(get())
   - 태스크 모음 중 아무것 하나(invokeAny) 혹은 모든 태스크(invoke all)가 완료되기를 기다린다
   - Executor Service가 종료하기를 기다린다

ForkJoinTask
- ForkJoinPool이라는 ExecutorService가 실행해준다
- ForkJoinTask는 하위 Task로 나뉠수 있고 Pool을 구성하는 스레드들이 이 태스크를 처리하고 먼저 태스크를 처리한 스레드가 다른 스레드의 태스크를 가져와서 처리할 수 있다. 이를 통해서 모든 스레드가 CPU를 최대한 활용하면서 높은 처리량과 낮은 지연시간을 달성한다. 