# 아이템 78 - 공유중인 가변 데이터는 동기화해서 사용하라
동기화의 기능
- 배타적 실행
- 일관성 있는 읽기

Java에서는?
- synchronized
   - 배타적 실행
   - 일관성 있는 읽기
- Atomic (Lock이 아니라 CAS 방식을 사용해서 성능이 더 뛰어나다)
   - 배타적 실행
   - 일관성 있는 읽기
- volatile
   - 일관성 있는 읽기

불변 데이터만 공유하거나 가변 데이터는 단일 스레드에서만 쓰도록 하자. 

# 아이템 79 - 과도한 동기화는 피하라
과도한 동기화는 성능을 떨어뜨리고, 교착상태에 빠뜨리고, 예측할 수 없는 동작을 낳기도 한다.

동기화된 영역 안에서는 재정의할 수 있는 메서드는 호출하면 안되고, 클라이언트가 넘겨준 함수 객체를 호출해서도 안된다.
- 동기화된 영역 관점에서는 이런 메서드는 모두 바깥에서 온 외계인이기 때문에 어떻게 동작할 지 알 수 없다

동기화 영역에서는 가능하면 일을 적게하자.

# 아이템 80 - 스레드보다는 Executor, Task, Stream을 애용하라
스레드를 직접 다르면 Thread가 작업 단위와 수행 매커니즘 역할을 모두 수행하게 된다. Executor Framework에서는 이 2개가 분리된다. 

작업 단위
- Task
   - Runnable
   - Callable (Runnable과 비슷하지만 값을 반환하고 임의의 예외를 던질 수 있다)

수행 매커니즘
- Executor Service
   - 특정 태스크가 완료되기를 기다릴 수 있다(get())
   - 태스크 모음 중 아무것 하나(invokeAny) 혹은 모든 태스크(invoke all)가 완료되기를 기다린다
   - Executor Service가 종료하기를 기다린다

ForkJoinTask
- ForkJoinPool이라는 ExecutorService가 실행해준다
- ForkJoinTask는 하위 Task로 나뉠수 있고 Pool을 구성하는 스레드들이 이 태스크를 처리하고 먼저 태스크를 처리한 스레드가 다른 스레드의 태스크를 가져와서 처리할 수 있다. 이를 통해서 모든 스레드가 CPU를 최대한 활용하면서 높은 처리량과 낮은 지연시간을 달성한다. 

# 아이템 82 - 스레드 안정성 수준을 문서화하라
모든 클래스가 자신의 동기화 수준을 명시해야한다. 그래야 클라이언트에서 지나치케 또는 충분하기 못한 동기화를 하는 상황을 피할 수 있다.

스레드 안정성 수준 (높은 기준)
1. 불변(immutable)
   - 상수와 같아서 외부 동기화가 필요 없다
   - String, Long, BigInteger
2. 무조건적 스레드 안전(unconditionally thread-safe)
   - 이 클래스의 인스턴스는 수정될 수 있으나, 내부에서 충분히 동기화하여 별도의 외부 동기화 없이 사용해도 안전하다
   - AtomicLong, ConcurrentHashMap
3. 조건부 스레드 안전(conditionally thread-safe)
   - 무조건적 스레드 안전과 같으니 일부 메서드는 동시에 사용하려면 외부 동기화가 필요하다
   - Collections.sychronized 래퍼 메서드들
4. 스레드 안전하지 않음(not thread-safe)
   - 이 클래스의 인스턴스는 수정될 수 있고, 동기화하려면 외부 동기화 매커니즘으로 감싸야한다
   - ArrayList, HashMap 
5. 스레드 적대적(thread-hostile)
   - 이 클래스는 메서드 호출을 외부 동기화로 감싸더라도 멀티스레드 환경에서 안전하지 않다

무조건적 스레드 안전 클래스를 작성할 대에는 synchroized 메서드 보다는 비공개 락 갹채를 이용하자.
   - 클래스가 외부에서 사용할 수 있는 락을 제공하면 클라이언트에서 일련의 메서드 호출을 원자적으로 수행할 수 있지만, 내부에서 처리하는 고성능 동시제어 매커니즘을 사용 못하거나, 클라이언트가 공개된 락을 오래 쥐고 놓지 않는 서비스 거부 공격을 수행할 수도 있다. 
   - synchroized 메서드는 외부에 공개된 락이다
   - 비공개 락은 클라이언트가 그 객체의 동기화에 관여할 수 없다
      ```java
      private final Object lock = new Object();

      public void foo() {
         synchroized(lock) { }
      }
      ```

