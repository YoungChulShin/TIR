# 아이템 57 - 지역변수 범위를 최소화하라
지역변수는 가능하면 처음 쓰일 때 선언하고, 동시에 초기화해서 사용한다

for/while문은 for문을 사용할 때 지역변수의 범위가 for문으로 한정되기 때문에 오류를 줄일 수 있다.

# 아이템 58 - 전통적인 for문 보다는 for-each문을 사용하라
for-each문은 `Iterable` 인터페이스를 구현하면 된다.

for-each문을 사용할 수 없는 상황
- 컬렉션을 순환하면서 원소를 제거해야한다면
   - removeif가 나오면서 필터링을 통한 삭제 가능
- 리스트나 배열을 순회하면서 원소의 값 혹은 전체를 교체해야할 때 
- 병렬 반복

# 아이템 59 - 라이브러리를 익히고 사용하라
이미 잘 만들어져있는 라이브러가 많기 때문에 가능하면 잘 활용하자
- 예: Random 보다는 자바7에 나온 ThreadLocalRandom을 사용하자

# 아이템 60 - 정확한 답이 필요하ㅏ면 float, double은 피하라
float와 double은 이진 부동소수점 연산에 쓰이며, 넓은 범위의 수를 빠르게 정밀한 '근사치'로 계산하도록 설계되었다. 따라서 정확한 결과가 필요할 때에는 사용하면 안된다. 
```java
// 이 코드를 수행하면 0.61이 나오지 않는다
System.out.println(1.03 - 0.42);
```

정확한 값이 필요하면 BigDecimal, int, long 중에 사용해야한다. 
- 소수점이 필요한 상황에서 성능 저하가 크게 신경쓰지 않는다면 BigDecimal을 사용하자. 대신 사용법이 조금 복잡하다. 
- 성능이 중요하고 소수점을 직접 추적할 수 있다면 범위에 따라 int, long을 사용하자

# 아이켐 61 - 박싱된 기본 타입 보다는 기본 타입을 사용하라
자바 기본 타입
- int, double, boolean, long 등

박싱된 기본 타입
- 자바 기본 타입에 대응되는 참조 타입
- Integer, Double, Boolean, Long 등

기본 타입과 박싱 타입의 차이
- 박싱 타입은 식별성을 가진다. 값이 같더라도 서로 다를 수 있다
- 박싱 타입은 유효하지 않은 null을 가질 수 있다
- 박싱 타입은 시간과 메모리 면에서 더 비효율 적이다. (힙 메모리를 찾아야하고, 스택에서 참조를 하니까)

박싱된 기본 타입을 `==` 연산을 사용하면 오류가 날 수 있다.

기본 타입과 박싱된 타입을 혼용한 연산은 박싱된 기본 타입의 박싱이 자동으로 풀린다. 
```java
Long sum = 0L;
for (long i = -; i <= Integer.MAX_VALUE; i++) {
    // sum이 언박싱
    // sum이 i와 계산
    // sum이 다시 박싱
    sum += i;
}
```

박싱된 타입은 언제 써야할까?
1. 컬렉션의 원소,키,값으로 사용한다. 
   - 컬렉션은 기본 타입을 담을 수 없다
2. 타입 매개변수
   - 예: `ThreadLocal<Integer>`
3. 리플렉션을 통한 메서드를 호출할 때

기본타입과 박싱타입 중 하나를 써야한다면 기본 타입을 사용하자.

# 아이템 62 - 다른 타입이 적절하다면 문자열 사용을 피하라
더 적합한 데이터 타입이 있거나 새로 작성할 수 있다면, 문자열을 쓰고 싶은 유혹을 뿌리쳐라. 문자열은 잘 못 사용하면 번거롭고, 덜 유연하고, 느리고, 오류 가능성도 크다. 

# 아이템 63 - 문자열 연결은 느리니 주의하라
문자열을 반복문에서 연결할 때에는 `+` 연산자가 아니라 StringBuilder를 사용하자
- 문자열은 불변이라서 +연산자로 계산하면 각각의 값을 복사해야 하기 때문에 속도가 느리다
- StringBuilder는 선언 시점에 어느정도의 공간을 만들고 여기를 채워가기 때문에 속도가 더 빠르다

# 아이템 64 - 객체는 인터페이스를 사용해 참조하라
적합한 인터페이스만 있다면 매개변수뿐 아니라 반환값, 변수, 필드를 전부 인터페이스 타입으로 선언하라. 객체의 실제 클래스를 사용해야할 때는 오직 생성자로 생성할 때뿐이다. 

인터페이스를 타입으로 사용하는 습관을 기르면 프로그램이 유연해 질 수 있다. 선언하는 구현체를 변경하면 되기 때문이다. 

예외 케이스
- 적합한 인터페이스가 없다면 클래스를 참조해야 한다. 예: String, BigInteger
- 추상클래스가 있다면 추상클래스를 참조한자
- 클래스에서 특별한 기능을 제공할 경우에는 클래스를 사용하지만, 가능하면 최소화하자

적합한 클래스가 없다면 계층구조 중 필요한 기능을 만족하는 가장 덜 구체적인 클래스를 타입으로 사용하자.

# 아이템 65 - 리플렉션보다는 인터페이스를 사용하라
리플렉션을 이용하면 프로그램에서 임의의 클래스에 접근할 수 있다.
- 이를 통해서 생성자, 메서드, 필드의 정보를 가져올 수 있고, 수정할 수 있다. 
- 인스턴스를 생성할 수도 있다

리플렉션의 단점
- 컴파일타임에 타입검사가 주는 이점을 누릴 수 없다
- 코드가 지저분해지고 장황해진다
- 성능이 떨어진다. (일반 메서드 호출에 비해서 느리다)

그럼 언제 써야할까?
- 컴파일타임에 이용할 수 없는 클래스의 인스턴스를 생성해야할 때 사용할 수 있다. (아래에 리플렉션을 이용한 인스턴스 생성 샘플 코드를 보자)

리플렉션을 이용한 인스턴스 생성 예시
```java
// Class 객체 생성
Class<? extends Set<String>> cl = null;
try {
   cl = (Class<? extends Set<String>>)Class.forName(args[0]);
} catch (ClassNotFoundException e) {
   System.out.println("클래스를 찾을 수 없습니다");
   return;
}

// 클래스 객체에서 생성자 추출
Constructor<? extends Set<String>> cons = null;
try {
   // Returns a "root" Constructor object
   cons = cl.getDeclaredConstructor();
} catch (NoSuchMethodException e) {
   System.out.println("생성자를 찾을 수 없습니다");
   return;
}

// 인스턴스 생성
Set<String> s = null;
try {
   s = cons.newInstance();
} catch (IllegalAccessException e) {   // ReflectiveOperationException를 이용하면 1개로 줄일 수 있다
   System.out.println("생성자에 접근할 수 없습니다");
   return;
} catch (InstantiationException e) {
   System.out.println("클래스를 인스턴스화 할 수 없습니다");
   return;
} catch (InvocationTargetException e) {
   System.out.println("생성자가 예외를 던졌습니다");
   return;
} catch (ClassCastException e) {
   System.out.println("Set를 구현하지 않은 클래스입니다");
   return;
}

// 생성자 집합 생성
s.addAll(Arrays.asList(args).subList(1, args.length));
System.out.println(s);
```

# 아이템 66 - 네이티브 메서드는 신중히 사용하라
자바 네이티브 인터페이스(JNI)
- 자바프로그램에서 네이티브 메서드를 호출하는 기술
- 네이티브 메서드는 C, C++로 작성한 메서드

네이티브 메서드는 저수준 자원이나 네이티브 라이브러리를 사용해야만 할 경우가 아니면 신중하게 생각하자. 사용한다면 철저하게 테스트를 하자. 

# 아이템 67 - 최적화는 신중히 하라
최적화를 통해서 빠른 프로그램을 작성하기 보다는 견고한 구조를 가지는 좋은 프로그램을 설계하자. 

설계가 중요하다
- public 타입을 가변으로 만들면(=내부 데이터를 변경할 수 있게 하면) 불필요한 방어적 복사를 유발할 수 있다
- 컴포지션으로 해결할 수 있으면 상속보다는 구현을 선택하자. 상속은 상위클래스에 종속된다.

# 아이템 68 - 일반적으로 통용되는 명명 규칙을 따르라
### 철자 규칙
패키지 이름
- 각 요소를 점(.)으로 구분해서 계층적으로 작성한다
- 바깥 조직에서도 사용된다면 조직의 인터넷 도메인 이름을 역순으로 사용한다
- 각 요소는 일반적으로 8자 이하의 짧은 단어로 한다. 예를 들어 utilities보다는 util처럼 의미가 통하는 약어를 추천한다

클래스, 인터페이스, 열거타입, 애너테이션
- 하나 이상의 단어로 이뤄지며, 각 단어는 대문자로 시작한다
- 널리 통용되는 줄임말 (max, min)을 제외하고는 단어를 줄여쓰지 않도록 한다
- 약자는 첫 글자만 대문자로 하는 쪽이 훨씬 많다. 예: HttpUrl, HTTPURL

메서드, 필드
- 첫 글자를 소문자로 시작한다. 나머지는 클래스와 같다
- 상수 필드
   - 모두 대문자로 작성한다
   - 밑줄(_)로 구분한다

지역변수
- 지역변수는 약어를 써도 좋다. 약어를 써도 변수가 문맥에서 의미를 쉽게 유추할 수 있기 때문이다. 예: i, denom, houseNum

입력 매개변수
- 일반 지역변수와 같지만, 메서드 설명 문서에 등장하기 때문에 신경을 써야한다

타입 매개변수
- 한 문자로 표현한다
   - 임의의 타입: T
   - 컬렉션 원소의 타입: E
   - 키, 값: K, V
   - 예외: X

### 문법 규칙
객체를 생성할 수 있는 클래스의 이름
- 단수 명사나 명사구를 사용한다. 예: Thread, Priority Queue, ChessPiece 등

객체를 생성할 수 없는 클래스
- 복수형 명사로 사용한다. 예: Collectors, Collections

인터페이스 이름
- 클래스와 똑같이 짓거나, able 혹은 ible로 끝나느 형용사로 짓는다. 예: Collection, Comparator, Runnable, Iterable, Accessible 등

동작을 수행하는 메서드의 이름
- 동사나 동사구로 짓는다. 예: apply, drawImage

boolean 값을 반환하는 메서드
- is, (드물게)has로 시작하고 명사나 명사구, 혹은 형용사로 기능하는 아무 단어나 구로 끝나도록 짓는다
- 예: isDigit, isProbablePrime, isEmpty, isEnabled, hasSilbings 등

반환 타임이 boolean이 아니거나 해당 인스턴스의 속성을 반환하는 메서드
- 명사, 명사구 혹은 get으로 시작하는 동사구로 짓는다. get으로 시작하는 형태만 써야한다는 주장도 있지만, 근거가 빈약하다
- 예: size, hasCode, getTime 등

객체의 타입을 바꿔서 다른 타입의 또 다른 객체를 반환하는 인스턴스 메서드
- toType 형태로 짓는다. 예: toString, toArray 등

객체의 내용을 다른 뷰로 보여주는 메서드
- asType 형태로 짓는다. 예: asList 등

객체의 값을 기본 타입 값으로 반환하는 메서드
- typeValue 형태로 짓는다. 예: intValue 등

정적 팩터리
- from, of, valueOf, instance, getInstance, newInstance, getType, newType을 흔히 사용한다

