# 01. 도메인 모델 시작하기
## 도메인이란
도메인은 소프트웨어로 해결하고자하는 문제의 영역. 
- 예: 온라인서점, 라스트마일

한 도메인은 다시 하위 도메인으로 나뉠 수 있다
- 예시
   ![1-2](/%EA%B8%B0%EC%88%A0%EC%84%9C%EC%A0%81/%5B%EA%B8%B0%EB%B3%B8%5D%20DDDStart/2%EC%B0%A8/image/1-2.jpg)
   - 카탈로그 도메인: 고객에게 구매할 수 있는 상품 목록을 제공
   - 주문 도메인: 고객의 주문을 처리
   - 혜택 도메인: 쿠폰이나 특별 할인 같은 서비스 제공
- 예: 라스트마일: 배송, 기사, 지점, 오더, 정산 등등

도메인의 구현은 모든 기능을 직접 구현할 필요는 없다
- 직접 구현
- 잘 만들어진 라이브러리 또는 외부 시스템
- 외부 업체에 구현 의뢰

## 도메인 전문가와 개발 간 지식 공유
각 영역에는 전문가가 있다. 전문가는 해당 도메인에 대한 지식과 경험을 바탕으로 본인들이 원하는 기능 개발을 요구한다
- 예: 회계 담당자 -> 정산 자동화, AS 기사 -> 문자를 빠르게 보내기 위한 템플릿
- 부릉 예: 라스트마일 운영실, 고객 지원팀, 기사, 지점, 상점 등 

개발자는 이런 요구사항을 분석하고 설계해서 코드를 작성하고 테스트하고 배포해야한다. 
- 잘 설계하기 위해서는 요구사항을 잘 분석하는게 중요하다
- 요구사항을 올바르게 이해하려면 개발자와 전문가가 직접 대화하는 방법이 있다. 이 과정에서 개발자도 도메인 지식을 갖춰야한다. 
- _개발자의 지식 자랑이 아니라, 우리는 결국 문제를 해결해야한다._

## 도메인 모델
도메인 모델이란?
- 특정 도메인을 개념적으로 표현한 것. (다양한 정의가 존재하는데, 이 책에서는 이렇게 표현)
- 도메인모델을 사용하면 여러 관계자들이 동일한 모습으로 도메인을 이해하고 지식을 공유하는데 도움이 된다

객체 도메인 모델
- 도메인이 제공하는 기능과 데이터를 함께 보여주는 모델
- 예시
   ![1-3](/%EA%B8%B0%EC%88%A0%EC%84%9C%EC%A0%81/%5B%EA%B8%B0%EB%B3%B8%5D%20DDDStart/2%EC%B0%A8/image/1-3.jpg)

상태 다이어그램
- 상태 전이를 표현. 상태의 변경이나 연관관계를 이해하는데 도움이 된다
- 예시
   ![1-4](/%EA%B8%B0%EC%88%A0%EC%84%9C%EC%A0%81/%5B%EA%B8%B0%EB%B3%B8%5D%20DDDStart/2%EC%B0%A8/image/1-4.jpg)

도메인 모델을 표현하는 방법은 다양하다
- 관계가 중요한 도메인이라면 그래프를 이용해서 모델링 할 수도 있고, 계산 규칙이 중요하다면 수학공식을 활용해서 모델을 만들 수도 있다
- 도메인을 이해하는데 도움이 되면 포현 방식은 중요하지 않다

개념 모델과 구현 모델
- 도메인 모델은 도메인 자체를 이해하기 위한 개념 모델이다
- 개념 모델을 이용해서 코드를 바로 작성할 수 있는것은 아니기 때문에 구현 기술에 맞는 구현 모델이 따로 필요하다

하위 도메인과 모델
- 도메인은 다수의 하위 도메인으로 구성된다
- 각 하위 도메인이 다루는 영역이 서로 다르기 때문에 같은 용어라도 하위 도메인마다 의미가 달라질 수 있다

## 도메인 모델 패턴
도메인 모델 패턴
- 도메인 모델과 각 모델간의 관계를 이용해서 문제를 해결하려는 패턴 (객체 지향과 유사)
- 반대되는 패턴: 트랜잭션 스크립트 패턴

일반적인 애플리케이션 아텍텍처 구성
- 구성
   ```
   //////////////////////
   Presentation
   //////////////////////
   Application
   //////////////////////
   Domain
   //////////////////////
   Infrastructure
   //////////////////////
   ```
   - Presentation: 사용자의 요청을 처리하고 사용자에게 정보를 보여준다. 사용자는 소프트웨어를 사용하는 사람이 될 수 도 있고, 외부 시스템이 될 수도 있다
   - Application: 사용자가 요청한 기능을 실행한다. __비지니스 로직을 직접 구현하지 않고, 도메인 계층을 조합해서 기능을 실행한다.__
   - Domain: 비지니스 로직을 구현한다
   - Infrastructure: 데이터베이스나 메시징 시스템같은 외부 시스템과의 연동을 처리한다

주문 도메인 예시
- 규칙
   - 출고 전에 배송지를 변경할 수 있다
- 코드
   ```java
   public class Order {

    public void changeShippingInfo(ShippingInfo newShippingInfo) {
        // '출고전에 배송지를 변경할 수 있다'라는 규칙으 체크하기 위한 로직이 들어간다
        if (!isShippingChnageable()) {
            throw new IllegalStateException("...");
        }

        this.shippingInfo = newShippingInfo;
    }
   }
   ```
- 중요한것은 이런 비지니스 로직이 주문 도메인 모델에 있어야한다는 것이다

## 도메인 모델 도출
요구사항(기획서, 유스케이스, 사용자 스토리)과 관련자들과의 대화를 통해서 도메인 모델 초안을 만들어야 코드를 작성할 수 있다. 

도메인을 모델링할 때 기본이 되는 작업은 모델을 구성하는 핵심 구성요소, 규칙, 기능을 찾는 것이다. 

과정 1. 요구사항 정리
   ```
   - 최소 한 종류 이상의 상품을 주문해야한다
   - 한 상품을 한 개 이상 주문할 수 있다
   - 총 주문 금액은 각 상품의 구매 가격 합을 모두 더한 금액이다
   - 출고를 하면 배송지를 변경할 수 없다
   - ..
   ```

과정 2. 요구사항을 바탕으로 `기능`을 파악할 수 있다
   ```
   - 출고를 하면 배송지를 변경할 수 없다 -> 출고 상태로 변경하기, 배송지 정보 변경하기
   - 출고 전에 주문을 취소할 수 없다 -> 주문 취소하기
   - 고객이 결제를 완료하기 전에는 상품을 준비하지 않는다 -> 결제 완료하기
   ```

과정 3. 기능을 코드로 옮기기, 규칙 추가하기
   - 일부는 구현수준까지 만들어지고, 일부는 이름정보만 만들어지기도 한다
   - 이렇게 만들어진 모델은 요구사항 정련을 위해 도메인 전문가나 다른 개발자와 논의하는 과정에서 공유되기도 한다

## 엔티티와 밸류
도메인 모델은 크게 `엔티티`와 `밸류`로 구분할 수 있다. 
- 예: 주문 도메인 모델
   ![1-6](/%EA%B8%B0%EC%88%A0%EC%84%9C%EC%A0%81/%5B%EA%B8%B0%EB%B3%B8%5D%20DDDStart/2%EC%B0%A8/image/1-6.jpg)

### 엔티티
특징
- 식별자를 가진다. 
   - 각 엔티티는 서로 다른 식별자를 갖는다
   - 식별자가 같으면 같은 엔티티로 판단할 수 있다. (식별자를 이용해서 equals, hashcode를 구현할 수 있다)
   - 예: Order -> OrderNumber
- 엔티티를 생성하고 속성을 바꾸고 삭제할 때까지 식별자는 유지된다

식별자 생성
- 특정 규칙에 따라서 생성: 주문번호, 운송장 번호, 카드번호 등
- UUID, Nano ID 같은 고유 식별자 생성기 사용
   - UUID는 순서가 없기 때문에 고유키로 사용하기에는 조심해야한다. 순서가 있는 UUID도 있긴하다. 
- 값을 직접 입력: 회원 아이디, 이메일 등
- 일련번호 사용: DB 시퀀스나 자동증가 칼럼

### 밸류 타입
특징
- 사용 예시: 개념적으로 완전한 하나를 표현할 때 사용
   - 예: Address, Money(amount, currency) 등
   ```java
   // 수정 전
   public class ShippingInfo {

      private String receiverName;
      private String receiverPhoneNumber;
   }

   // 밸류 타입 반영
   public class Receiver {
      private String name;
      private String phoneNumber;
   }

   public class ShippingInfo {

      private Receiver receiver;
   }
   ```
- 사용 예시: 의미를 명확하게 표현하기 위해서 사용
   - 예: int -> Money, String id -> OrderNo id;
   ```java
   // 수정 전
   public class OrderLine {
      private int price;
      private int amounts;
   }

   // 밸류 타입 반영
   public class Money {
      private int value;
   }
   public class OrderLine {
      private Money price;
      private Money amounts;
   }
   ```
- 부가 효과: 밸류 타입을 위한 기능을 추가할 수 있다
   - 예: Money 타입에는 돈 계산 기능을 추가할 수 있다
   ```java
   public class Money {
      private int value;

      public Money add(Money money) {
         return new Money(this.value + money.value);
      }

      public Money multiply(int multiplier) {
         return new Money(value * multiplier);
      }
   }
   ```
- 밸류 객체의 데이터를 변경할 때에는 기존데이터를 변경하는 것보다, 새로운 객체를 생성하는 방식을 선호한다.
   - 불변(immutable) 타입 객체 생성
   - 코드를 조금 더 안전하게 작성할 수 있다
- 밸류 객체는 같은지 비교할 때, 모든 속성이 같은지 비교한다

### 엔티티 식별자와 밸류 타입
엔티티 식별자는 보통 String 같은 문자열로 구성되는 경우가 많은데, 밸류타입을 사용하면 의미가 잘 드러나도록 할 수 있다

### 도메인 모델에 set 메서드 넣지 않기
set 메서드 단점
- 도메인의 핵심 개념이나 의도를 코들에서 사라지게 한다
   - 비지니스로직을 통과해서 변경될 수 있는 필드라도 set 메서드가 설정되어 있다면 외부에서 임의로 값을 변경할 수 있다. 
- 도메인 객체를 생성할 때 온전하지 않은 상태가 될 수 있다
   - 예: 아래 코드는 '주문자 설정'을 누락하고 있다
      ```java
      Order order = new Order();
      order.setOrderLine(lines);
      order.setShippingInfo(shippingInfo);
      ```
   - 이 경우에는 생성자를 이용하면 필요한 올바른 값들을 넘길 수 있고, 생성자 내에서 데이터 정합성도 검사할 수 있다
- 예외: 도메인 객체 내에서 private 접근 범위를 가지는 set 메서드는, 내부에서 데이터 변경을 목적으로 사용되므로 사용될 수 있다

### 도메인 용어와 유비쿼터스 언어
유비쿼터스 언어
- 에릭에반스의 ['Domain Driven Design(=DDD, 2003)'](http://www.yes24.com/Product/Goods/5312881) 책에서 유비쿼터스 언어를 소개
- 전문가, 관계자, 개발자가 도메인과 관련된 공통의 언어를 만들고 이를 대화, 문서, 도메인 모델, 코드, 테스트 등 모든 곳에서 같은 용어를 사용한다
- 이를 통해서 용어의 모호함을 줄이고, 개발자는 도메인과 코드 사이에서 불필요한 해석 과정을 줄일 수 있다
- 새로 발견한 용어는 코드나 문서에도 반영해서 산출물에 최신 모델을 적용한다
- 한국 개발자는 영어로 표현되는 용어 어려움을 겪을 수 있는데, 도메인 용어 알맞은 단어를 찾는 시간을 아끼지 말자
- 예
   ```java
   // 유비쿼터스 언어가 녹아있지 않은 경우
   public enum OrderState {
      STEP1, STEP2, STEP3, STEP4, STEP5, STEP6;
   }

   // 유비쿼터스 언어가 녹아있는 경우
   public enum OrderState {
      PAYMENT_WAITING, PREPAIRING, SHIPPED, DELIVERING, DELIVERY_COMPLETED;
   }
   ```
