# 1장. 구조적인 접근
효과적인 디버깅의 단계
1. 소프트웨어가 왜 이상하게 작동하는지 알아낸다
2. 문제를 수정한다
3. 다른 곳이 깨지지 않게 한다
4. 코드의 전반적인 품질(가독성, 구조, 테스트 커버리지, 성능 등)을 유지하거나 향상시킨다
5. 같은 문제가 다른 부분에는 없는지 살펴보고, 재발 방지책을 마련한다
- __근본 원인을 찾아내는 것이 제일 중요하다__

핵심 디버깅 과정
- 과정
   - 재현: 해결하려는 문제를 재현할 수 있는, 신뢰할 수 있으면서도 쉬운 방법 찾기
   - 진단: 가설을 세우고, 버그를 발생시키는 원인을 찾았다고 확신할 수 있을 때까지 실험으로 테스트하기
   - 수정: 문제를 고치기 위해 어떻게 코드를 수정할지 설계하고 구현.<br>
   회귀를 만들지 않으면서도, 소프트웨어 전반적인 품질은 유지하거나 향상시켜야 함
   - 반영: 버그에서 교훈얻기. 어디에서 잘못됐나? 다른 곳에는 같은 문제가 없을까?
- 위 과정이 순차적으로 일어나지는 않는다. 반복의 연속이다.

'무엇을'에 대해서 알고 있어야 한다
- 문제를 재현하거나 원인에 대한 가설을 세우기 전에 먼저 어떤일이 발생했는지를 정확하게 알아야 한다. 
- 마찬가지로 어떤 일이 벌어져야 하는지를 아는 것도 중요하다
- 어떻게 작동해야 하는지 명확하지 않다면 정확하게 알기 전까지는 아무런 변경도 하지 말라.

간단한 것부터 살펴보기
- 많은 버그는 실수로 부터 생긴다
- 미묘한 버그도 있겠지만 간단한 것이라고 그냥 지나치지 말자

'이건 내가 만든게 아냐(Not Invented Here)' 증후군
- 어째서인지 개발자들은 모든 것을 직접 확인해야 한다는 강박관념에 시달리는 것 같다. 
- 이런 현상은 훨씬 멋진 해결책이 이미 있음에도 불구하고 직접 구현해야 직성이 풀리는 '이건 내가 만든게 아냐' 증후군에서도 잘 나타난다.
- 디버깅에서 모든 문제를 내가 직접 디버깅해야 한다고 느낄 때 같은 실수를 하게 된다. 
- __다른 팀원들에게 '혹시 전에 이런 거 본 사람?' 이라고 물어보는 데 드는 비용은 거의 안들지만 엄청난 삽질을 막아줄 수 있다.__ 

# 2장. 재현
__디버깅을 하려면 먼저 문제 재현 방법을 찾아야 한다. 재현 할 수 없으면 진도를 나갈 수 없기 때문이다.__

재현을 시작하기
1. 분명한 것부터 시작하기
   - 버그 리포트에 있는 것부터 따라해보기
2. 노력 집중하기
   - 먼저 개발 환경과 버그 발생 환경을 동일하게 구성해야 한다
      1. 소프트웨어 그 자체(=동일한 버전)
      2. 실행 환경
      3. 입력 값

환경 제어
- 가능하면 모든 환경에 편리하게 접근할 수 있도록 테스트 환경을 구축해야 한다. (예: 가상머신)

입력 제어
- 입력 형태와는 상관없이 가장 중요한 것은 어떤 입력을 받았는지 파악한 후 똑같이 재생하는 것이다
- 고객이 어떤 것을 했는지를 성심껏 알려줬더라도 충분하지 않을 수 있다. 중요한 상세정보는 최종 고객에게 잘 보이지 않거나 전혀 볼 수 없는 경우가 대부분이다. 예를 들어 버그가 미묘한 타이밍 때문에 생긴다거나, 서드파티 시스템에서 받은 입력 때문에 생길수도 있다.
- 필요한 정보가 부족하다면 아래 2가지 방법을 선택할 수 있다. 하나는 어떤 입력을 받았는지 추론하는 것이고, 다른 하나는 입력을 기록하는 것이다. 
   1. 입력 추론하기
      - 거꾸로 작업해보기(찾아가보기)
      - 탐색하기: 버그 리포트에 적혀있는 방법과 비슷하게 이것저것 해보기
         - __사고 방식을 180도 바꿔보는 것도 하나의 방법이다. 우리는 문제가 없음을 증명하려는 것이 아니라, 문제가 있음을 증명해야 한다__
      - 억지로 에러 상태 만들기
      - 임의성 도입하기: 랜덤 값을 추가해 보는 방법
   2. 입력 값 기록: 로그로 입력을 직접 기록하는 것
      - 로그
         - 로그 프레임워크를 이용해서 도움을 받는다
         - 로그가 항상 최신 로그를 반영하도록 하고, 로그를 위한 로그는 남기지 말자 
      - 외부 로그
         - 디버깅 시점에 로깅 프록시를 이용하는 방법
         - '클라이언트' <-> 로깅 프록시(로그 기록) <-> 서버
         - 심(shim): 큰 라이브러리와 클라이언트 코드 사이를 연결해주는 간단한 라이브러리

재현 방법 다듬기
- 피드백 루프 최소화하기
   - 가장 짧으면서도 에러가 없는 수정-컴파일-실행-재현 주기를 만들어야 한다
   - 여타 소프트웨어 개발 영역과 마찬가지로 피드백 루프를 최소화하는 게 가장 중요하다
- 최대한 단순하게
   - 불필요한 부분을 찾아서 제거하는 작업을 먼저 해야 한다
   - 예를 들어서 100줄의 코드에서 50줄이 디버깅과 상관없다면 50줄을 제거하고 디버깅해야 한다
- 필요 시간 최소화 하기
   - 어떤 버그는 재현하는 데 시간이 걸린다.
   - 수 천 번 요청을 받고 나서야 크래시 되는 경우도 있는데, 보통은 메모리 누수 문제다. 
   - 이 부분이 의심스럽다면 메모리 양을 제한하거나, 메모리 누수를 만드는 임의 기능을 추가해서 검토한다
- 비결정적인 버그를 결정적인 것으로 만들기
   - 내부 상태를 초기화하지 않은 채로 사용
   - 외부 시스템과 상호 작용: 외부 시스템을 직접 제어하기 보다는, 외부 시스템을 디버깅용 하위 시스템이나 테스트 대역 같이 우리가 제어할 수 있는 것으로 바꿔보자
   - 일부러 넣은 임의성: 동일한 난수 값으로 테스트 한다
   - 다중 스레드
   - __로그 파일 재생__
      - 에뮬레이트 서드파티 서버가 로그를 읽어 똑같이 순서대로 작업을 재현할 수 있음을 보여준다
- __반복: 재현 과정을 끊음없이 다음을 수 있고, 또 그래야 한다__
   1. 어떤 모듈이 연관돼 있는지를 알고 나년 입력 파일 요소 중 어디에서 버그가 생기는지 끄집어 낼 수 있다
   2. 서드파티 서버와 통신하는 서브시스템을 항상 정해놓은 응답만 리턴하는 스텁으로 바꾸면 문제를 100% 재현할 수 있다
   3. 어느 함수가 문제를 일으키는지 알았다. 특정 인자로 이 함수를 호출해서 버그를 재현할 수 있는 단위 테스트를 만든다

정말로 버그를 재현할 수 없으면?
- __실제로 버그가 없을 수도 있다__
   - 하지만 모든 상황을 다 파악했는지 주의해야 한다. 개발자들은 너무 쉽게 이런 결론에 도달하는 경향이 있다
   - 사용자들이 악감정으로 버그 리포트를 보내지 않는다. 뭔가 잘못된 게 있을 가능성이 높은 것이다. 사용자가 원했던 것보다 불명확하게 설명했을 수도 있고, 소프트웨어의 어떤 부분을 잘못 이해했을 수도 있다. 시간을 내서 자신이 해본 것을 설명하면서 사용자가 실제로 겪은 일을 알 수 있게 해줄 추가 정보는 없을지 찾아보자. 
- __다른 사람 끌어들이기__
   - 다른 시각으로 문제를 따져볼 수 있는 사람을 데려올 수 있으면 좋다.
   - 예를 들어 고객 지원 팀 사람이라면 사용자에 대해서 잘 알 것이다. 
   - 할 수만 있다면 버그를 가장 먼저 알려준 사람을 데려오는게 가장 좋다. 

데드 레커닝 (dead reckoning)
- 보통 경험에 기댄 디버깅 방식이 좋지만 방법이 이것만 있는 것은 아니다
- 소프트웨어가 왜 이렇게 실행되는지를 순전히 논리만으로 증명하는 방법이 있다. 
   - 설명서를 확인해보거나, Spec.을 기준으로 하나하나 다 확인해보거나

# 3장. 진단

디버깅 방법
1. 소프트웨어 작동에 대해 알고 있는 것을 검토하고, 버그 원인에 대한 가설을 세운다
2. 가설을 검증할 수 있는 실험을 설계한다
3. 실험으로 가설이 실패했다면 다시 가설을 만든다
4. 시험으로 가설이 성공했다면 또 다른 증거가 있는지 확인한다. 또 다른 증거가 필요하다면 다른 실험을 계속 해본다.<br>그게 아니라면 종료한다



# 4장. 수정
소스를 수정을 할 때는 형사가 아닌 소프트웨어 엔지니어가 되어야 한다
- 형사
   - 다양한 가설을 증명/반증하면서 자유롭게 생각의 나래를 펼혔다
- 소프트웨어 엔지니어
   - '우마거나 되는 대로' 방식이 아니라 좀더 엄격하고 구조적으로 접근해 품질을 높이고 신뢰할 수 있도록 소스를 수정해야 한다

수정의 목표
- 문제 수정
- 회귀 방지
- 코드의 전반적인 품질을 유지하거나 향상시키기

__수정 과정__
- 수정 준비
   - 소스코드가 깨끗한 상태에서 시작해야 한다
   - 재현, 진단 과정에서 수정된 소스가 있으면 잠시 다른 곳에 옮겨두더라도 깨끗한 상태에서 진해해야 한다
- 테스트
   - 모든 테스트가 통과하는 것을 확인하고 진행한다
   - TDD 접근 방식
      1. 기존 테스트를 실행해보고 모두 통과하는지 확인한다
      2. 새로운 테스트를 추가하거나 기존 테스트를 수정해 버그가 있는 것을 보여준다(=실패시킨다)
      3. 버그를 수정한다
      4. 제대로 수정했는지 확인한다. (=테스트가 성공한다)
      5. 회귀가 생기지 않았음을 확인한다. (= 이전에 성공했던 테스트가 실패하지 않는다)
   - TDD를 안하고 있다면?
      - 자동이 아닌 수동 테스트가 있다는 점, 테스트가 끝나도 남는게 없다는 점이 차이가 있다.
      - 회귀 테스트가 없기 때문에 회귀가 생기지 않도록 조심해야 한다
- 증상이 아닌 원인을 고친다
   - 원인을 고쳐야지 증상인 버그를 고치는데 집중하면 안된다
      ~~~c
      int process_items(item* item_array, int array_size) 
      {
         int i;

         // 이유는 모르겠지만 array_size에 하나 모자람 문제가 있어 수정한
         array_size++;

         // 이후 처리
      }
      ~~~ 
   - 근본 문제를 제대로 해결했는가는 개발자 스스로가 보통 잘 안다. 정직성과 연결되어 있다.<br>
   근본 원인을 찾지 못했다면 이를 인정하는 용기가 필요하다.
- 리팩토링
   - 리팩토링의 핵심 통찰
      - 광범위한 단위 테스트 스위트가 안전망 역할을 해 줄 때에만 기존 코드를 안전하게 수정할 수 있다
      - 절대로 코드의 작동을 변경하면서 동시에 리팩토링하면 안 된다
- 체크인
   - 디버깅 관점에서는 변경 사항에 대해서 추적할 수 있는 기회를 제공한다
   - '로직을 하나 바꿀 때마다 체크인하기' 규칙
   - 체크인을 하기 전에는 어떤 것을 체크인하는지 `Diff` 등을 통해서 확인해보는 것이 좋다
- 코드 리뷰 받기
   - 누구에게?: 작업에 익숙한 사람에 물어보는 것이 좋지만, 그렇지 않은 사람에게 물어본다고 해도 신선한 시각에서 리뷰를 받을 수 있다
   - 언제?: (저자의 경험적으로) 분명하지 않거나 위험하다고 생각되는 부분에 왔을 때마다 코드 리뷰를 고려해보는 것이 좋다

# 5장. 반영
"이게 어떻게 지금껏 실행되고 있었지?" 라는 생각이 든다면
- 잠시 멈추고, 코드에 대한 이해를 더 높이자
- 가끔 실패할 것으로 예상되는 코드가 성공하는 경우가 있는데, 이런 테스트 코드는 더 중요하게 봐야 한다

무엇이 잘못되었는가?
- 비난하려는 문화는 팀워크를 갉아먹는다
- 문제를 찾은 후에 이를 어떻게 처리할 것인가가 그 문제가 있었다는 사실보다 훨씬 더 중요하다

__동료에게 이야기해주기__
- 동료에게 그가 한 실수를 알려주는 것은 지뢰밭을 걷는 것과 같다
- 몇가지 방법을 알아보자
   - 좋은 의도로 피드백을 주는게 가장 중요하다. 뻐기고 싶은 마음에 그 사람의 실수를 예기하려 한다면 닥치고 가만히 있자
   - 대화를 하기 전에 어떤 얘기를 할 지 먼저 계획하고 생각하자. 똑같은 이야기를 다른 사람이 나한테 한다면 어떨지 생각해보자. 
   - 개인적인 의견은 달지 말자. '너가', '당신이'라고 이야기하는 것보다, '내가', '우리가' 라고 예갸히는게 좋다
   - 생산적이 되자
   - 우리가 실수하는 것일수도 있다는 점을 잊지 말자. 단순히 누구에게 실수했다고 이야기하는게 아니라, 그 사람과 함께 가능성을 찾아보자.


# 6장. 문제 발견
버그 추적 시스템을 통해서 버그를 잊지 않고 관리할 수 있다. 
- 릴리즈 할 때 마다 어떤 버그가 있는지 알 수 있다. 
- 버그의 우선순위를 관리한다
- 버그의 현재 상태를 알 수 있다

버그 리포트
- 포함 내용
   - 상세하고, 분명하며, 구체적이어야한다
   - 에러 메시지는 무엇인지
   - 데이터는 어떻게 손상되었는지
   - 어떻게 했더니 그 문제가 발생했는지
   - 출력은 어떻게 다른지
- 유일해야 한다

환경과 설정 보고하기
- __작동에 영향을 미칠만한 모든 환경을 기록하는 옵션을 소프트웨어에 추가하면 골치아픈 문제를 해결할 수 있다__
- 소프트웨어에서 지원하는 모든 설정 옵션에 대해서도 자동으로 기록할 수 있게 해주면 좋다

### 고객과 작업하기
__버그 리포트의 품질 향상__
- 버그 리포팅 쉽게 만들기
   - 버그를 보고할 수 있는 방법에 대한 설명을 정보 대화상자, 온라인 도움말, 웹사이트 등에 둔다
- 자동화
   - 최상위 예외 처리 루틴을 넣고, 여기에서 사용자가 관련 상세 정보가 전부 들어있는 버그 리포트를 제공할 수 있는 옵션을 제공한다
- 버그를 보고할 수 있는 다양한 옵션을 제공 (이메일, 온라인 등)
- 간단하게 유지하기
   - 사용자가 해야하는 작업이 하나 늘어날 때마다 버그 리포팅을 완료하는 인원이 반으로 줄어든다
      예: 5번 입력을 해야 하면 1/32로 준다
- 형식에 너무 집착하지 않기
   - 리포트에 표준이 있는 것은 좋지만 너무 집착하지 않게 주의하자.
   - 입력 사항에 '모두 해당 안 됨'도 있을 수 있다
- 개인 정보 존중
- 최소로 작성한다

__경험상 사용자 한 명이 우리에게 어떤 문제를 얘기해줬다면 같은 문제를 겪고독 아무 말 안 한 사용자는 최소 10명에서 최대 100명은 더 있다__

__효과적인 의사소통__
- _서로의 다름을 이해해야 한다_
- 개발자는 고객보다 코드를 더 잘 알고, 고객은 개발자보다 문제 도메인에 대해 더 잘 안다. 그리고 서로 사용하는 용어도 다르다.
- 개발자는 미세한 차이도 중요한 단서가 될 수 있다는 사실을 알지만, 사용자들은 그것을 모르는 경우가 태반이다.<br>
그래서 에러 메시지를 결과 그대로 안알려준다거나, '상관없어'보이는 부분을 대강 얼버무릴 경우가 많다.<br>
개발자가 상세한 부분까지 캐묻기 시작하면 싫어할지도 모른다

피드백 제공
- __사용자가 버그 리포트를 제출하면 그에 대해 답을 주고, 프로세스 진행 과정을 알려줘서 고마움을 표현해야 한다__

### 지원팀과 일하기
QA팀과 짝을 이뤄 버그를 진단해보는 것도 도움이 될 수 있다

# 7장. 실질적인 무관용
버그 우선순위
- 기본적으로는 빠른 수정이 늦은 수정보다 훨씬 좋은 전략이다
   - 나중에 버그를 수정하려고 하면 수정이 얼마나 걸릴지 알 수 없다. 
   - 버그가 발생했을 때 바로 수정하는 것이 바람직하다. 그리고 버그를 수정할 수록 품질은 올라간다
- 빠른 수정의 2가지 원칙
   1. 개발하는 동안 버그를 찾을 수 있는 과정(테스트, 코드 리뷰, 실행되는 소프트웨어 인도)을 반복한다
   2. 무엇보다 버그 수정 우선순위가 높다

깨진 창문 없애기
- 문제는 늘어나고 낮은 품질은 전염되기 쉽다
- 유일한 방법은 버그를 발견하자마자 근절시키는 것이다
- 항상 버그의 개수를 0으로 유지하는 것이 목표다.

디버깅할 때 마음가짐
- 극단적인 것은 좋지 않다. (버그가 있는 것을 당연하거 여기거나, 무조건 버그가 있어서는 안된다고 하는거나)
- 버그 없는 소프트웨어를 달성할 수 있는 목표로 두고 행동해야 한다. 버그가 빈틈사이로 나왔다면 여기에서 교윤을 얻어 재발하지 않도록 모든것을 다해야 한다.

### 안좋은 코드가 발생했을 때 전략
더 나빠지지 않게 하기
- 새로 작성하는 코드는 표준에 맞게 구현한다

더러운 코드로부터 깨끗한 코드 격리하기
- '깨끗한'(잘 작성된, 테스트와 디버깅이 잘 되어 있는) 코드와 '더러운' 코드 사이의 경계를 분명하게 해주는 것이 좋다
- 기회가 날 때마다 이러한 범위를 오래된 코드까지 넓혀 나간다.
   - 오래된 코드를 수정할 때는 수정 중인 버그나 그외 건드린 것에 대해 테스트 코드를 작성한다

버그 선별 회의

버그 대청소
- 며칠을 잡아서 팀원 전체가 버그를 처리하는 업무만 진행
- 버그 숫자를 관리 가능한 수준까지 끌어내려 나무뿐만 아니라 숲도 볼 수 있게 해준다

# 8장. 특수한 경우
__기존 릴리스 패치__
- 주기
   - 기존의 릴리즈 주기가 있다면 이 과정을 쉽게 뒤집어서는 안된다. 
   - 가끔씩 버그가 너무 심각할 경우에 어쩔수 없이 정상 일정을 깨고 기존 릴리스를 패치할 때가 있다
- 목표
   - 평상시의 목표는 근본 원인을 고치는 것이다
   - 릴리스패치는 리스크를 최소화 하는게 제일 우선이다. 근본 원인을 고치기 보다는 증상만 막아주는 궁여지책이 더 좋을수도 있다.<br>
   급하게 원인을 잡으려고 하다가 더 큰 버그를 만들 수 있기 때문이다.
- 현재 릴리스를 패치하는 것 뿐 아니라, 개발 버전에 있는 버그도 같이 고쳐줘야 한다.

하위 호환성
- 사용자가 버그가 있는 버전을 꽤 오랬동안 사용해 왔다면 어떤 식으로든 잘못된 방식에 의지하고 있을지도 모른다는 점이다.<br>
이런 버그를 고쳤을 때 어떻게 될지 생각하지 않고 수정하면 오히려 사용자들의 불만을 살지도 모른다.
- 수정하려는 부분이 호환성에 어떤 영향을 미칠지 알고 수정을 해야 한다
- 호환성 해결 방법
   - 마이그레이션 방법 제공
   - 호환성 모드 구현
      - 예: 워드에서 예전 확장 파일을 열면 호환성 모드로 동작
      - 하지만 비용이 많이 든다
   - 사전에 경고
   - 버그를 고치지 않는다

병렬 버그
- 병렬 소프트웨어 버그는 종종 비결정적이고, 미묘한 부분(예: 타이밍)에 의존하기 때문에 디버깅이 어렵다
- 가능하면 코드에 `sleep` 등의 타이밍을 이용해서 제어하는 부분을 넣지 않는다

하이젠버그
- 정의: 현장에서는 안정적으로 재현되다가도 찾아보려고 하면 재현이 되지 않아서 진단이 어려운 버그
- 검토해볼 수 있는 문제
   - 소프트웨어의 작동을 검사하는데 쓰는 기법이 동작에 영향을 줄 수도 있다. (예: 진단 코드, 로그 등)
   - _디버그 모드와 릴리즈 모드에서 메모리 관리가 달라질 수 있다_
- 로깅은 타이밍이 달라지게 만드는 주요 요인이다
   - 예를 들어서 `System.out.println()`을 호출하면 수천클록의 사이클이 필요하고, 컨텍스트 스위칭이 한번은 생길 가능성이 있다
   - 비 결정성이 생길 수 있는지를 알고 있다면 그 부분에 영향을 주는 것을 피해보자

성능 버그
- 병목 찾기
   - 성능 문제의 근본 원인은 90%가 전체 성능을 제어하는 일부 코드, 즉 병목에 있다
   - __프로파일러를 이용해서 검사를 해보자__
- 정확한 프로파일링
   - 가능한 실제 제품과 비슷하게 빌드해 프로파일링한다
   - 실행환경을 비슷하게 만든다
   - 전형적인 데이터로 소프트웨어를 실행한다. (적은 양의 테스트 데이터를 이용하지 않는다)

서드파티 소프트웨어
- 서드파티 소프트웨어를 의심하기 보다는 우리 코드를 먼저 의심하자
   - 서드파티 소프트웨어는 많이 사용되고 있고, 테스트가 잘 돼 있어서 명백한 버그는 이미 발견되었을 가능성이 높다
- 실제로 문제가 있으면 일단 우리 소프트웨어에서는 이 문제를 우회할 수 있는 방법을 찾고, 서드파트 업체에 문제를 알려서 공식 릴리스에 포함되도록 하는게 제일 좋은 방법이다. 


# 11장. 안티패턴

우선순위 인플레이션
- 문제점
   - 모든 버그의 우선순위가 최우선인 예시
- 개선책
   - 주기적으로 버그를 제거하자
   - 버그의 우선순위를 사람들이 정할 수 없게 하자. 별도의 엄격한 과정을 통해서 결정

프리마돈나
- 문제점
   - 겉으로보기에는 일을 빠르게 하고 잘하는 것처럼 보이지만 실제로는 일을 반만한다
   - 모든 것에 문제가 생기고, 팀원들은 이 문제를 치우느라 바쁘다
- 개선책
   - 확하게 끝나야 끝나는 것임을 분명하게 한다
   - '오염자 부담 원칙' 을 도입한다 (= 버그를 만든 사람이 수정해야 한다)

유지보수팀
- 문제점
   - 개발한 프로그램이 잘 돌아가는지 확인하는 방법은 실제로 운영을 해보면서 알아보는 것인데, 여기서 나오는 문제는 원래 설계했던 사람이 수정하는 것이 훨씬 좋다
   - 개발자가 자신이 개발한 코드에 문제가 있다는 것을 배울 방법이 없다
   - 프로젝트 계획상에는 개발 단계와 유지보수 단게를 나누지만 실제로는 이렇게 구분되는 경우가 잘 없다.<br>
   사용자도 한 이유인데, 실제로 프로그램을 사용해봐야 무엇이 문제인지를 아는 경우가 많다
   - 유지보수팀은 2등인 경우가 많다. 실력이 좋은 개발자일수록 개발 팀으로 가려고 한다
- 개선책
   - 한 팀에서 한 제품을 처음부터 배포와 다음 과정까지의 전 과정을 맡게 한다

화재 진압
- 상황
   - 심각한 문제가 쌓여서 불길이 다른 곳으로 번지는 것을 막기 위해 하나하나 재발리 끄는 상황
- 개선책
   - 1주일간 진행했는데도 해결이 안된다면 일을 멈추고 근본 원인을 찾아야 한다
   - 어쩌면 내키지 않는 결정을 내려야 할지도 모르는데, 장기적으로 튼튼한 기반을 마련하기 위해 단기적인 고통을 감내해야 할 수도 있다

새로 작성하기
- 상황
   - 지저분하게 작성된 코드를 보면 기존 코드를 버리고 새로 작성하고 싶을 수 있다
   - 정말 이 방법이 맞을 수도 있지만, 개발자들은 이런 결론을 너무 금방 내리는 경향이 있다
   - 제대로 실행되는 코드를 다시 만드는 것은 기존에 코드에 녹여져 있는 로직을 놓칠 수 있다

흑마술
- '무슨이유인지 모르겠지만 그 서버에서 빌드한 바이너리는 항상 그 버그가 발생하더라구요'
- 모두 이해 못하는 것은 버그로 취급하자. 