## 도입
- 개발자는 도메인보다 데이터에 초점을 맞추려는 경향이 있다
- 풍부한 행동을 바탕으로 도메인 개념을 설계하진 않고, 주로 데이터의 속성과 연결을 먼저 생각하려 한다. 

## 엔터티를 사용하는 이유
- 우리가 도메인 개념의 개별성에 신경을 쓸 때(한 개념을 시스템내의 나머지 모든 객체와 반드시 구분해야 하는 조건이 있을 때) 이를 엔터티로 설계한다
- 고유 식별자와 변화 가능성(mutability)이라는 특징이 엔터티와 값 객체 사이의 차이점이다
- CRUD시스템에선 데이터의 포착만으론 정교한 비즈니스 시스템을 생성할 수 없다

## 고유 식별자
- 엔터티의 설계 초기엔 고유 식별자의 중심을 우리는 우선적인 내용과 이를 쿼리하는데 도움을 주는 요소에 집중하고, 이를 마무리하기 전까진 다른 특성이나 행동을 의도적으로 무시한다
- 시간이 흘러도 고유성(uniquness)의 보존됨을 보장해줄 수 있도록, 식별자를 구현하는 다양한 옵션의 확보는 아주 중요하다
   - 예를 들어 애플리케이션에서 사용자가 사용할 수 있는 사람의 이름을 검색할 때, 사람의 이름이 Person 엔터티의 고유 식별자로 쓰일 가능성은 없다. 이름은 고유하지 않기 때문이다

식별자 생성 전략 1 - 사용자가 식별자를 제공한다
- 간단하지만, 양질의 식별자를 새엇ㅇ하는 일을 사용자에게 의지한다는 문제점이 있다
- 사용자 입력 값은 언제든 매칭에 사용할 엔터티의 속성으로 고려해도 되지만, 이를 고유 식별자로 사용해선 안 된다

식별자 생성 전략 2 - 애플리케이션이 식별자를 생성한다
- UUID나 GUID를 이용한 생성접근법 (36바이트)
- 상대적으로 생성이 빠른 식별자이고, 영속성 메커니즘과 같은 외부와의 상호 교류가 필요하지 않다
- 우리의 식별자 생성기는 하나 의상의 특정 UUID 세그먼트를 사용할 수 있다
   - 'APM-P-08-14-2012-F36AB21C' : 2012년 8월 14일에생성된 애자일 프로젝트 관리(APM) 컨텍스트의 Product(p)를 나타낸다
   - 이런 종류의 식별자를 String으로 유지 관리하는 일이 좋은 선택이 아닐 수 있다. 사용자 지정 식별자 값 객체가 더 잘 맞다

식별자 생성 전략 3 - 영속성 매커니즘이 식별자를 생성한다
- DB를 이용한 시퀀스나 증가 값을 호출한 결과는 언제나 고유하다
- 값을 얻기 위해서 DB까지 다녀와야 하기 때문에 성능이 단점이 될 수도 있다
- 엔터티의 생성과 할당이 일어나는 시점이 중요하다
   - 빠른 식별자 생성과 할당은 엔터티가 저장되기 전에 일어난다
   - 늦은 식별자 생성과 할당은 엔터티가 저장될 때 일어난다

식별자 생성 전략 4 - 또 하나의 바운디드 컨텍스트가 식별자를 할당한다
- 또 다른 컨텍스트가 식별자를 할당할 땐 각 식별자의 검색과 매칭과 할당을 위한 통합이 필요하다
- 동기화 영향
   - 외부의 참조된 객체의 상태가 변하면서 로컬 엔터티에 양향을 미치면 어떻게 될까? 
   - 이벤트 주도 아키텍처를 도메인이벤트와 함께 사용해서 해결할 수 있다. 로컬 바운디드 컨텍스트는 외부 시스템이 게시한 도메인 이벤트를 구독한다
   - 경우에 따라서는 로컬 바운디드 컨텍스트가 변경내용을 푸쉬하며 동기화 할 수도 있다

식별자의 생성 시점이 문제가 될 때 
- 지연 생성의 문제
   - 둘 이상의 새로운 엔터티를 추가해야 하는데, 식별자가 아직 할당되지 않았다면, 해당 식별자와 다른 새로운 엔터티의 색별자가 같아질 수 있다
- 해결 방법 
   1. 식별자를 초기에 가져와서 할당
   2. 'equals' 메서드를 리팩토링해서 도메인 식별자가 아닌 다른 속성과 비교하도록 한다

대리 식별자
- 하이버네이트 같은 일부 ORM도구는 자신만의 고유한 객체 식별자를 처리하길 원한다
- 도메인에서 다른 식별자가 필요하다면 충돌이 발생할 수 있고, 이를 해소하기 위해서는 두 개의 식별자를 사용해야 한다
   1. 도메인 모델에 맞는 식별자
   2. 하이버네이트를 위한 식별자로, 대리 식별자라고 부른다
- 생성하는 법
   1. 대리 식별자의 타입을 답고 있는 특성을 하나 만든다
   2. DB의 엔티티 테이블에 열을 하나 생성하고, 기본 키 제약 조건을 추가한다
   3. 하이버네이트 맵핑 정의에 'id' 요소를 추가한다
   - 외부 세계에서는 대리 속성을 감추는 편이 바람직하다. (= 도메인 모델의 일부가 아니기 때문에 가시성은 영속성의 누수를 의미한다)
- 도메인 식별자가 DB의 기본 키 역할을 수행해야 할 필요는 없다

식별자 안정성
- 대부분의 경우 고유 식별자는 수정하지 못하도록 보호되고, 할당된 엔터티의 수명주기에 걸쳐 안정적으로 유지돼야 한다
- 보호 방법
   1. 식별자 Setter를 클라이언트로부터 숨기는 방법
   2. (이미 Settter가 존재한다면) 식별자의 상태 변화로부터 엔터티 자체를 보호하기 위해 세터 내에 가드를 만드는 방식
      - Setter내에 값의 변화를 만족시키지 못할 경우 에러를 발생하는 방법

## 엔터티의 발견과 그들의 내부적인 특성
엔터티의 발견
- 단순히 클래스에 이름을 붙여줄 명사와 중요한 오퍼레이션의 이름으로 쓰일 동사의 집합만을 객체에서 뽑아낸다 생각하면 실수이다
- 원하는 만큼 얼마든지 토론하면서 명세를 검토하는 투자는 상당한 생각, 노력, 동의, 합의가 녹아든 언어를 개발하는 데 도움이 된다
- 특별한 도메인 시나리오가 팀의 토론본다도 더 오래 유지돼애 한다는 점이 중요하다면, 이를 가벼운 문서에 담도록 하자

### User와 Tenent에 대한 사스오베이션 예시 (정리를 하기개 좀 애매한 부분이라 필요한 부분만 메모)
엔터티와 속성 알아내기
   - 요구 사항을 완전히 정리하고 다른 항목을 추가하고 더 분명하게 다듬는 일은, 실제로 일어나는 일이 무엇인지 훨씬 더 정확하게 정의해준다
필수 행동 파해치기
- 퍼블릭 세터는 오직 언어가 사용할 허용할 때나 하나의 요청을 완수하기 위해 여러 세터를 사용할 필요가 없을 때만 사용한다. 다수의 세터는 의도를 모호하게 만든다
   - `setActive`를 `activate`와 `deactivate`로 변경
- 인증에는 단순히 username과 password에 매칭되는 User를 찾는 이상이 필요하기 때문에, 더 높은 수준의 조정자가 필요하다. 이런 상황에선 도메인 서비스가 좋다. 
- Person은 User에 너무 큰 책임을 부여하는 상황을 피하기 위해서 별도의 클래스로 모델링했다

### 역할과 책임
- 모델링의 한 측면은 객체의 역할과 책임을 발견하는 것이다

여러 역할을 수행하는 도메인 객체
- 이런 방법을 택하는 이유는 보통은 둘 이상의 객체 사이에서 유사점과 차이점을 함께 발견하기 때문이다.
- 만약 두 인터페이스가 복잡하다면, 두 가지를 한 객체에 구현하는 일은 어려울 수 있다
   ```java
   // 이 예제는 더 복잡하기만 하다
   public interface User { }
   public interface Person { } 
   public class HumanUser implements User, Person { }
   ```
- 객체 정신 분열증
   - 위임된 객체가 위임받기 전 본래의 객체 식별자를 모르는 상황을 나타낸다
   - 위임을 받은 내부에선 실제 자신이 누구인지 혼란을 겪는다
   - 위임은 복잡하게 만들지 않으며 단순하게 만들때에만 좋은 설계다
- 좀더 작은 단위로 역할 인터페이스를 만들면 도움이 될 수 있다
   - 책의 Customer 예시
      ```C#
      public interface IAddOrdersToCustomer  { AddOrder(Order order)  }
      public interface IMakeCustomerPreferred  { MakePreferred() }
      public class Customer : IAddOrdersToCustomer, IMakeCustomerPreferred { }
      ```
   - 엔터티의 역할은 유스케이스만다 바뀔 수 있다. 클라이언트가 새로운 Order 인스턴스를 Customer에 추가할 필요가 있다면, 선호 Customer를 만들 때와 그 역할이 달라진다. 
   - 단위가 작은 인터페이스는 Customer 등의 구현한 클래스 자체에 행동을 구현하기가 좀 더 쉽도록 해준다. 구현을 별도의 클래스로 위임할 필요가 없으며, 그렇기 때문에 객체 정신 분열증을 막아준다
   - Interface의 기능을 분리가 아니라 Customer에 구현을 한다면? 
      ```c#
      public class Customer 
      { 
         AddOrder(Order order);
         MakePreferred();
      }
      ``` 
      - 인터페이스를 사용하면 우리는 클라이언트에게 흘리고 싶지 않은 모델의 구현 세부 사항을 숨길 수 있다
      - 클라이언트의 사용을 허가할 대상만 노출되도록 정확히 설계하고, 그 이상은 노출시키지 말자

### 생성
생성자
- 새로운 엔터티를 인스턴스화 할 때, 이를 완전히 식별해 클라이언트가 찾을 수 있도록 충분한 상태 정보를 포착하는 생성자를 사용하길 바란다
- 빠른 식별자 생성을 사용한다면, 올바르게 설계된 생성자는 최소한 고유 식별자를 매개변수로 갖는다
- 만약 엔터티가 이름이나 설명과 같은 다른 수단으로 쿼리된다면, 그 모든 사항도 생성자의 매개변수로 포함시킨다

변수의 자가 캡슐화
- 생성자에서 인스턴스 변수 할당을 내부 세터로 위임하는 것
- 각 세터가 엔터티를 대신해 개별적으로 제약을 검사한다. (=가드)

복잡한 엔터티 인스턴스화를 위해서는 팩토리를 사용하자

### 유효성 검사
목적
- 모델 내의 유효성 검사를 사용하는 주 이유는 하나의 특성/속성, 전체 객체, 객체의 컴포지션 등의 정확성을 확인하기 위해서다
- 예를 들어서 도메인 객체의 모든 속성이 개별적으로 유효하다고 객체 전체가 하나의 대상으로서 유효하다는 의미는 아니다. 따라서 하나 이상의 단계로 이뤄진 유효성 검사를 통해 가능한 모든 문제를 다뤄야 한다. 

특성/속성 유효성 검사
- 자가 캡슐화의 사용으로 해결할 수 있다
   - '자가 캡슐화는 심지어 같은 클래스 내에서부터 모든 데이터로의 액세스가 접근자 메소드를 거쳐가도록 설계하는 방법이다' (by 마틴 파울러)
   - 이점
      - 객체의 인스턴스 변수를 추상화 할 수 있도록 해준다
      - 유효성 검사의 단순한 형태를 지원한다
- 전체 값을 엔터티 특성으로 할당할 때 해당 값의 작은 특성을 가드하지 않는다면, 정신 나간 값이 설정되는 상황을 가드할 방법이 없다.
- 방어적 프로그래밍
   - 일부 개발자들은 이러한 전제 조건 확인을 방어적 프로그래밍으로 보기도 한다
   - 그들이 보기에 문자열의 길이나 숫자의 범위까지 확인하는 것은 모델 객체에 관련되지 않은 부분이라 생각하고 DB에 맡기는게 최선이라고 생각할 수도 있다.<br>
   그런데 이는 DB에 따라 다를 수 있기 때문에 세터의 전제조건에서 텍스트 길이를 확인하는 방법은 이런 문제를 전반적으로 피할 수 있게 해주는 최선책일 수 있다

전체 객체의 유효성 검사
- 완전히 유효한 속성 엔터티를 가졌다고 하더라도, 이게 전체 엔터티가 유효하다는 의미는 아니다.<br>
전체 엔터티의 유효성 검사를 위해서는 전체 객체의 상태로의 엑세스가 필요하고, 유효성 검사를 위한 명세나 전략이 필요하다
- 여기서 유용한 방법은 지연 유효성 검사(Deferred Validation)다
   - 마지막으로 가능한 순간까지 확인을 지연시켜야 하는 클래스 by 와드
- 유효성 검사 컴포넌트는 엔터티 상태가 유효한지 결정하는 책임을 갖는다
   - 유효하지 않은 상태를 감지하면 클라이언트에게 알리거나 결과를 기록으로 남겨 확인할 수 있도록 한다
   - 첫번째 문제가 발생했을 때 예외를 던지는 것보단, 전체 겨로가를 수집하는 편이 중요하다

객체 컴포지션의 유효성 검사
- 유효성 검사의 적당한 조건이 준비되면, 모델은 도메인 이벤트를 게시해서 이를 클라이언트에게 알려줄 수 있다
- 클라이언트는 이 이벤트를 수신해서 유효성 검사 시점을 알 수 있다

## 변화 추적
- 엔터티의 정의에 따라 모든 변경사항을 추적할 필요는 없지만, 도메인 전문가는 시간이 지남에 따라 모델에서 일어나는 중요한 사건에 신경을 쓴다. 이때 변경 사항의 추적이 도움이 된다
- 정확하고 유용하면서 가장 실용적인 변경 추적은 도메인 이벤트와 이벤트 저장소를 통해 이뤄진다
   - 도에인 전문가가 신경 쓰고 있는 모든 애그리게잇에 관해 해당 애그리게잇이 실행되며 상태를 바꾸는 모든 중요한 커맨드마다 고유한 이벤트 타입을 생성한다
   - 고덕자는 모델에서 만들어지는 모든 이벤트를 수신하고, 이벤트 저장소에 저장한다
   - 이벤트 소싱 패턴