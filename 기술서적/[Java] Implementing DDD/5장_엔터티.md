## 도입
- 개발자는 도메인보다 데이터에 초점을 맞추려는 경향이 있다
- 풍부한 행동을 바탕으로 도메인 개념을 설계하진 않고, 주로 데이터의 속성과 연결을 먼저 생각하려 한다. 

## 엔터티를 사용하는 이유
- 우리가 도메인 개념의 개별성에 신경을 쓸 때(한 개념을 시스템내의 나머지 모든 객체와 반드시 구분해야 하는 조건이 있을 때) 이를 엔터티로 설계한다
- 고유 식별자와 변화 가능성(mutability)이라는 특징이 엔터티와 값 객체 사이의 차이점이다
- CRUD시스템에선 데이터의 포착만으론 정교한 비즈니스 시스템을 생성할 수 없다

## 고유 식별자
- 엔터티의 설계 초기엔 고유 식별자의 중심을 우리는 우선적인 내용과 이를 쿼리하는데 도움을 주는 요소에 집중하고, 이를 마무리하기 전까진 다른 특성이나 행동을 의도적으로 무시한다
- 시간이 흘러도 고유성(uniquness)의 보존됨을 보장해줄 수 있도록, 식별자를 구현하는 다양한 옵션의 확보는 아주 중요하다
   - 예를 들어 애플리케이션에서 사용자가 사용할 수 있는 사람의 이름을 검색할 때, 사람의 이름이 Person 엔터티의 고유 식별자로 쓰일 가능성은 없다. 이름은 고유하지 않기 때문이다

식별자 생성 전략 1 - 사용자가 식별자를 제공한다
- 간단하지만, 양질의 식별자를 새엇ㅇ하는 일을 사용자에게 의지한다는 문제점이 있다
- 사용자 입력 값은 언제든 매칭에 사용할 엔터티의 속성으로 고려해도 되지만, 이를 고유 식별자로 사용해선 안 된다

식별자 생성 전략 2 - 애플리케이션이 식별자를 생성한다
- UUID나 GUID를 이용한 생성접근법 (36바이트)
- 상대적으로 생성이 빠른 식별자이고, 영속성 메커니즘과 같은 외부와의 상호 교류가 필요하지 않다
- 우리의 식별자 생성기는 하나 의상의 특정 UUID 세그먼트를 사용할 수 있다
   - 'APM-P-08-14-2012-F36AB21C' : 2012년 8월 14일에생성된 애자일 프로젝트 관리(APM) 컨텍스트의 Product(p)를 나타낸다
   - 이런 종류의 식별자를 String으로 유지 관리하는 일이 좋은 선택이 아닐 수 있다. 사용자 지정 식별자 값 객체가 더 잘 맞다

식별자 생성 전략 3 - 영속성 매커니즘이 식별자를 생성한다
- DB를 이용한 시퀀스나 증가 값을 호출한 결과는 언제나 고유하다
- 값을 얻기 위해서 DB까지 다녀와야 하기 때문에 성능이 단점이 될 수도 있다
- 엔터티의 생성과 할당이 일어나는 시점이 중요하다
   - 빠른 식별자 생성과 할당은 엔터티가 저장되기 전에 일어난다
   - 늦은 식별자 생성과 할당은 엔터티가 저장될 때 일어난다

식별자 생성 전략 4 - 또 하나의 바운디드 컨텍스트가 식별자를 할당한다
- 또 다른 컨텍스트가 식별자를 할당할 땐 각 식별자의 검색과 매칭과 할당을 위한 통합이 필요하다
- 동기화 영향
   - 외부의 참조된 객체의 상태가 변하면서 로컬 엔터티에 양향을 미치면 어떻게 될까? 
   - 이벤트 주도 아키텍처를 도메인이벤트와 함께 사용해서 해결할 수 있다. 로컬 바운디드 컨텍스트는 외부 시스템이 게시한 도메인 이벤트를 구독한다
   - 경우에 따라서는 로컬 바운디드 컨텍스트가 변경내용을 푸쉬하며 동기화 할 수도 있다

식별자의 생성 시점이 문제가 될 때 
- 지연 생성의 문제
   - 둘 이상의 새로운 엔터티를 추가해야 하는데, 식별자가 아직 할당되지 않았다면, 해당 식별자와 다른 새로운 엔터티의 색별자가 같아질 수 있다
- 해결 방법 
   1. 식별자를 초기에 가져와서 할당
   2. 'equals' 메서드를 리팩토링해서 도메인 식별자가 아닌 다른 속성과 비교하도록 한다

대리 식별자

