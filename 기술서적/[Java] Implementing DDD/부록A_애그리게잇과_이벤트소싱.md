이벤트 소싱 기본
- 수십년간 사용돼온 개념이지만, 최근에 그렉 영(Greg Young)이 DDD에 이를 적용함을써 널리 알려지게 됐다
- 이벤트 소싱은 애그리게잇을 생성한 이후 발생한 일련의 이벤트를 통해 애그리게잇의 상태를 나타내는 데 사용할 수 있다.<br>
이벤트가 발생한 순서대로 해당 이벤트를 다시 재생한다면, 이벤트를 통해 애그리게잇의 상태를 재구축 할 수 있다. 
- 애그리게잇의 이벤트 스트림은 이벤트 저장소로 저장된다

A+ES의 주요 이점
- 애그리게잇 인스턴스에 발생하는 각 변경의 발생 원인이 유실되지 않음을 보장한다
- 이벤트 스트림에는 덧붙이기만이 허용되기 때문에 성능이 매우 좋고 다양한 데이터 복제 옵션의 지원이 가능해진다
- 이벤트를 중심으로 애그리게잇을 설계함으로써 유비쿼터스 언어로 표현되는 행동에 더욱 집중할 수 있다

A+ES의 현실적 단점
- 비지니스 도메인에 대한 깊은 이해가 필요하다
- 이 글이 작성되는 시점에서 이 분야는 아직 도구 지원이나 일관된 지식 체계가 부족하다
- 이벤트 스트림은 질의하기가 어렵기 때문에, A+ES의 구현에는 대부분 어떤 형태로든 CQRS가 필요하게 된다

## 애플리케이션 서비스의 내부
애플리케이션 서비스의 내부
- ![A-2](/Images/IDDD/A-2.png)

이번트를 이용해서 애프리게잇 상태의 인스턴스화
- ![A-3](/Images/IDDD/A-3.png)

비즈니스 오퍼레이션의 수행
- 애그리게잇이 이벤트 저장소로부터 재구성되면 애플리케이션 서비스는 애그리게잇 인스턴스상의 커맨드 오퍼레이션을 수행한다
- 오퍼레이션을 수행하기 위한 계약에 따라 현재의 상태와 필수 도메인 서비스를 활용하게된다
- 행동이 실행되면, 상태에 발생한 변경은 새로운 일변의 이벤트로 표현된다
- ![A-4](/Images/IDDD/A-4.png)

변경하는 행동이 완료된 후에는 반드시 Changes 컬렉션을 이벤트 저장소로 커밋해야 한다
- 즉시 쓰기(write-through)
   - 추가된 이벤트가 마스터 이벤트 저장소로 들어오면, 모든 이벤트를 복제본 이벤트 저장소에 추가한다
   - 추가가 완료되면 Append() 호출을 완료한다
- 뒤에 쓰기)write-behind)
   - 추가된 이벤트가 마스터 이벤트 저장소로 들어오면, Append() 호출을 완료한다
   - 그 이후에 이벤트를 복제본에 추가한다

## 커맨드 핸들러
커맨드 계약의 장점
- 커맨드 객체는 직렬화 할 수 있기 때문에 해당하는 텍스트나 바이너리 표현을 메시지 큐를 통해 메시지로 보낼 수 있다
- 클라이언트와 서비스 사이의 결합을 분리하면 로드 밸런싱을 개선하고 경쟁적 컨슈머를 사용하고 시스템 파티셔닝을 지원할 수 있다
- 작업 로드 밸런싱도 가능하다
- 이런 접근은 클라이언트와 애플리케이션 서비스 사이에 시간 분리를 가능케 하는데, 이는 시스템을 더욱 견고하게 해준다
- ![A-5](/Images/IDDD/A-5.png)

## 람다 구문
언어가 람다 표현을 지원한다면 반복되는 이벤트 스트림 관리로 인한 코드 반복을 피할 수 있다

## 동시성 제어
동시성 충돌
- 애그리게잇 이벤트 스트림은 여러 스레드가 동시에 접근하고 읽을 수 있기 땜누에 제대로 확인하지 않았을 때 동시성 충돌 문제가 발생할 수 있다
- 그 결과로는 잘못된 애그리게잇 상태가 유발될 수 있다

해결법
- 가장 간단한 해결법은 이벤트를 추가하려고 할 때 (동시성 문제로) 실패한다면, 최종 클라이언트까지 Exception을 전달하는 방법이다
   - 최종 클라이언트에서 이 예외를 잡게 된다면, 사용자는 아마도 수동으로 오퍼레이션을 재시도하도록 지시하게 된다
- 다른 방법으로 이벤트 저장소가 충돌 Exception을 던지면 즉시 복구하는 방법을 시도해볼 수도 있다

## A+ES의 구조적 자유
A+ES의 실질적 이점
- 영속성의 간결함과 다양한 유용성
- 애그리게잇 구조가 얼마나 복잡하든, 애그리게잇은 언제나 직렬화된 이벤트의 연속을 통해 표현할 수 있다
- 특별된 식별자는 갖고 있는 일련의 이벤트를 보통 이벤트 스트림이라 하는데, 이벤트 스트림은 일관성이 보장되기만 한다면 관계형 데이터베이스. NoSQL, 파일 시스템 등 어디든 저장할 수 있다

## 성능
배경
- 때론 거대한 스트림으로부터 애그리게잇을 가져오면서 성능 문제를 겪을 수 있다

해결법
- 이벤트가 일단 이벤트 저장소에 쓰여진 이후엔 변경되지 않는다는 사실을 활용해 이벤트 스트림을 서버 메모리에 캐싱한다
- 스냅샷을 만들어서 이벤트 스트림을 다시 재생허라 때 상당 부분을 제외시킨다
   - 스냅샷에는 버전이 함께 기록되어서 기록한 시점 이후에의 발행 이벤트를 가져올 수 있게 한다

## 관계형으로 저장하기
관계형 데이터베이스가 제공하는 여러 기능과 강력한 일관성 보장은 추가하기만이 허용되는 영속성을 구현하는 가장 간단한 방법이다

트랜잭션 안에서 이벤트를 특정 스트림에 추가하는 방법
1. 트랜잭션을 시작한다
2. 이벤트 저장소에 변경이 발생해 예상했던 버전과 맞지 않는다면 예외를 던진다
3. 동시성 충돌이 발생하지 않는다면 이벤트를 추가한다
4. 트랜잭션을 커밋한다

## 집중된 애그리게잇
애그리게잇을 전통적인 영속성에 따라 개발하게 되면 시스템에 새로운 엔터티를 도입할 때의 개발 부담이 커지거나 기존 시스템을 강화하는 과정이 어려워질 수 있다

이벤트 소싱을 사용하면 새로운 애그리게잇을 더 쉽게 설계할 수 있다
- (저자의 경험상) 이렇게 설계된 애그리게잇은 크기가 더 작은 편이며, 이는 중요한 애그리게잇 경험 법칙 중 하나다
- 물론 애그리게잇은 임의로 작게 설계해선 안된다

애그리게잇을 만드는 방법
- 모데인 모델링을 시작할 때 들어올 커맨드와 나갈 이벤트를 먼저 정의하고, 그에 따라 수행되는 행동을 정의함으로써 유비쿼터스 언어의 중심을 만드는편이 도움이 된다
- 그 이후에 유사성과 관련성과 비즈니스 규칙을 기준으로 일부 개념을 묶어서 애그리게잇을 만들면 된다

## 읽기 모델 투영
읽기 모델 투영
- A+ES 설계를 선택했을 때 애그리게잇 속성을 사용해 쿼리하는 방법에 대해서 고민을 겪게 되는데 읽기 모델 투영을 통해서 도움을 받을 수 있다
- 읽기 모델 투영은 읽기 모델을 생성하고 갱신하기 위해 사용되는 단순한 도메인 이벤트 구독자의 집합이다
- 갱신이 발생할 때마다 저장되며, 바운디드 컨텍스트 안팎의 여러 리더가 접근할 수 있다
- 큰 장점 중 하나는 언제든 완전히 버릴 수 있다는 점이다.<br>
투영은 애플리케이션의 수명 중 언제든 추가되거나 수정되거나 완전히 대체될 수 있다

## 애그리게잇 설계와 함께 사용하기
읽기 모델은 클라이언트로 정보를 노출시키기 위해 자주 사용되지만, 바운디드 컨텍스트와 그에 속한 애그리게잇 사이에 정보를 공유할 때도 상당히 유용하다
- Invoice와 Customer Information 예시
- 느슨한 결합과 유지 보수가 더 쉬운 방향으로 애그리게잇 인스턴스들 사이에 정보를 공유할 수 있도록 해준다

## 이벤트 강화
이벤트의 사용
- 애그리게잇의 저장을 위해서 사용
- 이벤트 발생 -> 엔터프라이즈의 도메인 수준에서 일어나는 사건을 알리기 위한 용도로 사용

## 지원 도구와 패턴
A+ES를 사용해 시스템을 개발/빌드/배포/유지관리 하기 위한 패턴
- 이벤트 직렬화
   - 이벤트의 버전 관리와 이름 변경이 쉬운 직렬화기를 선택하는 펺이 현명하다
- 이벤트 불변성
- 값 객체
   - 값 객체를 사용하면 응집도 높은 원시 타입을 묶어서 명시적으로 이름이 부여된 불변 타입으로 만들 수 있다
   - 정적 타입 검사와 IDE 지원 같은 이점이 추가된다
   - 커맨드 객체나 이벤트나 애그리게잇의 파트에선 가능성이 있다면 반드시 값 객쳉의 이점을 위한 노력을 기울여야 한다

## 계약생성
많은 수의 이벤트 계약을 수동으로 관리하는 것이 아니라, DSL(도메인 특화 언어, Domain-Specific Language)로 표현하는 것이 더 효율적이다

이점
- 도메인 모델링 이터레이션을 가속시켜서 개발 마찰을 줄여준다
- 수동 작업에서 흔하게 발생하는 사람의 오류를 줄여준다
- 간결한 표현에 따라 한 화면 안에서 전체 이번트 정의를 볼 수 있어, 직관력을 높일 수 있는 큰 그림을 제공해준다
- 소스나 바이너리 코그가 없어도 간결한 정의로서의 이벤트 계약에 버전을 부여해 배포할 수 있다

## 단위테스트와 명세
이벤트 소싱을 사용하면 단위 테스트를 더 손쉽게 Given/When/Then 형태로 명세할 수 있다
- Given/When/Then 형태
   - Given: 과거에 발생한 이벤트에 대해
   - When: 애그리게잇 메소드가 호출되는 상황에선
   - Then: 이벤트가 이어지거나 예외가 발생해야 한다
- 이런 접근은 우리가 각 에그리게잇에 엮여 있는 행동을 찾아내서 검증할 수 있도록 해준다
- When 조건을 커맨드로 표현해 테스트하는 애그리게잇의 애플리케이션 서비스로 전달함으로써 한 걸음 더 나아갈 수 있다

## 함수형 언어에서의 이벤트 소싱
함수형 언어를 사용하게 된다면 최적의 상태로 동작하는 보다 간결한 코드가 작성될 여지가 커진다


