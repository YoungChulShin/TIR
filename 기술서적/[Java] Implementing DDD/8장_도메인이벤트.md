## 언제 그리고 왜 도메인 이벤트를 사용할까
도메인 이벤트
- 도메인 이벤트는 도메인 모델을 완벽히 지원하며 도메인에서 일어난 어떤 사건을 나타낸다. 
- 어떤 일이 중요한지에 대해서는 도메인 전문가와 논의를 통해서 그들이 알려주는 단서에 귀 기울여야 한다.

도메인 이벤트 사용
- 이벤트가 로컬 시스템이든 외부 시스템이든 관심을 있는 대상으로 전달됐을 땐 보통 겨로가적 일관성을 위해 사용된다
![8-1](/Images/IDDD/8-1.jpg)
- 모델의 기술적 구현 측면이나 협업 시스템의 목표에 따라 도메인 전문가가 요구하는 수보다 이벤트가 더 많을 수 있다. 이런 상황에서 이벤트 소싱을 사용한다

## 이벤트의 모델링
모델링 규칙
- 해당 이벤트가 속한 바운디드 컨텍스트의 유비쿼터스 언어에 따라 이벤트와 그 속성을 명명하자
- 이름이 간단할수록 읽기 좋다. 그렇지만 당신의 팀이 좀 더 구체적인 이름을 선호한다면 그렇게 사용해도 좋다. 
   - BackLogItemCommitted와 BackLogItemCommittedToSprint
- 애그리게잇으로부터 이벤트를 발행할 땐 이벤트의 이름에 발생의 과거 시점을 반영하는 것이 중요하다
- 일어난 일의 의미를 나타내기 위해 필요한 다른 속성이 무엇인지 결정한다
- 구독자가 이베늩의 원인 이외의 상황까지 나타내주길 요청한다면, 추가적인 상태와 행동의 제공이 필요할 수 있다

애그리게잇의 특성과 함께하기
- 때론 클라이언트가 직접 요청한 내용을 바탕으로 이베늩가 생성되도록 설계하기도 한다.<br>
이는 모델 내 애그리게잇 인스턴스상에 위치한 행동을 실행한 직접적인 결과가 아닌 다른 일부 사건에 따른 응답으로써 이뤄진다.<br>
이런 방식으로 모델링하면, 이벤트는 애그리게잇처럼 모델 구조의 일부가 된다.<br>
즉 이런 이벤트는 과거에 일어난 일부 사건의 기록일 뿐만 아니라, 더 넓은 의미를 갖게 된다.

식별자
- 이벤트를 서로 구분해야할 때가 있지만 그런 상황은 굉장히 드물다. 하지만 비교를 해야 한다면 속성으로써 이벤트 식별자를 표현해주면 된다. 
- 이벤트의 이름/타입과 함께 이벤트를 유발시키는 데 관여한 애그리게잇의 식별자와 이벤트가 발생한 타임스탬프를 통해 구해낼 수 있다. 
- 속성만으로 구분할 수 없는 상황에선 이벤트가 정형적인 고유 식별자를 할당할 수 있다.
- 이벤트가 발생한 로컬 바운디드 컨텍스트의 밖에서 이벤트가 발행되면 메시징 인프라 스트럭처가 이를 전달하기 위해 고유 식별자가 필요해진다. 
- 일부 경우 메시지가 한 번 이상 전달될 수 있는데, 이 경우 원격구독자로 하여금 중복 메시지 전달을 감지하고 수신된 메시지를 무시하도록 하면 된다. 

## 도메인 모델에서 이벤트를 발행하기
도메인 이벤트를 도메인 모델 외부의 컴포넌트와 결합하지 않고 발행하는 가장 간단하고 효과적인 방법은 경량 옵저버의 생성이다. 
- 간단하다
- 이벤트가 발행할 때 네트워크를 통과하지 않기 때문인데, 등록된 모든 구독자는 발행자와 같은 프로세스 공간의 같은 스레드에서 실행된다. 

발행자
- 도메인 이벤트를 사용하는 가장 흔한 상황은 애그리게잇이 이벤트를 생성해서 발행할 때다. 
![8-2](/Images/IDDD/8-2.png)

구독자
- 구독자 등록
   - 애플리케이션 서비스에서 이뤄지며 때론 도메인 서비스에서 구독자 등록이 이루어 진다. 
   - 핵사고날 아키텍처를 사용할 땐 애플리케이션 서비스는 도메인 모델의 직접 적인 발행자가 애그리게잇에서 이벤트 생성 행동을 실행하기 전에 구독자를 등록할 수 있는 이상적인 위치다.
   - 도메인 서비스의 경우에는 이벤트를 리스닝해야 하는 특별한 이유가 있을 수 있다
- 구독자 대상
   - 이벤트를 발송하는 애그리게잇과 같은 스레드에서 실행 중인 모든 컴포넌트가 구독자가 될 수 있다
   - 이벤트의 발행에 앞서 구독이 이뤄진다
- 구독자는 다른 애그리게잇 인스턴스를 가져와서 변경을 유발하는 커맨드 행동을 수행해선 안 된다
- 이벤트 발행의 계약은 적어도 엔터프라이즈 범위나 그보다 더 넓은 범위에 속해야 한다.

## 뉴스를 원격 바운디드 컨텍스트로 전파하기
메시징 메커니즘
- 원격 바운디드 컨텍스트로 이벤트를 알리는 방법에는 여러가지가 있지만, 어떤 형태로든 메시징이 가능해야 하고, 엔터프라이즈 메시징 메커니즘이 필요하다. 
- 많은 메시징 컴포넌트가 있고 이는 '발행-구독' 범위에 속한다. 장단점이 있기 때문에 상황에 맞게 선택해야 한다. 
- 바운디드 컨텍스트 사이에서 사용하는 모든 메시지 메커니즘을 사용하기 위해선 결과적 일관성을 달성하려는 의지가 필요하다. 이는 포기할 수 없는 부분이다. 

메시징 인프라의 일관성
- 메시징 솔루션은 적어도 두가지 메커니즘은 항상 서로 일관성을 유지해야 한다
   1. 도메인 모델이 사용하는 영속성 저장소
   2. 모델이 발행한 이벤트를 전달하기 위해 사용하는 메시징 인프라의 영속성 저장소
   - 이는 모델 변경의 저장이 이벤트의 전달을 보장하고, 메시징을 통한 이벤트의 전달이 해당 이벤트를 발행한 모델에 실제 상황이 반영됐음을 보장하기 위해 필요하다

- 일관성을 달성할 수 있는 방법
   1. 도메인 모델과 메시징 인프라가 같은 영속성 저장소를 공유한다
      - 장점: 로컬 트랜잭션이므로 상대적으로 성능이 좋다
      - 단점: 메시징 시스템의 저장 공간이 반드시 모델과 같은 데이터베이스에 위치해야 한다
   2. 도메인 모델의 영속성 저장소와 메시징 영속성 저장소가 글로벌 XA 트랜잭션 하에 제어된다
      - 장점: 모델과 메시징 저장소를 서로 분리할 수 있다
      - 단점: 글로벌 트랜잭션을 위한 특별한 지원이 필요하다
   3. 도메인 모델을 저장하기 위해 사용하는 영속성 저장소에 이벤트를 위한 특별한 저장 영역을 생성한다. 이를 이벤트 저장소라고 한다. 
      - 장점
         - 모델과 이벤트가 단일 로컬 트랜잭션 안에서 일관성을 유지한다고 보장해준다
         - REST 기반 알림 피드의 생성 기능을 비롯해 이벤트 저장소의 특성을 반영한다
      - 단점: 이벤트 저장후에 미들웨어 메시징 메커니즘을 사용할 수 있는 상황에선, 메시징 메커니즘을 통해 발송하기 위해 반드시 이벤트 전달자를 직접 개발해야 하고, 클라이언트는 메시지 중복을 제거하도록 설계돼야 한다
   
자치 서비스와 시스템
- 도메인 이벤트를 사용하면 어떤 수의 엔터프라이즈 시스템이든 자치 서비스와 시스템으로 설계할 수 있다
   - 자치 서비스: 엔터프라이즈 내의 다른 '서비스'로부터 상당한 독립성을 갖고 동작하는 시스템이나 애플리케이션
- RPC는 의존성을 갖고 있는 시스템의 성공에 영향을 미친다
   - 서로 묶이는 RPC를 피하는 편이 의존성, 관계된 인스턴스의 완전한 실패, 사용할 수 없거나 너무 낮은 처리량을 가진 원격 시스템으로 인한 허용할 수 없는 수준의 성능 등과 같은 문제를 줄여준다
- 다들 시스템을 호출하는 대신 비동기적 메시징을 사용해 시스템의 독립성을 달성하자.
- 메시지를 수신하면 바운디드 컨텍스트 안의 모델에서 해당 이벤트의 의미를 반영하고 행동을 실행하자. 
   - 도메인 이벤트가 제대로 설계되면 상태의 한 부분으로 전체 객체를 운반할 일은 거의 없다
   - 이벤트가 구독자에게 충분한 정보를 전달하지 못한다면, 필요한 부분을 제공하기 위해 반드시 도메인 전반에 걸친 이벤트의 계약을 변경해야 한다

지연 시간 허용
- 상태의 일관성을 달성하기 위해 얼마나 긴 시간을 허용할지, 감당할 수 없는 한계는 어디인지를 질문해봐야 한다.
- 몇 초 가량의 전형적인 지연은 허용할 수 있을 뿐만 아니라 문제가 되지 않는다. 사실 실제 지연이 발생하더라도 인식하지 못할 수 있다. 

## 이벤트 저장소
이벤트 저장소 방식
1. 이벤트 저장소를 큐로 사용해, 메시징 인프라를 통해 모든 도메인 이벤트를 발행한다
2. 폴링 중인 클라이언트에게 REST 기반 알림을 전달하기 위해 같은 이벤트 저장소를 사용할 수 있다
3. 모델에서 실행됐던 모든 커맨드의 결과 내역은 모델뿐만 아니라 클라이언트의 버그를 추적할 때도 도움이 된다
4. 비지니스 분석에 데이터를 활용. 처음부터 이벤트 저장소를 유지 관리하지 않는다면 필요한 순간이 오더라도 과거 데이터를 사용할 수 없다. 
5. 이벤트 소싱. 저장된 이벤트의 스냅샷을 원하는 만큼 만들 수 있으며, 이를 통해 인스턴스 재구성을 최적화 할 수 있다.

![8-3](/Images/IDDD/8-3.png)

## 저장된 이벤트의 전달을 위한 아키텍처 스타일
레스풀 리소스로서 알림 발행하기
- 레스트풀 접근법
   - 장점
      - 잠재적으로 많은 수의 클라이언트가 잘 알려진 하나의 URI로 알림의 집합을 요청할 땐 레스트풀 접근법이 잘 작동한다
   - 단점
      - 하나 이상의 소비자가 특정 순서에 맞춰 수행되는 태스트 집합을 가져오기 위해 풀링해야 하는 상황에서는 고통을 수반한다
      - 이는 여러 생산자가 하나 이상의 소비자에게 알림을 전달해야 하는 상황에서 사용되는 큐를 나타내며 수신의 순서가 중요하다
      - 큐를 구현하기에 풀링 모델이 그다지 좋은 선택은 아니다. 
   - 기타 특징
      - 관심을 갖는 쪽으로 푸시할 필요가 없기 때문에 '발행자'는 '구독자'의 집합을 관리하지 않는다
      - REST 클라이언트가 잘 알려진 URI를 통해 알람을 풀링해야 한다
- 조금 더 상위 수준에서의 접근 법
   1. 클라이언트는 `HTTP GET` 메소드를 사용해서 현재 로그라 알려진 대상을 요청한다
   2. 클라이언트는 해당 바인디드 컨텍스트에서 아직 소비하지 않은 모든 이벤트를 찾아내기 위해 현재 로그 안의 이벤트를 확인한다
   3. 클라이언트는 자신의 데이터베이스로부터 가장 최근에 적용된 알림의 식별자에 관한 추적 기록을 읽어온다.
      - 적용할 알람을 추적할 책임은 클라이언트에 있다
   4. 일정 시간이 지나면 이 프로세스를 다시 반복한다
- 클라이언트 리소스 폴링이 서버에 대량의 트래픽을 발생
   - 현재 로그의 max-age  값을 타이머/슬립 임계값으로 사용할 수 있다.<br>
   슬립으로 줄어단 폴링을 통해 클라이언트 바운디드 컨텍스트와 소스 서버상의 처리 부하를 줄일 수 있다. 
   - 서버에서 캐시를 제공할 수도 있다

메시징 미들웨어를 통한 알림 발행
- 메시징 미들웨어 제품
   - 우리가 다뤄야 할 REST 스타일에 관한 세부사항을 관리해주고, 쉽게 발행-구독과 큐를 지원할 수 있도록 해준다
   - 푸쉬 모델을 사용해 등록된 구독자나 리스너로 이벤트 알림 메시지를 발생한다

- 처리 과정
   1. 이벤트 저장소에서 아직 지정된 익스체인지로는 발행되지 않은 모든 도메인 이벤트를 쿼리하고, 고유 식별자 순서에 따라 오름차순 정렬한다
   2. 객체를 순회하면서 익스체인지로 발송한다
   3. 메시징 시스템이 메시지의 발행을 알려주면, 해당 익스체인지를 통해 발행된 도메인 이벤틀 추적한다

- 구독자가 수신을 확인해주길 기다리지 않는다
   - 각 구독자가 자신만의 시간 범위에 맞춰서 메시지를 처리할 책임을 가진다
