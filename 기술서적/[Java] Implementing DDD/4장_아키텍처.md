## 도입부
DDD의 가장 큰 장점 중 하나는 특정 아키텍처의 사용을 요구하지 않는다는 점이다
- _다양한 아키텍처와 같이 사용될 수 있으면, 이 장에서 각각에 대해서 설명한다_

아키텍처 스타일과 패턴의 선택을 정당화하는 우리의 능력은 유스케이스와 사용자스토리, 심지어 특정 도메인 모델의 시나리오 등과 같은 기능적 요구사항을 사용할 수 있는지에 따라 제한된다
- 기능적 요구사항 없이는 소프트웨어 품질을 결정할 수 없다

아키텍처는 얼마나 멋진지 판단하기 위한 척도가 아니다
- 적용 가능한 가운데, 프로젝트나 시스템의 실패 리스크를 줄여주는 위치에서만 사용하자

## 계층
계층 설명
- Evans 책 설명
   - 각 계층 내에선 응집력있고 하위 계층들에만 의존하는 설계를 만들어라
- DDD가 적용된 전통적인 계층 아키텍처
   - '사용자 인터페이스 계층' -> '애플리케이션 계층' -> '도메인 계층' -> '인프라 계층'
- 아래에서 위쪽으로는 절대로 직접 참조할 수 없다

사용자 인터페이스
- 사용자의 뷰와 요구사항 문제를 다루는 코드만 포함
- 여기에서 찾을 수 있는 유효성 검사의 유형은 도메인 모델에 속해있는 유형과는 다르다

애플리케이션 서비스
- 영속성 트랜잭션과 보안을 제어할 수 있다
- 이벤트 기반의 알림을 다른 시스템으로 보내거나, 사용자에게 보낼 이메일 메시지의 작성을 담당할 수도 있다
- 도메인 로직은 전혀 없지만, 도메인 모델의 직접적인 클라이언트가 된다
- 애플리케이션 서비스가 복잡해진다면 도메인 로직이 애플리케이션 서비스로 새어나가고 있음을 나타내는 신호일 수 있으며, 모델이 무기력해 지고 있다는 뜻이다
- _UseCase와 비슷한 개념으로 보면 되지 않을까. 애플리케이션의 기능을 구현하는 계층_

인프라 계층과 도메인 계층
- 계층을 사용하면 도메인 계층에서 인프라 계층을 사용할 때 제약을 둬야 할 수 있다
- 핵심 도메인 객체가 인프라 계층을 사용하는 것은 피해야하 하는데, 계층의 정의를 따르기 위해서는 인프라가 제공하는 기술에 의존적인 도메인 계층 안에서 일부 인터페이스를 구현해야 할 수도 있다

### 의존성 역행 원리
정의
- 상위 수준의 모듈은 하위 수준의 모듈에 의존해서는 안된다. 둘 모두는 반드시 추상화에 의존해야 한다

DIP를 사용한 계층의 한가지 예시
- '인프라 계층' -> '사용자 인터페이스 계층' -> '애플리케이션 계층' -> '도메인 계층'

## 헥사고날 또는 포트와 어댑터
설명
- 다양한 이질적 클라이언트가 동등한 지위에서 시스템과 상호작용하도록 함으로써 목표를 달성
- 새로운 클라이언트가 필요하면 내부 애플리케이션의 API가 클라이언트의 입력을 이해하도록 변환해주는 어댑터만 추가하면 된다

헥사고날 아키텍처 
- ![4-2](/Images/IDDD/4-4.jpg)
- 포트를 어떤 위치로 나눴든, 클라이언트의 요청이 도착하면 그에 해당하는 각각의 어댑터가 이 입력을 변환해준다
- 애플리케이션은 퍼블리익 API를 통해 요청을 받는다
   - 애플리케이션의 경계는 유스케이스의 경계이기도 하다
   - 애플리케이션의 기능적 요구사항에 기반해 유스케이스를 생성해야지, 다양한 클라이언트가 얼마나 연결되지나 출력 매커니즘에 기반해서는 안된다
- 헥사고날의 가장 큰 장점은 테스트를 위해 어댑터를 쉽게 개발할 수 있다는 점이다
   - 클라이언트와 저장소 매커니즘이 없더라도, 전체 애플리케이션과 도메인 모델을 설계해서 테스트할 수 있따
   - HTTP/RES나 SOAP나 메시징 포트를 지원할지 결정하기 훨씬 전에, 테스트를 생성해서 ProductService를 구동해볼 수 있다
   - _클린아키텍처에서 말하는 세부사항을 정하기 전에 주용내용을 먼저 개발할 수 있다는 점이랑 동일하지 않을까_

## 서비스 지향
서비스의 설계 원리
1. 서비스 계약 (Service Contract)
   - 서비스는 그 목적과 기능을 하나 이상의 설명 문서에 계약함으로써 표현한다
2. 서비스의 느슨한 결함 (Service Loose Coupling)
   - 서비스는 의존성을 최소화하고 오직 서로에 대해서만 알고 있다
3. 서비스 추상화 (Service Abstraction)
   - 서비스는 그들의 계약만을 게시하고, 클라이언트로부터 내부 로직을 숨긴다
4. 서비스 재사용성 (Service Resusability)
   - 서비스는 좀 더 대단위의 큰 서비스를 만들기 위해 다른 상태에서 재사용될 수 있다
5. 서비스 자율성 (Service Autonomy)
   - 서비스는 하위 환경과 자원을 제어하며 독립적으로 유지되고, 이로부터 서비스는 일관성과 신뢰성을 유지한다
6. 서비스 무상태 (Service Stateless)
   - 서비스는 상태 관리의 책임을 소비자에게 두며, 이는 서비스 자율성을 위한 제어 과정과 충돌하지 않도록 하기 위해서다
7. 서비스 발견성 (Service Discoverability)
   - 메타데이터로 서비스를 기술함으로써 검색이 가능해지고 서비스 계약을 이해할 수 있는데, 이를 통해 서비스는 사용 가능한 자산이 된다
8. 서비스 구성성 (Service Composability)
   - 서비스는 크기나 컴포지션의 복잡성과는 무관하게 더 대단위 서비스를 구성하는 일부가 될 수 있다

헥사고날 기반 시스템과의 관계
- 하나의 헥사고날 기반 시스템이 다수의 기술적 서비스 엔드포인트를 지원한다는 점에 유의하자

## REST: 표현 상태 전송
아키텍처 스타일로서의 REST
- 아키텍처 스타일이란 특정 설계를 위한 설계 패턴이 무엇인지에 관한 구조적인 큰 그림이다.<br>
이는 여러 구체적 구현에서 일반적으로 사용되는 측면을 추상화하며, 이를 통해 기술적 세부사항에만 집착하다가 길을 잃지 않게 해주고 어떤 부분에서 이점이 있는지 논의할 수 있도록 해준다
- REST는 웹의 아키텍처가 형성된 이후 웹 아키텍처 자체를 기반으로 둔 추론을 바탕으로 얻어진 이론적 결과다. 
   - 지금의 우리는 'REST'를 시스템을 만드는 방법이나 웹 서비스를 만드는 방법으로 생각하고 되었는데 이는 웹 프로토콜을 여러가지 방법으로 활용할 수 있다는 점을 발견했기 때문이다. (RDBMS의 예시)
   - 'RESTful'한 방법으로 HTTP를 사용하며 어떤 이익도 얻지 못한다면, 다른 종류의 분산 시스템 아키텍처가 더 맞을 수도 있다

레스트풀 HTTP 서버의 주요 특징
- 리소스가 핵심 개념이다
   - 일반적으로 각 리소스는 하나의 URI를 가지는데, 각 URI는 반드시 하나 이상의 리소스를 가리켜야 한다는 점이 더욱 중요하며, 이를 통해 외부로 노출한 '대상'을 각각 불러낼 수 있어야 한다
- 자술적 메시지를 사용해 무상태로 의사소통을 하는 개념
   - 예: 서버가 처리할 때 필요한 모든 정보를 담고 있는 HTTP 요청
   - 다른 요청과는 독립적으로 각각의 리소스를 액세스 할 수 있도록 해주며, 이를 바탕으로 대규모 확장성을 달성할 수 있다
- 하이퍼미디어라는 방법을 통해 클라이언트가 애플리케이션에서 일어날 수 있는 상태 변경에 맞는 경로를 찾을 수 있도록 해준다
   - HATEOAS(Hypermedia as the Engine of Application State)
   - 개별 리소스는 스스로 자립할 수 없으며, 리소스를 서로 연결돼 동작한다

레스트풀 HTTP 클라이언트의 주요 특징
- URI에는 주소를 역참조하기 위해 필요한 모든 정보가 담겨 있기 때문에, 하이퍼미디어의 원칙을 따르는 클라이언트는 다른 애플리케이션이나 호스트, 심지어는 다른 기업에서 호스팅하는 리소스에도 말을 걸 수 있다
- 이상적인 REST 설정에선 클라이언트가 단 하나의 잘 알려진 URI에서 시작해, 그 다음부턴 하이퍼미디어 제어를 계속 따라가게 된다

REST와 DDD
- 도메인 모델을 레스트풀 HTTP로 바로노출하는 것은 좋지 않다
   - 도메인 내의 변경 하나하나가 시스템 인터페이스로 바로 반영되기 때문이다
- DDD와 레스트풀 HTTP를 합치는 2가지 방법
   1. 시스템의 인터페이스에 별도의 바운디드 컨텍스트를 생성하고, 시스템의 인터페이스 모델에서 실제 핵심 도메인으로 엑세스하기 위한 적절한 전략을 사용
   2. 특정 미디어 타입이 단일 시스템 인터페이스뿐만 아니라 유사 클라이언트-서버 상호작용 유형도 함께 지원하기 위해 개발된다면, 각 표준 미디어 타입을 표현하기 위해 도메인을 모델을 생성한다
      - 이렇게 만들어진 도메인 모델은 클라이언트와 서버를 모두 아우르며 재사용할 수 있다
   - 솔루션이 특화될수록 첫번째 방법이 유용하며, 공식 표준 본문을 통한 표준화가 이뤄진다면, 일반적으로 유용한 솔루션일수록 두 번째의 미디어타입 중심의 접근법이 더 낫다

왜 REST인가
- REST 원리에 맞게 설계된 시스템은 느슨한 결합의 조건을 충족한다
- HTTP 설계와 도구 사용의 성숙도 때문에 레스트풀 HJTTP는 느슨하게 결합돼야 하고 높은 확상성이 필요한 아키텍처에게 훌륭한 선택이 될 수 있따

## 커맨드-쿼리 책임 분리
배경
- 사용자가 필요한 데이터 뷰를 리파지토리로 쿼리하기란 어려울 수 있다
- 도메인 데이터를 뷰에 매핑하는 완전히 다른 방법이 있을까에 대한 질문이 있었고, 이에 대한 대답으로 CQRS가 있다. 

CQRS 원리
1. 메소드가 객체의 상태를 수정한다면, 이 메소드는 커맨드이며 값을 반환하면 안 된다. 
   - 커맨드 모델
2. 메소드가 값을 반환한다면 이 메소드는 쿼리이며, 직접적이든 간접적이든 객체 상태의 수정을 야기해선  안 된다. 반환타입과 함께 선언해야 한다
   - 쿼리 모델
- 결과적으로 전통적 도메인 모델은 둘로 분리도니다. 커맨드 모델과 쿼리 모델은 서로 다른 저장소에 저장된다

CQRS 영역 및 역할
![4-6](/Images/IDDD/4-6.jpg)
- 쿼리 모델 (읽기 모델)
   - 정규화되지 않은 데이터 모델이며, 오직 표시할 데이터만을 전달한다
      - SQL 데이터베이스라면, 각 테이블에는 한 가지 종류의 클라이언트 뷰만을 위한 데이터가 저장된다
- 클라이언트가 커맨드 처리를 주도한다
   - 클라이언트는 커맨드 모델 내에 있는 애그리게잇의 행동을 실행시키기 위한 방법으로 서버로 커맨드를 보낸다
   - 보내진 커맨드는 실행할 행동의 이름과 이를 수행하기 위해 필요한 매개변수를 포함한다
- 커맨드 처리기
   - 보내진 커맨드는 커맨드 핸들러/처리기가 수신한다
   - 커맨드 처리기 스타일
      - 카테고리 스타일
         - 다수의 메소드를 가진다
         - 단순함이 장점
      - 전용 스타일
         - 각 핸들러는 하나의 메서드를 갖고 있는 하나의 클래스
         - 각 핸들러는 독립적으로 재사용될 수 있고, 특정 종류의 커맨드의 양이 많을 때 이를 관리하기 위해 확장될 수 있다
      - 메시지 스타일
         - 커맨드를 비동기식 메시지로 보낸다
         - 설계가 복잡하기 때문에 기본으로 사용하면 안되며, 동기식 커맨드로 먼저 시작하고 확장의 요구가 있으면 변경을 검토한다
    - 어떤 핸들러를 사용하든 각각을 분리하는게 중요하다. 하나의 핸들러가 다른 핸들러에 의존하지 않도록 한다. 
    - 커맨드 핸들러가 완성되면 단일 애그리게잇 인스턴스가 업데이트되고, 커맨드 모델에 의해 도메인 이벤트가 게시된다. 이는 쿼리 모델이 업데이트됐음을 분명하기 하기 위한 필수 과정이다
- 커맨드 모델(쓰기 모델)은 행동을 수행한다
   - 커맨드 모델상의 각 커맨드 메소드가 수행되면, 이벤트를 게시하며 수행이 완료된다
- 이벤트 구독자가 쿼리 모델을 업데이트한다
   - 한 특별한 구독자가 커맨드 모델에 의해 게시된 모든 도메인 이벤트를 수신하도록 등록한다
   - 이 구독자는 각 도메인 이벤트를 사용해 쿼리 모델이 커맨드 모델에 일어난 가장 최근의 변경을 반영하도록 업데이트한다
      - 동기식 업데이트
         - 쿼리모델과 커맨드 모델이 같은 데이터베이스를 공유하며, 두 모델을 같은 트랜잭션으로 업데이트한다
         - 일관성이 유지되는 장점이 있지만 많은 시간이 소요되고, SLA를 만족하지 못할 수 있다
      - 비동기식 업데이트
         - 동기식 업데이트가 부하를 줄 수 있거나 시간이 오래 걸린다면 비동기식을 사용
         - 지체 시간이 예측 불가능한 단점이 있지만, 다른 SLA를 만족시키기 위해서 감수해야 한다
   - 새로운 사용자 인터페이스 뷰를 생성했지만 데이터를 반드시 생성해야 할 때는?
      - 이벤트 소싱을 사용한다면 기록된 이벤트를 Replay하면 된다
- 일관성이 유지되는 쿼리 모델 다루기
   - CQRS에서 제안된 기법으로 사용자가 현재 보고 있는 쿼리 모델의 데이터에 해당하는 시간과 날짜를 항상 사용자 인터페이스에서 명시적으로 보여주는 방법

## 이벤트 주도 아키텍처
특징
- 위키피디아 정의: 이벤트의 생산, 감지, 소비와 이벤트에 따른 응답등을 촉직하는 소프트웨어 아키텍처
- 출력포트를 통해 게시하는 도메인 이벤트는 입력 포트를 통해 다른 시스템 내에 표현된 구독자로 전달된다

파이프와 필터
- 메시지 기반 파이프와 필터 프로세스의 기본 특성
   - 파이프는 메시지 채널이다
       - 필터는 들어오는 파이프에서 메시지를 수신하고, 나가는 파이프로 메시지를 보낸다. 파이프는 실제론 메시지 채널이다
    - 포트는 필터를 파이프에 연결한다
       - 필터는 포트를 통해 들어오고 나가는 파이프로 연결된다. 포트는 헥사고날이 적합한 중요한 스타일이 되도록 해준다
    - 필터는 처리기다
       - 필터는 실제 필터링 없이도 메시지를 처리할 수 있다
    - 분리된 처리기
       - 각 필터 처리기는 별도의 컴포넌트며, 신중한 설계를 통해 적절한 컴포넌트의 단위성을 달성할 수 있다
    - 느슨한 결합
       - 각 필터 처리기는 다른 모든 것으로부터 독립적인 프로세스로 구성된다
    - 교환 가능성
       - 처리기가 메시지를 받는 순서는 유스케이스 요구사항마다 재구성할 수 있으며, 이 또한 구성에 따른 콤포지현을 사용한다
    - 필터에는 여러 파이프를 연결할 수 있다
       - 병렬적이고 동시적이다
    - 병렬 처리에는 같은 타입의 필터를 사용하라
       - 가장 바쁘고 가장 느릴 가능성이 있는 필터는 처리량의 증가를 위해 여러개 사용할 수 있다
       - _비동기적으로 사용될 때 이점을 나타내는 것일까?_
    
장기 실행 프로세스
- 병렬 프로세싱은 관련된 도메인 이벤트를 모두 수신할 때까지 완료되지 않았다고 간주한다. 완료된 후에는 병렬 처리의 결과가 하나로 합쳐진다
   - 여기에는 어떤 병렬프로세스가 완료되었는지 확인하는 과정이 필요한데, 각 관련 도메인 이벤트에 고유 프로세스 식별자를 부여할 수 있다
- 병렬로 처리되는 각 파이프라인이 완료되면, 실행자는 그에 따른 완료 이벤트를 수신한다. 
   - 실행자는 고유 프로세스 식별자를 이용해서 상태가 완료되었음을 설정한다
- 메시징 매커니즘은 각 이벤트의 단일 전달을 보장하는 기능이 없을 수도 있다 (=두번 전달될 경우에 대한 대응)
   - 완료된 시간을 관리하는 방법으로 대응
- 분산 병렬 처리와 관련이 있을 수 있지만, 분산 트랜잭션과는 전혀 상관 없다
   - 장기 실행 프로세스의 단일 인스턴스에 관여하는 모든 시스템은 실행자가 최종 완성 알림을 받기 전까진 모든 참여자와의 관계에 일관성이 없다고 간주해야 한다

이벤트 소싱
- 변경에 대한 추적관리 개념을 엔터티와 애그리게잇에 적용한다면, 관련된 자원이 어떤 사건으로 생성되었고 시간의 흐름에 따라 어떤 일이 일어났는지를 오페레이션별로 확인할 수 있다
- 방법
   - 각 이벤트는 일어난 순서대로 이벤트 저장소에 자정된다
   - 각 애그리게잇이 해당 저장소로부터 가져올 땐, 발생했던 순서대로 이벤트를 다시 재생해서 인스턴스를 재구성한다
- 병목을 피하기 위해서 스냅샷을 적용해 최적화 한다.
- 이점
   - 이벤트 히스토리가 시스템의 버그를 해결하는 방법을 보여준다


