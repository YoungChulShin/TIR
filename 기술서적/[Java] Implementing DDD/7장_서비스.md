도메인 내의 서비스
- 도메인 고유의 작업을 수행하는 무상태의 오퍼레이션
- 생성에 대한 필요성을 느낄 때는 애그리게잇이나 값 객체에서 수행해야 하는 오퍼레이션이 메소드로는 부족하게 느껴질 때

## 도메인 서비스란
도메인 서비스와 애플리케이션 서비스
- 우리는 비지니스 로직을 애플리케이션 서비스에 넣으려는 게 아니라, 도메인 서비스에 넣고자 한다
- 애플리케이션 서비스는 도메인 모델의 클라이언트로 보통 도메인 서비스의 클라이어트가 된다

도메인 서비스의 사용
- 중요안 비지니스 프로세스를 수행하 ㄹ때
- 어떤 컴포지션에서 다른 컴포지션으로 도메인 객체를 변형할 때
- 하나 이상의 도메인 객체에서 필요로 하는 입력 값을 계산할 때 

## 서비스가 필요한지 확인하자
서비스로 도메인 개념을 모델링하는데 너무 의존하면 안된다
- 서비스를 도메인 문제를 해결하는 묘책으로 여겨서는 안된다
- 서비스를 지나치게 사용하면 대부분의 도메인 로직이 엔터티와 값 객체 전체로 흩어지지 못하고 서비스에만 몰리게 되어서 에너믹 도메인 모델이 만들어질 수 있다

클라이언트와의 관계
- 클라이언트에 많은 구현이 들어가면 클라이언트에서 부담이 늘고, 서버의 로직을 알아야 하는 상황이 발생할 수 있다
- 이 책임들은 모델 안으로 옮겨져야 한다
   - 순수하게 도메인 특화된 지식은 절대로 클라이언트로 유출돼선 안된다
   - 클라이언트가 애플리케이션 서비스라 해도, 해당 컴포넌트는 식별자와 액세스 관리 도메인의 책임을 져서는 안 된다
- `AuthenticationService` 예시
   - 클라이언트에 과중하게 들어가 있던 인증관련 로직을 'AuthenticationService' 로 옮겼다
   - 이 과정은 인증에 대한 세부사항을 애플리케이션 서비스 클라이언트에서 도메인서비스로 밀어낸다
   - 서비스가 필요에 따라 어떤 수의 도메인 객체든 사용할 수 있다
   - 이러한 세부 구현은 클라이언트에서는 알 필요가 없는 것들이다

`UserDescriptor` 클래스 예시
- 도메인 서비스 결과에 대한 반환 타입에 대해서도 꼭 완전한 객체(=User)를 반환할 필요가 없다
- 필요한 정보만을 포함하는 작고 안정적인 객체('UserDescriptor')를 사용할 수 있다

## 도메인 서비스를 모델링하기
도메인 서비스의 위치
1. Interface를 정의하고 Infrastructure에서 구현하기
   - 여러 구현에 대한 사항이 만들어질 수 있다면 필요하다
2. 단일 구현 클래스 
   - 도메인에 서비스를 바로 구현
   - 여러 구현이 필요하지 않을 때 이 방법이 더 적합할 수 있다

`BisuniessPriorityTotal` 예시
- `BacklogItemRepository` 사용
   - 도메인 서비스는 필요에 따라 리포지토리를 사용할 수 있지만, 애그리게잇 인스턴스에서 리파지토리로의 접근은 추천하지 않는 방식이다
- 도메인 로직이 애플리케이션 로직에 유출돼지 않도록 유의해야 한다

도메인 서비스의 미니 계층<br>
(_미니계층이 도메인 모델에서 자연스럽게 사용할 수 있는 서비스의 계층을 만드는 것을 말하는 것일까?_)
- 때론  나머지 도메인 모델 엔터티와 값 객체 위에 도메인 서비스의 '미니 계층'을 생성하는 편이 바람직할 수 있다.<br>
하지만 이는 종종 애너믹 도메인 모델로 이어지기 때문에 안티패턴으로 간주해야 한다. (_서비스에 대한 의존성이 커져서 그럴까?_)

## 서비스의 테스트
테스트 목적
- 클라이언트의 관점에서 생각하는 모델링 방향을 제대로 반영했는지 확인하기 위해서

리포지토리
- 리포지토리는 제대로 된 구현체이거나(_=실제 DB 사용을 뜻하겠지_), 인메모리(_=H2같은_), Mock일 수 있다
- 제대로 된 구현체의 경우는 여러 테스트를 걸쳐 불필요한 인스턴스를 쌓아가지 않도록 테스트를 트랜잭션 롤백으로 마무리한다

클라이언트의 경우는 에러 케이스에 대해서 세부사항을 유념해야 한다
- 실패의 결과가 일반적인 문제 상황일 수도 있고, 실제 Exception을 나타낼 수도 있다

