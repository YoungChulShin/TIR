애그리게잇을 잘못 모델링하는 방식
- 컴포지션의 편의에 맞춰 설계하다 보니 애그리게잇을 너무 크게 만들어버리는 현상
- 애그리게잇을 모두 걷어내는 바람에 진정한 고정자를 보호하지 못하는 경우

## 스크럼 핵심 도메인에서 애그리게잇 사용하기
### 큰 클러스터의 애그리게잇
크기가 큰 애그리게잇
- 처음에는 그럴싸해 보였지만, 실제로 실용적이지 않았다
- 다수의 사용자 환경에서 애플리케이션을 실행핫면 트랜잭션이 주기적으로 실패하기 시작했다

책 예시 - 조의 커밋 실패
- 잘못된 고정자를 기준으로한 설계
- 잘못된 고정자는 개발자가 만들어낸 인위적인 제약 조건
- 이런 설계는 트랜잭션의 문제를 일으킬 뿐 아니라, 성능과 확장성의 측면에서도 안 좋은 영향을 미친다

### 다수의 애그리게잇
다수의 애그리게잇
- 공통의 ID를 통한 추론을 거쳐 각 의존성이 연견된다
- 큰 애그리게잇은 CQS 커맨드 메소드인데 빈해, 여러 애그리게잇은 CQS 쿼리 걔약을 맺고 있다
   - 각 메소드는 새로운 애그리게잇 인스턴스를 생성해서 그 참조를 반환한다
- 트랜잭션의 이점이 있지만, 클라이언트가 사용하는 관점에서 보면 네 개의 작은 애그리게잇은 사용이 불편하다

## 규칙: 진짜 고정자를 일관성 경계 안에 모델링하라
고정자
- 바운디드 컨텍스트에서 애그리게잇을 찾으려면 모델의 진짜 고정자를 이해해야 한다.<br>
이를 알아야만 주어진 애그리게잇으로 묶어야 할 객체가 무엇인지 결정할 수 있다. 
- 언제나 (트랜잭션적) 일관성을 유지해야만 한다

일관성의 경계
- 어떤 오퍼레이션이 수행되든 상관없이 경계 안의 모든 대상이 특정 비지니스 고정자 규칙 집합을 준수하도록 논리적으로 보장해준다
- 이 경계 밖의 일관성은 애그리게잇과 무관하다
- 올바르게 설계된 애그리게잇은 단일 트랜잭션 내에서 완벽한 일관성을 유지하면서, 비즈니스 적으로 요구되는 모든 방식과 그 고정자에 맞춰 수정될 수 있어야 한다. 
- 바르게 설계된 바운디드 컨텍스트는 어떤 상황에서든 한 트랜잭션상 한 애그리게잇 인스턴스 만을 수정한다
   - 이 규칙이 엄격하게 느껴질 수 있지만, 이는 경험 법칙에 따른 것으로 대부분의 상황에선 이를 목표로 해야 한다

## 규칙: 작은 애그리게잇으로 설계하라
큰 애그리게잇을 유지하는데 드는 추가적인 비용
- 모든 트랜잭션이 성공한다고 보장되더라도, 큰 클러스터에는 여전히 성능과 확장성의 문제가 있다
- 이미 거대해진 컬렉션에 단 하나의 항목을 추가하기 위해 수천 개의 백로그 항목을 메모리로 가져올 지도 모른다. 

작은 애그리게잇을 설계할 때 '작다'의 기준
- 애그리게잇을 루트 엔터티와 최소한의 특성이나 값 타입의 속성으로 제한하자
- 최소한의 특성에는 일관성을 유지하는 규칙이 필요하다
   - 예: Product는 name과 description 속성을 갖는다. 보통 name을 바꾸면 description도 같이 바꾼다.<br>이 중 하나가 다른 애그리게잇으로 모델링되는 상황은 상상할 수 없다.

작은 애그리게잇 장점
- 성능과 확장성이 좋다
- 커밋을 가로막는 문제가 거의 일어나지 않기 때문에 트랜잭션이 성공할 가능성이 높다

## 규칙: ID로 다른 애그리게잇을 참조하라
지금까지의 규칙
- 참조하는 애그리게잇과 참조된 애그리게잇은 같은 트랜잭션 안에서 수정해선 안된다
- 하나의 트랜잭션에서 여러 인스턴스를 수정하고 있다면 일관성 경계가 잘못됐다는 신호일 가능성이 높다

참조 없이는 다른 애그리게잇을 수정할 수 없지 않나?
- 이런 상황 자체를 만들지 않음으로써 피해갈 수 있다

ID 참조
- 참조를 사용하되, 객체 참조를 직접 사용하지 말고 전역 고유 식별자를 이용하자
- 추론 객체 참조(inferred object reference)를 가진 애그리게잇은 참조를 즉시 가져올 필요가 없기 때문에 크기가 더 작아진다
- 인스턴스를 가져올 때 더 짧은 시간과 적은 메모리가 필요하기 때문에 모델의 성능도 나아진다

ID 참조에서 모델 탐색
- Repository를 이용해서 탐색할 수 있다
- 탐색할 수 있다고 해도, 둘 이상을 수정할 수 있는 자격이 주어지지는 않는다
- ID만을 사용해서 참조하도록 제한한다면 클라이언트에게 사용자 인터페이스 뷰를 조합해서 보여주기가 더욱 어려워질 수 있다 

## 규칙: 경계의 밖에선 결과적 일관성을 사용하라
결과적 일관성 사용
- 하나의 애그리게잇 인스턴스에서 커맨드를 수행할 때마다 하나 이상의 애그리게잇에서 추가적인 비지니스 규칙이 수행돼야 한다면 결과적 일관성을 사용하자
- 한 인스턴스를 수정할 경우에 그와 관련된 다른 수정이 완료될 때까지 어느 정도의 시간 지연을 용납할 수 있는지 도메인 전문가에게 물어보자
- DDD 모델 내에서 결과적 일관성을 지원하는 방법
   - 애그리게잇 커맨드 메서드는 하나 이상의 비동기 구독자에게 제때 전달되는 도메인 이벤트를 발행한다
   - 각각의 구독자가 다른 유형의 애그리게잇 인스턴스를 가져오고, 그에 기반해 동작을 수행한다.<br>
   각 구독자는 분리된 트랜잭션 내에서 수행한다
   - 구독자가 실행에 실패할 경우는 재시도 할 수 있다. 
   - 재시도 프로세스는 일관성이 달성될 때까지 또는 재시도 제한에 이를 때까지 계속된다
   - 완전히 실패하게 된다면 그에 따른 대응을 하거나 최소한의 대기중인 관련 작업을 위해 실패했음을 알려야 한다
- _단점: 이벤트가 아예 발생 자체를 안했을 경우에 또는 처리 중에 특정 이벤트에서 Hang이 발생하면 어떻게 처리할 것인지 또는 트래킹 할 것인지 대응 시나리오가 필요하다_

트랜잭션이나 결과적 일관성 중 무엇을 사용해야 할까?
- 유스케이스를 논의할 때 데이터의 일관성을 보장하는 주체가 유스케이스를 수행하는 사용자의 일인지 질문해보자<br>
그렇다 -> 다른 애그리게잇의 규칙들은 고수하는 가운데 트랜잭션을 통해 일관성을 보장하자<br>
아니다 -> 만약 다른 사용자아 시스템이 해야할 일이라면 결과적 일관성을 선택한자

## 규칙을 어겨야 하는 이유
1. 사용자 인터페이스 편의
   - 편의를 위해 사용자가 한 번에 여러 일의 공통 특성을 정의해 배치를 생성할 있도록 허용할 때도 있다
   - 애그리게잇 인스턴스의 배치를 한 번에 생성하는 방식과 반복적으로 하나씩 생성하는 방식 사이에 차이점이 없다면, 이는 경험에 근거한 규칙을 깨더라도 문제가 되지 않는 한 가지 이유가 된다
2. 기술적 매커니즘의 부족
   - 결과적 일관성을 위해선 메시징이나 타이머, 또는 백그라운드 스레드와 같은 추가적인 처리 기능의 사용이 필요할 수 있다. 
3. 글로벌 트랜잭션
   - 단기간 내에선 지연될 가능성이 거의 없어야 하는 상황이라 2단계 커밋 트랜잭션을 엄격히 지켜 사용해야 할 경우
4. 쿼리 성능

분명한 점은 경험에만 의존해서 애그리게잇 규칙을 지키지 않아야 할 변명거리를 찾진 말아야 한다.<br>
장기적으로는 규칙을 지키는 편이 프로젝트에 이익이 된다.

## 구현
고유 ID와 루트 엔터티를 생성하라
- 하나의 엔터티를 애그리게잇 루트로 모델링하라
- 각 루트는 전역 고유 식별자와 함께 설계돼야 한다.
   - 예: Product는 ProductId라는 이름의 값 타입과 함께 모델링됐다

값 객체 파트를 선호하라
- 가능하다면 애그리게잇 파트를 엔터티 보다는 값 객체로서 모델링하는 편을 선택하자.<br>
모델이나 인프라에서 의미있는 오버헤드를 야기하지 않는다면 완전히 대체될 수 있는 파트가 최선의 선택지다

'데메테르의 법칙'과 '묻지 말고 시켜라'를 사용하기
데메테르 법칙
- 모든 객체의 모든 메서드는 다음을 통해서만 호출해야 한다
   1. 그 자신
   2. 자신에게 전달된 매게변수
   3. 자신이 인스턴스화 하는 객체
   4. 자신이 직접 액세스 할 수 있는 스스로가 포함된 파트 객체
- _'.'을 2번이상 사용하지 마라_

묻지 말고 시켜라
- 클라이언트 객체는 서버 객체가 갖고 있는 파트를 요구해선 안되며, 자신이 갖고 있는 상태에 기반해 결정해야 하고, 그 후에 서버 객체가 일을 하도록 만들어야 한다
- _클라이언트에서 서버의 상태를 이용해서 호출을 결정하는 것이 아니라 일단 서버를 호출하고 그에 대한 판단은 서버가 해야 한다_

낙관적 동시성
- 애그리게잇의 정의를 생각해보면 버전은 오직 루트 엔터티에서만 관리하는 편이 안전할 듯 보인다
- 책 예시 - Product의 Version
   - `reorderFrom`애서 `version` 직접 컨트롤 하면서 인프라의 관심사가 모델로 흘러 들어오게 되는데, 이는 피할 수 있으면 피해야 하는 방법이다
- 모든 엔터티 파트를 버전 관리하는 방식이 항상 옳은 것은 아니다. 루트 버전의 변경이 고정자를 보호하는 유일한 방법이 될 때도 있다. 
- 루트를 수정하는 일이 아주 어렵고 비용이 많이 든다면, 애그리게잇을 단순한 특성과 값 타입 속성만을 담고 있는 루트 엔터티로 쪼개야 함을 알려주는 단서일 수 있다.<br>
애그리게잇이 루트 엔터티로만 구성된다면 어떤 파트가 수정되든 루트가 함께 수정된다

의존성 주입을 피하라
- 일반적으로 리파지토리나 도메인 서비스의 애그리게잇으로의 의존성 주입은 나쁘다고 볼 수 있다.
   - 애그리게잇 내부에서 의존적 객체를 인스턴스를 찾고 싶기 때문일 수 있다
   - 의존적 객체는 ID를 통해서 커맨드 메서드가 실행되기 전에 찾아서 전달하는 편이 좋다
- 트래픽이 많고, 높은 성능을 발휘해야 하는 도메인에서 메모리 크기와 가비지 컬렉션의 부담을 느끼고 있다면, 리파지토리와 도메인 서비스 인스턴스를 애그리게잇으로 주입하는데 따른 잠재적 오버헤드를 생각해보자


