## Item 11 : 닷넷 리소스 관리에 대한 이해
- 개발자 관리 리소스
   - DB 연결
   - GID+ 객체
   - COM 객체
   - 시스템 객체
   - __CLR Via C#에서 가비지 수집 관련해서 항목을 보고 정리하자__

## Item 12: 할당 구문보다는 멤버 초기화가 좋다
- 멤버 초기화: 생성자가 아니라 멤버 변수를 선언함과 동시에 초기화를 하는 방식
- 멤버 초기화는 컴파일러가 생성자의 시작부분에 초기화 구문을 포함한다
- 장점
   - 생성자가 2개 이상일 때, 초기화를 누락할 수 있는 실수를 줄여준다
   - 그렇기 때문에 유지보수도 용이하다
   - 다만 모든 생성자에서 초기화 방식이 동일해야 한다
- 적용하지 못하는 경우
   - 생성자에 따라 초기화 구문이 다를 경우
   - 변수 초기화에 예외 처리가 필요할 경우

## Item 13: 정적 클래스 멤버를 올바르게 초기화 하라
- 정적 멤버를 포함하는 타입이 있으면 인스턴스 생성 전에 초기화를 해야 한다
- C#에서는 '정적멤버초기화'와 '정적 생성자' 2개를 제공한다
- 호출 순서는 정적 생성자 -> 생성자

## Item 14: 초기화 코드가 중복되는 것을 최소화 하라
- 공용으로 사용할 수 있는 생성자를 만들어서 초기화 코드의 중복을 피할 수 있다 (= 생성자 체인 기법)
   - public MyClass() : this(XXX, YYY) {}
   - public MyClass(int xInput, int yInput) {}

- 초기화 함수를 만들어서 각 생성자에서 호출하는 방법도 있지만, 이렇게 되면 컴파일러가 코드를 컴파일 할 때에는 초기화 코드가 각 생성자에 포함된다
- **특정 타입의 인스턴스가 생성되는 순서**
   1. 정적 변수의 저장 공간을 0으로 초기화
   2. 정적 변수에 대한 초기화 구문을 수행
   3. 베이스 클래스의 정적 생성자 수행
   4. 정적 생성자 수행
   5. 인스턴스 변수의 저장 공간을 0으로 초기화
   6. 인스턴스 변수에 대한 초기화 구문 수행
   7. 적절한 베이스 클래스의 인스턴스 생성자 수행
   8. 인스턴스 생성자 수행

   -클래스 자체의 초기화 작업은 한 번만 이뤄지기 때문에 동일한 타입으로 클래스를 생성하면 앞의 단계 중 5단계에서 부터 수행된다

- C#은 객체가 생성될 때 어떤 식으로든 모든 객체가 초기화 될 것임을 보장한다. 인스턴스를 생성하면 인스턴스 내의 모든 멤버들이(= 정적 멤버, 인스턴스 멤버를 가지지 않고) 최소한 0으로 초기화 된다. 
- 생성자를 작성할 때 유념할 부분은 멤버들을 원하는 값으로 초기화할 때 가능한 한 한번만 초기화가 이뤄지도록 해야 한다는 점이다. 
   - 단순한 리소스의 경우는 멤버 초기화 구문을 이용
   - 복잡한 과정이 필요한 경우 생성자를 이용
   - 코드의 중복을 막기 위해서 공통적인 초기화 작업을 하는 공용 생성자를 작성하고 이용한다

## Item 15 불필요한 객체를 만들지 말라
- 가비지 수집기는 응용프로그램이 사용하는 메모리를 효율적으로 관리한다. 그러나 힙에서 객체를 생성하고 삭제하려면 여전히 시간이 필요하다. 객체를 과도하게 생성하는 것을 피하고 불필요한 객체를 생성하지 말라. 

- 객체 생성을 최소화 하는 방법
   1. 자주 사용되는 지역변수를 멤버변수로 변경하는 것
      - 특히 onPaint()같이 자주 호출되는 함수의 경우는 가비지 컬렉션이 자주 일어나기 때문에 성능에 영향을 미칠 수 있다
   2. 종속성 삽입(Dependency Injection)을 활용하여 자주 사용되는 객체를 생성했다가 이를 재활용 하는 것이다
   3. 보간 문자열 또는 StringBuilder를 사용해서 문자열을 처리하는 것
      - string 문자에 새로운 값을 할당하면 기존의 문자열이 변경되는 것이 아니라, 새로운 값을 가지는 객체가 생성된다. 기존의 문자열 객체는 가비지가 된다

## Item 16 생성자 내에서는 절대로 가상 함수를 호출하지 말라
- 초기화 순서
   - 정적벽수 -> 지역번수가 초기화 -> 베이스 클래스 생성자 -> 자식 클래스 생성자
- 베이스 클래스의 생성자에서 가상 함수를 호출하고 자식 클래스에서 이를 구현하고 있다면 자식 클래스의 생성자에서 올바른 값을 할당하기 이전에, 베이스 클래스 생성자에 의해서 자식 클래스의 Override 된 함수가 호출될 수 있다

## Item 17 표준 Dispose 패턴을 구현하라
- 정의
   - 닷넷 내부에서 비관리 리소스를 정리하는 표준화된 패턴
   - IDisposable Interface를 통해서 개발자들이 리소스를 안전하게 삭제할 수 있는 기능을 제공한다
- 리소스 정리 규칙 - Base Class
   - 리소스를 정리하기 위해서 IDisposable 인터페이스를 구현해야 한다
   - 멤버 필드로 비관리 리소스를 포함하는 경우에 한해 방어적으로 동작할 수 있도록 finalizer를 추가해야 한다
   - Dispose와 finalizer는 실제 리소스 정리 작업을 수행하는 다른 가상 메서드에 작업을 위임하도록 작성돼야 한다. 파생 클래스가 고유의 리소스 정리 작업이 필요한 경우 이 가상 메서드를 재정의 할 수 있도록 하기 위함이다
- 리소스 정리 규칙 - Derived Class
   - 파생 클래스가 고유의 리소스 정리 작업을 수행해야 한다면, 베이스 클래스에서 정의한 가상 메서드를 재 정의 한다. 
   - 멤버 필드로 비관리 리소스를 포함하는 경우에는 반드시 finalizer를 추가해야 한다
   - 베이스 클래스에서 정의하는 가상함수를 반드시 호출해야 한다

- 비 관리 리소스가 포함된 경우 finalizer를 구현하는 것이 중요하다.<br>
finalizer도 없고, Dispose 호출 역시 잊어버리면 리소스 누수가 발생한다<br>
이 말은 비 관리 리소스가 포함되어 있지 않으면 finalizer를 구현하지 말아야 한다. finalizer의 존재 만으로도 성능상의 손해를 감수해야 한다. 
- finalizer의 호출 동작
   - GC가 수행되면 가비지 객체는 메모리에서 제거되지만 finalizer를 가진 객체는 메모리에 남는다
   - GC는 finalizer 큐라는 곳에 이 객체들을 삽입해 두고, finalizer 스레드를 이용해서 이 큐에 포함된 객체들의 finalizer를 순차적으로 호출한다. 
   - finalizer 큐에 삽입된 객체는 한 세대가 높아지기 때문에, 메모리에서 제거되는 시점이 느려진다
- IDisposable.Dispose()의 작업
   1. 모든 비관리 리소스를 정리한다
   2. 모든 관리 리소스를 정리한다
   3. 객체가 이미 정리되었음을 나타내기 위한 상태플래그를 설정한다
   4. finalize호출 회피. GC.SuppressFinalize(this)를 호출한다

- finalizer와 derived class에서 모두 Dispose를 사용하기 위해서는 protected type의 가상함수를 만들어 준다
   - protected virtual void Dispose(bool isDisposing)

- 반드시 비 관리 리소스를 포함하는 경우에만 finalizer를 구현해야 한다. finalizer가 존재하는 것 만으로도 상당한 성능상의 손해가 있기 때문에, finalizer가 필요 없는 경우라면 절대 추가하지 않는다.                                                                

- IDisposable 구현 관련 참고 링크
   - [CodeProject](https://www.codeproject.com/Articles/413887/Understanding-and-Implementing-IDisposable-Interfa)
   - [Medium](https://medium.com/rkttu/idisposable-%ED%8C%A8%ED%84%B4%EC%9D%98-%EC%98%AC%EB%B0%94%EB%A5%B8-%EA%B5%AC%ED%98%84-%EB%B0%A9%EB%B2%95-4fa0fcf0e67a)

