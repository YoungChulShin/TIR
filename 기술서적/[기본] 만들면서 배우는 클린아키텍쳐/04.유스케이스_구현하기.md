# 04. 유스케이스 구현하기
## 유스케이스 둘러보기
유스케이스의 역할
1. 입력을 받는다
2. 비지니스 규칙을 검증한다
3. 모델 상태를 조작한다
4. 출력을 반환한다

유스케이스는 비지니스 로직을 검증할 책임이 있다. 입력 유효성 검증은 가능하면 입력 모델(command 모델)에 책임을 두고, 유스케이스는 도메인 로직에만 집중하도록 한다. 

![4-1](/Images/만들면서배우는클린아키텍쳐/4-1.jpg)

## 입력 유효성 검증
책에서는 입력 모델(SendMoneyCommand)이 입력 유효성에 대한 검증 책임을 가진다. 
- 어댑터가 유스케이스에 입력 전에 유효성을 검증할 수도 있지만, 모두 구현한다는 보장이 없고 각각의 어댑터에 코드가 들어가야하는데 놓칠수도 있다. 

애플리케이션 계층에서 입력 유효성 검사를 해야하는 이유는, 그렇지 않을 경우 코어의 바깥쪽으로부터 유효하지 않은 입력값을 받게 되고, 모델의 상태를 해칠 수 있기 때문이다. 

## 생성자의 힘
빌더를 사용할 경우 유연하게 코드를 만들 수 있는 장점이 있지만, 컴파일 타임에 유효하지 않은 상태의 객체를 만들려는 부분에 대해서는 경고를 주지 못한다. 

생성자를 이용하면 컴파일 타임에 이러한 오류를 잡을 수 있다. 파라미터가 많은 부분은 IDE의 도움을 받아본다. 

## 유스케이스마다 다른 입력모델
각 유스케이스 전용 입력 모델은 유스케이스를 훨씬 명확하고 다른 유스케이스와 함께 사용할 때 발생할 수 있는 부수효과가 발생하지 않는 장점이 있다. 

## 비지니스 규칙 검증하기
입력 유효성 검증은 유스케이스 로직의 일부가 아닌 반면, 비지니스 규칙 검증은 유스케이스 로직의 일부다. 

유스케이스 로직과 비지니스 로직
- 간단하게는 도메인의 상태에 접근하는가에 따라서 구분할 수 있다.
- 유스케이스 로직: 구문상의 유효성을 검증
   - 예: 송금되는 금액은 0보다 커야한다
- 비지니스 로직: 맥락 속에서 의미적인 유효성을 검증
   - 예: 출금 계좌는 초과 출금이 되어서는 안된다

비지니스 규칙 검증 위치
- 일반적으로 도메인 엔티티 안에서 구현한다
- 도메인 엔티티 안에서 구현하기 어려운 부분은 유스케이스에서 도메인 엔티티를 사용하기 전에 검증한다

## 풍부한 도메인 모델 vs 빈약한 도메인 모델
풍부한 도메인 모델(rich domain model)
- 애플리케이션의 코어에 있는 엔티티에 가능한 많은 도메인 로직을 구현한다
- 유스케이스는 도메인 모델의 진입점으로 동작한다. 사용자의 의도만을 표현하면서 실제 작업은 도메인 엔티티를 호출한다

빈약한 도메인 모델(anemic domain model)
- 엔티티가 굉장히 얇다. 일반적으로 엔티티를 표현하는 필드와 getter, setter 정도를 가지고 있다.
- 유스케이스가 풍부해지고 도메인 로직이 여기에 위치한다

DDD는 풍부한 도메인 모델을 지향하지만, 구현하는 프로젝트의 필요성에 따라서 맞게 선택하고 구현하면 된다. 

## 유스케이스마다 다른 출력 모델
가능하면 호출자에게 필요한 데이터만 반환한다. 

명백한 정답은 없지만, 출력 모델을 공유하게 되면 유스케이스간에 결합이 발생하고 시간이 지나면 모델이 점점 커질 가능성이 있다. 같은 이유로 엔티티를 리턴하고 싶은 유혹도 견뎌야한다. 

## 읽기 전용 유스케이스
읽기 전용 작업이 유스케이스라고 부르는것은 조금 어색할 수도 있다. 이 경우 `쿼리 서비스`라고 정의하고 구분해볼 수 있다. 
- 쿼리를 위한 인커밍포트를 만들고 쿼리서비스를 구현하는 것이다. 
   ```java
   class GetAccountBalanceService implements GetAccountBalanceQuery {
   ```
- 동작은 유스케이스와 동일하지만 모델의 상태를 변경하는 로직이 없다. 

읽기 전용 쿼리는 쓰기가 가능한 유스케이스와 코드 상에서 명확하게 구분이 되기 되게 되는데, CQS, CQRS 개념과 잘 맞는다. 

## 생각
유스케이스에 잘못된 데이터가 들어가는 것을 막기 위해서 command 입력 모델을 사용하고 입력 모델에 유효성 검증을 해주는 작업은 필요하고, 좋은 것 같다. 

유스케이스마다 서로 다른 입력/출력 모델을 가지는 것도 많이 공감이 되었고 가능하면 이렇게 하려고 노력 중이다. 입/출력 모델이 여러곳에서 사용되면 나중에 특정 모델에 변경이 발생할 때 수정이 어렵고, 모델이 점점 커지는 것을 경험했다. 

