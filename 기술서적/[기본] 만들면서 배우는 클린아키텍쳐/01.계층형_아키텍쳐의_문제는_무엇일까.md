# 01. 계층형 아키텍처의 문제는 무엇일까?
기본적인 계층형 아키텍처 구조
- 웹 -> 도메인 -> 영속성의 3계층 구조

계층형 구조도 잘 이해하고 만들면 웹 계층이나 영속성 계층에 독립적으로 도메인 로직을 작성할 수 있다
- 잘만들어진 계층형 아키텍처는 선택의 폭을 넓히고, 변화하는 요구사항과 외부 요인에 빠르게 적응할 수 있게 해준다

계층형 구조의 문제점은?
- 코드에 나쁜 습관들이 스며들기 쉽게 만든다
- 시간이 지날수록 소프트웨어를 점점 더 변경하기 어렵게 만드는 허점들을 노출한다

## 계층형 아키텍처는 데이터베이스 주도 설계를 유도한다
도메인 계층이 영속성 계층에 의존하기 때문에 자연스레 데이터베이스에 의존하게 된다.

우리는 상태가 아니라 행동 중심으로 모데링을 해야하는데(=상태가 중요하긴 하지만 행동이 상태를 바꾸는 주체이기 때문에), 도메인 계층이 영속성 계층을 의존하게 되면 데이터베이스를 먼저 만들고 도메인 계층을 여기에 맞추게된다.
- 상태 중심의 에너믹 모델이 만들어질 수도 있다

하지만 비지니스 관점에서 본다면, 도메인 로직을 먼저 만들어야한다. 도메인 로직을 먼저 만든 이후에 이를 기반으로 영속성 계층과 웹 계층을 만들어야한다. 

데이터베이스 중심적인 아키텍처가 만들어지는 가장 큰 원인은 ORM 프레임워크를 사용하기 때문이다. 
- 서비스는 영속성 모델을 비지니스 모델처럼 사용하게 되고, 도메인 로직 외에 즉시로딩/지연로딩, 트랜잭션, 캐스 플러시 등등의 영속성 계층과 관련된 작업을 함께 처리해야한다.

## 지름길을 택하기 쉬워진다
전통적인 계층형 아키텍처에서 전체적으로 적용되는 유일한 규칙은 특정한 계층에서는 같은 계층 또는 하위 계층에만 접근 가능하다는 것이다. 
- 만약 상위 계층에 위치한 컴포넌트에 접근해야한다면 해당 컴포넌트를 하위 계층으로 내려서 해결할 수 있다. 
- 딱 한번은 괜찮지만 이 문제가 계속 된다면 코드의 품질은 떨어질 수 있다. 
- 헬퍼 컴포넌트가 유틸리티 컴포넌트가 영속성 계층까지 내려갈 수 있다. 

지름길 모드를 끄고 싶다면 추가적인 아키텍처 규칙을 강제해야하는데, 코드 리뷰 같은 의미보다는 빌드가 실패하도록 만들어야한다. 

## 테스트하기 어려워 진다
게층형 아키텍처를 사용할 때 일반적으로 나타나는 변화의 형태는 계층을 건너뛰는 것이다. 웹 계층에서 도메인 계층에 접근해서 엔티티를 수정할 수 있다. 
![1-4](/Images/%EB%A7%8C%EB%93%A4%EB%A9%B4%EC%84%9C%EB%B0%B0%EC%9A%B0%EB%8A%94%ED%81%B4%EB%A6%B0%EC%95%84%ED%82%A4%ED%85%8D%EC%B3%90/1-4.jpg)

이 경우 2가지의 문제가 발생한다. 
1. 도메인 로직이 웹 계층에 구현될 수 있다. 이는 도메인 로직이 여러 곳에 퍼져나가는 문제를 야기한다.
2. 웹 계층 테스트를 하는데 영속성 계층까지 모킹해야할 수도 있다. 테스트 구현이 복잡해진다. 
   - 시간이 지나면서 테스트 코드를 작성하는 것보다, 종속성을 이해하고 mock을 만드는데 시간을 더 많이 쓰게 된다

## 유스케이스를 숨긴다
개발을 하다보면 기능을 추가하거나 변경할 적절한 위치를 찾는일이 빈번하기 때문에 아키텍처 코드는 이 작업을 빠르게하는데 도움이 돼야한다.
- 도메인 로직이 분산된 계층형 아키텍처는 새로운 기능을 어디에 추가할지 어려워지게 된다. 

계층형 아키텍처는 너비에 대한 규제가 없기 때문에 'OrderService' 같은 방대한 크기의 서비스가 만들어질 수 있다. 
- 넓은 서비스는 영속성 계층에 많은 의존성을 가지게 되고, 많은 웹 계층이 의존하게 된다. 테스트가 어려워지고 작업의 책임을 가지는 유스케이스를 찾기가 어려워진다. 
- UserService보다는 RegisterUserService가 더 좋지 않겠는가?

## 동시 작업이 어려워진다
3명의 개발자가 있다고 3명이 작업을 나누어 동시에 진행하기가 어렵다
- 영속성 계층을 만들고, 도메인 계층을 만들고, 웹 계층을 순서대로 만들어야하기 때문이다. 

만약에 코드에 넓은 서비스가 있다면 서로 다른 기능을 동시에 작업하기는 더 어럽다. 

## 유지보수 가능한 소프트웨어를 만드는 데 어떻게 도움이 될까?
앞에서 설명한 계층형 아키텍처의 단점은 익숙할 수도 있고, 겪어봤을 수도 있다.

올바르게 구축하고 추가적인 몇가지 규칙을 적용하면 계층형 아키텍처는 유지보수하기 쉬우며, 코드를 쉽게 변경하거나 추가할 수 있다. 하지만 계층형 아키텍쳐는 많은 것들이 잘못된 방향으로 흘러갈 수 있게 용인하고, 엄격한 자기 훈련 없이는 시간이 지날수록 품질이 저하되고 유지보수 하기가 어려워지기 쉽다.

## 생각
이 책에서는 계층형 아키텍처를 설명했지만 어떤 아키텍처를 사용하더라도 시간이 지나면서 초기의 구조를 무너뜨릴 수 있는 방법은 만들어질 것이라고 생각한다. 이를 위해서 추가적인 장치/규칙/엄격한 자기 훈련을 바탕으로 지속적으로 프로젝트를 관리해야하는 것 같다. 

코드 리뷰에 많이 의존하고 있지만, 코드 리뷰 외에 빌드 실패를 통해서 구조가 깨지는 것을 막아주는 것은 좋은 것 같다. Presentation Layer에서 의도하지 않은 참조가 발생하면 그것을 막아보는것은 어떨까?

서비스는 가능한 작게 나누어서 SRP를 지키고, 동시작업을 할 수 있도록 하면 좋을듯하다. 



