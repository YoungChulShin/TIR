# 03. 코드 구성하기

## 계층으로 구성하기
![3-1](/Images/만들면서배우는클린아키텍쳐/3-1.jpg)

단점
- 애플리케이션의 기능 조각이나 특성을 구분 짓는 패키지 경계가 없다
- 애플리케이션이 어떤 유스케이스를 제공하는지 파악할 수 없다
- 인커밍, 아웃고잉 포트가 코드 속에 숨겨져 있다

## 기능으로 구성하기
![3-2](/Images/만들면서배우는클린아키텍쳐/3-2.jpg)

단점
- 가시성이 떨어진다

## 아키텍처적으로 표현력 있는 패키지 구조
![3-3](/Images/만들면서배우는클린아키텍쳐/3-3.jpg)

특징
- 최상위에 특정 도메인과 관련된 패키지임을 명시하기 위해서 상위 패키지가 존재한다
- domain: 도메인 모델
- application: 도메인 모델을 둘러싼 서비스 계층
- application/port: 인커밍, 아웃고잉 포트 존재
- adapter: 외부에서 포트를 사용 또는 구현하는 어댑터가 존재

예: SendMoneyService
- SendMoneyUseCase를 구현
- LoadAccountPort, UpdateAcountPort를 사용한다

접근 권한
- 기본적으로 package-private으로하고, 외부에서 접근될 수 있는 클래스는 public으로 한다
   - public: domain model, usecase, outgoing port 

## 의존성 주입의 역할
의존성이 중심을 향하도록 하기 위해서 의존성 역전 원칙을 사용했는데, 여기에 의존성 주입은 누가해야할까?

의존성 주입을 위한 컴포넌트
- 모든 계층의 바깥에 존재하면서, 중립적인 컴포넌트
- 아키텍처를 구성하는 대부분의 클래스를 초기화하는 역할을 한다. 