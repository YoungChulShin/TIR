# 02.의존성 역전하기
## 단일 책임 원칙
단일 책임 원칙: 컴포넌트를 변경하는 이유는 오직 하나뿐이어야한다
- 어떤 다른 이유로 소프트웨어를 변경하더라도 이 컴포넌트에 대해서는 신경쓸 필요가 없게된다
- 많은 코드는 단일 책임 원칙을 위반하기 때문에 시간이 갈 수록 변경이 어려워지고 변경 비용도 증가한다

## 의존성 역전 원칙
계층형 아키텍처에서 계층간 의존성은 아래를 가리킨다. 영속성 계층에 대한 도메인 계층의 의존성 때문에 영속성 계층을 변경할 때마다 잠재적으로 도메인 계층도 변경해야한다. 
- 하지만 도메인 코드는 애플리케이션에서 가장 중요하기 때문에 영속성 계층이 변경 될 때마다 도메인 계층까지 변경하고 싶지는 않다. 

의존성 역전 원칙(DIP)를 적용하면 의존성의 방향을 바꿀 수 있다. 
- 이를 통해서 영속성 계층이 도메인 계층에 의존하도록 할 수 있다. 
- 핵심은 interface를 이용하는 것이다. 컴파일 타임에는 영속성 계층이 도메인을 의존하지만, 런타임에는 의존성이 반대로 된다. 
![2-2](/Images/만들면서배우는클린아키텍쳐/2-2.jpg)

## 클린 아키텍처
클린 아키텍처 (by 엉클밥)
- 설계가 비지니스 규칙의 테스트를 용이하게 하고
- 비지니스 규칙은 프레임워크, 데이터베이스, UI 기술, 그 밖의 외부 애플리케이션이나 인터페이스로부터 독립적일 수 있다고 이야기했다

이는 도메인 코드가 바깥으로 향하는 어떤 의존성도 없어야 함을 의미한다. 

클린 아키텍처 그림
![2-3](/Images/만들면서배우는클린아키텍쳐/2-3.jpg)

도메인 코드는 어떤 영속성 프레임워크나 UI 프레임워크가 사용되는지 알 수 없기 때문에 특정 프레임워크에 특화된 코드를 가질 수 없고, 비지니스 규칙에 집중할 수 있다. 

여기에는 대가가 따른다
- 도메인 계층이 다른 UI, 영속성 계층으로부터 철저하게 독립되어야 하기 때문에 엔티티에 대한 모델을 각 계층에서 유지보수해야한다. 
- ORM을 쓴다고하면 영속성 모델이 필요한데, 도메인 계층은 영속성 계층을 모르기 때문에 두 계층에서 각각 엔티티를 만들어야한다. 
   - 도메인 입장에서는 이는 바람직한 일이다. 
   - 예를들어서 JPA를 사용한다면 도메인 코드에 기본 생성자가 있어야하는 강제조건이 있는데, 이러한 프레임워크의 제약으로부터 도메인 모델을 자유롭게 관리할 수 있다. 

## 육각형 아키텍처 (헥소고날 아키텍처)
육각형 아키텍처 그림
![2-4](/Images/만들면서배우는클린아키텍쳐/2-4.jpg)

설명
- 육각형 안에는 도메인 엔티티와 유스케이스가 있다. 육각형에서 외부로 향하는 의존성이 없기 때문에 클린 아키텍처의 의존성 규칙이 그대로 적용된다. 즉, 모든 의존성은 코어(유스케이스, 엔티티)를 향한다. 
- 육각형 바깥에는 애플리케이션과 상호작용하는 어댑터가 있다. 어댑터에는 웹 어댑터, 영속성 어댑터 등이 있다. 
   - 왼쪽에는 애플리케이션을 주도하는(driving adapter) 어댑터들이다
   - 오른쪽에는 애플리케이션에 의해 주도되는(driven adapter) 어댑터들이다. 
- 각 어댑터는 육각형 외부에 위치한 포트와 연결된다. 

## 생각
서비스가 SRP를 갖추면서 범위를 좁게 가져가는 것은 서비스의 행동을 예측할 수 있고, 의존하는 곳도 작게 유지할 수 있다는 점에 좋은 것 같다. 지금 개발하는 애플리케이션에는 너무 넓은 서비스로 인해서 코드의 변경점을 파악하거나, 테스트코드 작성이 어렵고 변경을 했을 때 영향을 받는 모듈이 너무 많아서 수정할 때 어려웠던 경험을 했다. 

DIP를 적용해서 도메인과 영속성 계층의 의존성을 바꿨다면, 앞장에서 설명했던 계층구조를 뛰어넘은 방법을 지양한다고 할 때 컴파일 타임 의존성의 방향은 아래와 같이 될 것 같다. 
- 프레젠테이션 -> 애플리케이션 -> 도메인 <- 영속성

헥소고날 방식을 이용하면 포트로 인해서 계층을 뛰어넘거나 잘못된 방향으로 의존성이 향하는 것을 아케텍처 레벨에서 막아줄 수 있기 때문에 한번 적용해본다면 좋을 것 같다.

다만 도메인 모델과 영속성 모델을 별도로 관리한다면 JPA가 제공해주는 Lazy Loading이나 변경 감지 같은 기능은 사용하지 못하는걸까? 이 부분이 아직 확실히 감이 오지는 않는다. 그래도 한번은 해보면 도움이 될 것 같다. 사이드 프로젝트에서 한번 해봐야겠다. 