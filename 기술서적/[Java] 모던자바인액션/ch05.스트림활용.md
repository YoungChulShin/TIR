# 스트림 활용
distinct
- 고유 여부를 equals, hashcode로 판단
   - equals와 hashcode가 모두 같아야 distinct()에서 동일한 것으로 판단

takeWhile, dropWhile
- 정렬된 요소에 대해서 일정 조건까지의 계산을 할 수 있도록 지원
- java 9

map
- 새로운 요소로 맵핑할 때 사용

flatMap
- 스트림의 각 값을 다른 스트림으로 만든 다음에 모든 스트림을 하나의 스트림으로 연결한다

쇼트서킷
- 전체 스트림을 처리하지 않았더라도 결과를 반환할 수 있는 연산
- allMatch, anyMatch, noneMatch, findFirst, findAny, limit 등

findAny()와 findFirst()가 모두 있는 이유
- 병렬성 때문. 병렬스트림에서는 첫 번째 요소를 찾기가 어렵다
- 요소의 반환 순서가 상관 없다면 병렬 스트림에서는 findAny()를 사용한다

reduce
- 리듀싱 연산: 모든 스트림 요소를 처리해서 값으로 도둘하는 연산. 함수형 언어로는 '폴드'라고 한다.
- 스펙
   ```
   reduce(T 초기 값, BinaryOperator<T>)
   reduce(BinaryOperator<T>) -> Optional<T>를 반환
   ```
- 랩 리듀스: map과 reduce를 연결하는 기법
   ```java
   List<Dish> dishes = Arrays.asList(dish1, dish2, dish3, dish4);
   Integer reduce = dishes.stream()
      .map(d -> 1)
      .reduce(0, Integer::sum);
   ```
- reduce를 이용해서 내부적으로 연산을 수행하면, 내부반복이 추상화되기 때문에 병렬처리를 할 수 있게 된다. 외부 반복의 경우는 보통 sum 변수를 만들어서 처리하게 되는데, 이렇게 되면 병렬처리를 하기가 어렵다. 

스트림 연산의 상태
- 내부 상태를 갖지 않는 연산
   - 연산이 내부 상태를 변경하지 않는 연산
   - map, filter 등
- 내부 상태를 가지나 크기가 한정되어 있는 연산
   - 내부 상태를 가지고 있지만 스트림의 요소수와 상관없이 정해진 크기를 가지는 연산
   - reduce, sum, max 등
- 내부 상태를 갖는 연산
   - 