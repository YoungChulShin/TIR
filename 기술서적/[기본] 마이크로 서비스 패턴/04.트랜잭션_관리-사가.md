# 트랜잭션 관리: 사가
ACID 트랜잭션은 데이터를 배타적으로 접근해서 처리하는 것처럼 동작하기 때문에 개발자가 할 일이 단순해진다. 마이크로서비스 아키텍처는 단일 서비스 내부의 ACID는 보장하지만, 여러 서비스를 업데이트하는 트랜잭션은 구현하기가 까다롭다. 

여러 서비스에 걸친 작업의 데이터 일관성을 위해서는 ACID 트랜잭션 대신, 사가(saga)라는 메시지 주도 방식의 로컬 트랜잭션을 이용해야한다. 

## 마이크로서비스 아키탁처에서의 트랜잭션 관리
분산 트랜잭션의 필요성
- 데이터가 여러 서비스에 흩어져있는 마이크로서비스 아키텍처는 각 서비스에 있는 데이터에 접근해야한다
- 서비스마다 DB가 따로있기 때문에 여러 DB에 걸쳐 데이터의 일관성을 유지할 수 있는 수단을 강구해야한다

분산트랜잭션의 문제점
- 예전에는 분산트랜잭션을 사용해서 데이터의 일관성을 유지했다
- XA(X/Open XA)는 분산 트랜잭션의 표준인데, 2단계 커밋을 이용해서 전체 트랜잭션 참가자가 커밋 아니면 롤백을 하도록 보장한다. 
- 문제
   - NoSQL과 메시지브로커는 분산 트랜잭션을 지원하지 않는다
   - 동기 IPC라서 가용성이 떨어진다

### 사가패턴
데이터 일관성 유지: 사가패턴
- 개념
   - 마이크로서비스 아키텍처에서 분산 트랜잭션 없이 데이터의 일관성을 유지하는 매커니즘이다
   - 각 로컬트랜잭션마다 변경분을 커밋하므로 보상트랜잭션을 걸어서 롤백해줘야한다
- 예제: 주문생성 사가
   ![그림4-2](/Images/%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%EC%84%9C%EB%B9%84%EC%8A%A4%ED%8C%A8%ED%84%B4/3-8.jpg)
   - 6개의 로컬 트랜잭션으로 구성된다
   - 각 로컬트랜잭션이 완료되면 메시지를 발행해서 다음 사가 단계를 트리거한다
   - 메시지를 이용해서 사가 참여자를 느슨하게 결합시킨다
- 보상트랜잭션으로 롤백
   - 마이크로서비스에서는 실패가 발생했을 때 보상트랜잭션(compensating transaction)을  이용해서 이전단계의 변경분을 명시적으로 언두해야한다.
   - 보상트랜잭션은 항상 필요한 것은 아니다.
      - 읽기전용 단계에서는 보상트랜잭션이 필요 없다. 
      - 절대로 실패하지 않는 단계 다음에도 보상 트랜잭션이 필요 없다. 
      - 항상 성공하는 단계 다음에도 보상트랜잭션이 필요 없다. 

## 사가 편성
### 코레오그래피(choreography) 사가
사가 참여자가 할 일을 알려주는 중앙 편성자가 없다. 대신 참여자가 서로 이벤트를 구독해서 그에따라 반응하는 방식

주문생성 사가 예시
- 주문 성공 
   ![그림4-4](/Images/%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%EC%84%9C%EB%B9%84%EC%8A%A4%ED%8C%A8%ED%84%B4/3-8.jpg)
- 주문 실패
   ![그림4-5](/Images/%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%EC%84%9C%EB%B9%84%EC%8A%A4%ED%8C%A8%ED%84%B4/3-8.jpg)

고려해야할 2가지 통신 이슈
1. 사가 참여자가 자신의 DB를 업데이트하고, DB 트랜잭션의 일부로 이벤트를 발행해야한다
  - 이벤트 발행은 트랜잭셔널 메시징 방법을 사용한다
2. 사가 참여자는 자신이 수신한 이벤트와 자신이 가진 데이터를 연관지을 수 있어야한다
   - 상관관계 ID가 포함된 이벤트를 발행한다

장점
- 단순함: 서비스가 이벤트를 직접 발행한다
- 느슨한 결합: 메시지 기반이기 때문에 느슨한 결합

단점
- 이해하기 어렵다: 사가가 한곳에 정의된 것이 아니고, 여러 서비스에 걸쳐 있어서 이해하기가 어렵다
- 서비스 간 순환 의존성: 서로 이벤트를 구독하는 특성 상, 순환 의존성이 발생할 수 있다
- 단단히 결합될 위험성: 사가 참여자는 각자 자신에게 영향을 미치는 이벤트를 모두 구독해야한다. 다른서비스와 맞물려서 업데이트해야하는 위험성이 있다.(?)

### 오케스트레이션(ochestration) 사가
사가 오케티스트레이터가 참여자와 통신하면서 각 단계를 실행한다

주문 생성 사가 예시
- 예시
   ![그림4-6](/Images/%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%EC%84%9C%EB%B9%84%EC%8A%A4%ED%8C%A8%ED%84%B4/3-8.jpg)

사가 오케스트레이터를 상태 기계로 모델링
- 가능한 모든 시나리오를 기술하는 상태 기계로 사가를 모델링 하면 유용하다
- 상태기계: 상태(State)와 상태 전이(transition)으로 구성된다. 전이가 발생할 때마다 action이 일어난다.
- 주문 생성 사가의 상태 기계 모델링
   ![그림4-7](/Images/%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%EC%84%9C%EB%B9%84%EC%8A%A4%ED%8C%A8%ED%84%B4/3-8.jpg)

사가 오케스트레이션과 트랜잭셔널 메시징
- 서비스는 DB를 업데이트하고, 메시지를 발행하는 동작을 가진다
   - 예: 사가 참여자는 자신의 DB를 업데이트하고, 응답 메시지를 응답 채널로 보낸다. 
   - 예: 주문서비스는 사가 오케스트레이션 상태를 업데이트하고, 커맨드 메시지를 요청 채널로 보낸다. 
- DB 업데이트와 메시지 발행은 원자적으로 일어나야하기 때문에, 트랜잭셔널 메시지를 이용한다

장점
- 의존 관계 단순화: 오케스트레이터는 참여자를 호출하지만, 참여자는 오케스트레이터를 호출하지 않으므로 순환의존성이 발생하지 않는다
- 낮은 결합도: ?
- 관심사를 분리하고 이벤트 로직을 단순화: 사가 편성 로직이 오케스트레이터에만 있기 때문에, 도멘인 객체는 단순해진다. 

단점
- 오케스트레이터가 똑똑해지고, 깡통 서비스를 호출하는 일이 발생할 수 있다. 오케스트레이터는 순서화만 담당하고, 비지니스 로직은 갖고 있지 않도록 설계해야한다. 

## 비격리 문제 처리
격리성
- 동시에 실행중인 여러 트랜잭션의 결과가 어떤 순서대로 실행된 결과와 동일함을 보장하는 속성
- 사가에는 격리성이 빠져있다
   1. 한 사가가 실행 중에 접근하는 데이터를 도중에 다른 사가가 바꿔치기 할 수 있다
   2. 한 사가가 업데이트하기 전에 다른 사가가 이전 데이터를 읽어서 데이터 일관성이 깨질 수 있다
- ACD
   - 원자성(Atomic): 사가는 트랜잭션을 모두 완료하거나 모두 언두해야 한다
   - 일관성(Consistency): 서비스 내부의 참조 무결성은 로컬 DB가, 여러 서비스에 걸친 참조 무결성은 서비스가 처리한다
   - 지속성(Durability): 로컬 DB로 처리한다

### 비정상 개요
소실된 업데이트: 한 사가의 변경분을 다른 사가가 미쳐 못읽고 덮어 쓰는 경우
- 예시
   1. 주문 생성 사가 첫번째 단계에서 주문을 생성
   2. 사가 실행 중 주문 취소 사가가 주문을 취소
   3. 주문 생성 사가가 마지막 단계에서 주문을 승인
   4. 고객은 주문을 취소했지만, 음식을 배달받게 된다

더티 읽기: 사가가 업데이트하지 않은 변경분을 다른 트랜잭션이나 사가가 읽는 경우
- 예시: 주문 취소와 주문 생성이 같이 일어나고 있는데, 주문 취소가 롤백될 경우
   1. 주문 취소 사가: 신용 잔고를 늘린다. 0 -> 100
   2. 주문 생성 사가: 신용 잔고를 줄인다. 100 -> 0
   3. 주문 취소 사가 롤백: 신용 잔고를 줄이는 보상 트랜잭션이 발생한다. 0 -> -100

퍼지/반복 불가능한 읽기(fuzzy/nonrepeatable reads): 한 사가의 상이한 두 단계가 같은 데이터를 읽어도 결과가 달라지는 현상. 

### 비격리 대책
사가의 구조
- 보상 가능 트랜잭션(compensatable transaction)
   - 보상트랜잭션으로 롤백 가능한 트랜잭션
- 피봇 트랜잭션
   - 사가의 진행/중단 지점. 피봇 트랜잭션이 완료되면 사가는 완료될 때까지 실행된다
   - 예: 주문에서는 '카드 승인'이 피봇트랜잭션이다. 카드가 승인되면 이후 주문 승인 단계는 성공을 해야한다
- 재시도 가능 트랜잭션
   - 피봇 트랜잭션 이후의 트랜잭션. 단드시 성공한다. 

대책: 시맨틱 락
- 보상 가능 트랜잭션이 생성/수정하는 레코드에 플래그를 세팅하는 대책
- 플래그를 통해서 다른 트랜잭션이 레코드에 접근하지 못하게 하는 방법이며, '재시도 가능 트랜잭션' 또는 '보상 트랜잭션'에 의해서 해제된다
- 예: Order.state 필드
   - '*_PENDING' 상태로 시맨틱 락을 구현한다
   - 마지막 단계에서 'APPROVE' 또는 'REJECTED'로 반영된다
- 만약에 주문 진행중에 취소 요청이 온다면?
   1. 취소 요청을 실패 처리한다. 클라이언트에서 다시 호출한다
   2. 앞에 진행중인 사가 작업이 완료될 때까지, 취소 요청을 블로킹한다

대책: 교환적 업데이트
- 어떤 순서로도 실행 가능하도록 설계한다

대책: 비관적 관점
- 사가 사이에 순서를 조정해서 더티 읽기를 통한 위험성을 줄인다

대책: 값 다시 읽기
- 사가가 레코드를 업데이트하기 전에 다시 읽어서 중간에 값이 변경되지 않았는지 확인하는 방법
- 값이 변경되었다면 사가를 중단하고 나중에 재시작한다
- 예: 주문 승인 과정에서 주문이 취소된다면? -> 주문 승인 트랜잭션에서 주문이 이미 취소된 것을 확인해서 사가를 멈추고 보상트랜잭션을 가동한다

대책: 버전 파일
- 변경되는 레코드에 대해서 순서를 기록한다. 
- 서비스 참여자가 메시지를 처리할 때, 메시지의 순서가 달리 오는게 있으면, 기록해 두었다가 순서대로 실행하는 방법

## 주문 서비스 및 주문 생성 사가 설계
주문 서비스와 사가 설계
- 전체 구조
   ![그림4-9](/Images/%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%EC%84%9C%EB%B9%84%EC%8A%A4%ED%8C%A8%ED%84%B4/3-8.jpg)

OrderService
- 주문 생성/관리를 담당하는 도메인 서비스
- SagaManager를 이용해서 CreateOrderSaga와 같은 사가를 생성한다
- OrderService 사가
![그림4-11](/Images/%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%EC%84%9C%EB%B9%84%EC%8A%A4%ED%8C%A8%ED%84%B4/3-8.jpg)

주문 생성 사가
- CreateOrderSaga: 사가의 기계 상태를 정의한 싱글턴 클래스
   - CreateOrderSagaState를 이용해서 메시지를 생성하고, 참여자에게 메시지를 전달한다
   - SafaDefinition: 아래와 같이 단계별 동작과 메시지가 정의되어 있다
      ```java
      setep()
         .withCompensation(api, mssage)

      setep()
         .invokeParticipant(api, message)
      ```
- CreateOrderSagaState: 사가의 저장 상태. 커맨드 메시지를 생성한다
- 사가 참여자 프록시 클래스: 프록시 클래스마다 커맨드 채널, 커맨드 메시지 타입, 반환형으로 구성된 메시징 API를 구현한다

이벤트 발생
- OrderService가 주문생성 사가 인스턴스를 생성할 때 발생하는 이벤트
   ![그림4-13](/Images/%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%EC%84%9C%EB%B9%84%EC%8A%A4%ED%8C%A8%ED%84%B4/3-8.jpg)
- SagaManager가 사가 참여자의 응답 메시지를 수신할 때 발생하는 이벤트
   ![그림4-14](/Images/%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%EC%84%9C%EB%B9%84%EC%8A%A4%ED%8C%A8%ED%84%B4/3-8.jpg)