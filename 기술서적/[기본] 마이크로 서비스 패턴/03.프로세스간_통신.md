# 프로세스 간 통신
모놀리식 애플리케이션은 언어 수준의 메서드나 함수를 통해 호출되기 때문에 IPC는 크게 신경 쓸 필요가 없었다. 

## 마이크로서비스 아키텍처 IPC 개요
상호작용
- 일대일
   - 요청/응답
   - 비동기 요청/응답
   - 단방향 알림: 클라이언트는 서비스에 요청만하고, 서비스는 응답을 보내지 않는다
- 일대다
   - 발행/구독: 클라이언트가 알람 메시지를 발행하고, 관심있는 0개 이상의 서비스가 메시지를 소비한다
   - 발행/비동기 응답: 클라이언트가 요청메시지를 발행하고, 주어진 시간동안 응답이 오기를 기다린다
- 동기
- 비동기

API 발전
- 시맨틱 버저닝
   - MAJOR: 하위 호환되지 않는 변경을 반영
   - MINOR: 하위 호환되는 변경을 반영
   - PATCH: 하위 호환되는 오류 수정
- 변경을 하더라도 하위 호환을 보장하는 방향으로 변경한다
- 하위 호환이 되지 않는다면, 일정 시간동안은 신/구 API를 모두 유지해야한다
   - REST API라면 URL에 메이저 버전 번호를 붙일 수 있다. 예: /v1/, /v2/

메시지 포맷
- 텍스트: JSON, XML 등. 메시지가 긴 담점
- 이진 메시지: 컴파일러가 메시지를 직렬화/역질렬화하는 코드를 생성한다. 프로토콜 버퍼, 아브로가 유명하다

## 동기 RPI 패턴
RPI는 클라이언트가 서비스에 요청을 보내면 서비스가 처리후 응답을 회신하는 IPC. 

REST
- 장점
   - 단순하고 익숙하다
   - curl, 포스트맨 등으로 간단히 API를 테스트할 수 있다
   - 요청/응답 스타일의 통신을 지원한다
   - 방화벽 친화적이다 (단일 포트 사용, 인터넷에서 서버 접속 가능, TCP를 사용한다) 
   - 중간 브로커가 필요하지 않아서 아키텍처가 단순해진다
- 단점
   - 요청/응답 스타일만 지원한다
   - 가용성이 떨어진다. 중간 매개체가 없어서 양쪽이 모두 실행중이어야한다
   - 서비스 URL을 알고 있어야한다
   - 하나의 요청으로 여러 리소스를 가져오기가 어렵다
   - 다중 업데이트 작업을 HTTP 동사에 매핑하기 어려울때가 많다

gRPC
- 특징
   - 다양한 언어로 클라이언트/서버를 작성할 수 있다 (https://en.wikipedia.org/wiki/Remote_procedure_call)
   - 메시지기반 프로토콜이라서 API 우선 방식으로 설계해야한다
- 장점
   - 큰 메시지를 교환할 때 컴팩트하고 효율적이다
   - 양방향 스트리밍 때문에 RPI, 메시징 두가지를 모두 지원
- 단점
   - 구형 방화벽이 HTTP2를 지원하지 않을 수 있다

회로 차단기
- 연속 실패 횟수가 주어진 임계치를 초과하면 일정 시간동안 호출을 즉시 거부하는 RPI 프록시
- 견고한 RPI 프록시 설계
   - 네트워크 타임아웃을 설정
   - 미처리 요청(outstanding request) 개수 제한: 클라이언트가 특정 서비스에 요청 가능한 미처리 요청의 최대 개수를 설정. 이 개수에 다다르면 더이상의 요청은 무의미하므로 즉시 실패한다
   - 회로차단기 패턴
- 여러 서비스를 비동기로 호출하는 과정에서 중요하지 않은 서비스가 동작하지 않을 경우에는, 앞단에서 폴백 값이나 정해진 응답의 캐시를 리턴하는 방법도 있다. 
   ![3-3](/Images/%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%EC%84%9C%EB%B9%84%EC%8A%A4%ED%8C%A8%ED%84%B4/3-3.jpg)

서비스 디스커버리
- 서비스 인스턴스의 위치를 레지스트리에 저장한다
- 패턴
   - 자가등록: 서비스가 직접 레지스트리에 자기자신을 등록 (예: 스프링 클라우드 유레카)
   - 서드파티 등록: 서드파티가 인스턴스를 레시지스트리에 등록 (예: 쿠버네티스)

## 비동기 메징 패턴
비동기 패턴은 클라이언트의 응답을 기다리며 블로킹하지 않는다. 클라이언트는 응답을 하지 못할 것이라는 전제하에 작성한다. 

메시지
- 구성
   - 헤더: 메타데이터, 메시지 ID, 콜백 주소 등
   - 본문: 송신할 이진 또는 텍스트 형식의 데이터
- 종류
   - 문서: 데이터만 포함된 제네릭한 메시지. 예: 커맨드에 의한 응답
   - 커맨드: RPC 요청과 동등한 메시지. 호출할 작업과 매개변수를 가진다
   - 이벤트: 송신자에게 어떤 사건이 발생했음을 알리는 메시지. 주로 도메인 객체의 상태 변경을 나타내는 도메인메시지

메시지 채널
- 구성
   ![3-7](/Images/%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%EC%84%9C%EB%B9%84%EC%8A%A4%ED%8C%A8%ED%84%B4/3-7.jpg)
- 종류
   - 점대점(point-to-point) 채널: 하나의 컨슈머에게 메시지를 전달. 예: 커맨드
   - 발행-구독(publish-subscribe) 채널: 예: 이벤트

메시지 상호 작용
- 비동기 메시지 응답/요청
   - 한쌍의 메시지를 주고 받는 요청/응답 스타일로 등록
      ![3-8](/Images/%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%EC%84%9C%EB%B9%84%EC%8A%A4%ED%8C%A8%ED%84%B4/3-8.jpg)
- 단방향 알림
   - 소비자가 소유한 점대점 채널로 커맨드 메시지를 보내는 방법
- 발행/구독
   - 여러 컨슈머가 읽는 발행/구독 채널에 메시지를 발행
   - 주로 도메인 이벤트이며, 도메인 클래스의 이름을 딴 채널에 발행한다
- 발행/비동기 응답
   - 발행/구독 방법을 이용해서 컨슈머에게 메시지를 발행
   - 컨슈머는 지정된 응답 채널에 메시지를 작성한다

비동기 API 명세 
   - 메시지 채널명, 메시지 타입 & 포멧을 기술해야한다. 
   - 요청 비동기 응답 스타일 API
      - 서비스의 커맨드 채널, 커맨드 메시지의 타입과 포멧
      - 서비스가 반환하는 응답 메시지의 타입과 포멧
   - 단방향 알림 스타일 API
      - 서비스의 커맨드 채널, 커맨드 메시지의 타입과 포멧

메시지 브로커
- 브로커리스 메시징
   - 메시지를 서비스들끼리 직접 교환하는 방법
   - 장점
      - 브로커를 통하지 않기 때문에 네트워크 트래픽이 가볍고 지연 시간이 짧다
      - 브로커가 없기 때문에, SPOF가 될 가능성이 없고, 관리 포인트가 줄어든다
   - 단점
      - 메시지 교환시 송신자/수신자가 모두 실해 중이어야 한다
      - 서비스 디스커버리를 구현해야 한다 (위치를 알아야하기 때문에)
      - 전달 보장 매커니즘을 구현하기가 어렵다
- 브로커기반 메시징
   - 메시지브로커가 중간에서 메시지를 컨트롤 하는 방법
   - 종류
      - ActiveMQ
      - RabiitMQ
      - Kafka
      - Kinesis, SQS
   - 검토 사항
      - 프로그래밍 언어 지원 여부
      - 메시지 표준 지원 여부: AMQP, STOMP 등 표준 프로토콜을 지원하는 제품인가? 아니면 자체 표준만 지원하는 제품인가?
      - 메시지 순서: 메시지의 순서 보장이 되는가?
      - 전달 보장: 어떤 종류의 전달 보장을 하는가?
      - 영속화: 브로커가 고장나도 문제가 없도록 메시지를 디스크에 저장하는가?
      - 내구성: 컨슈머가 메시지브로커에 다시 접속할 경우, 접속이 중단된 시간에 전달된 메시지를 받을 수 있는가?
      - 확장성
      - 지연시간: 종단간 지연시간
      - 경쟁사 컨슈머: 지원 여부
   - 장점
      - 느슨한 결합. 브로커를 통하므로 디스커버리 매커니즘도 필요없다
      - 메시지 버퍼링: 브로커가 처리 가능한 시점까지 메시지를 버퍼링한다. 컨슈머가 항상 가동중이 아니어도 된다
      - 명시적 IPC: ??
   - 단점
      - 성능 병목: 브로커가 성능 병목이 될 수 있다
      - 단일 장애점
      - 운영 복잡도 부가

수신자 경합과 메시지 순서 유지
- 순서 보장을 위해서 브로커는 샤딩된 채널을 이용한다
   - 송신자는 샤드키를 이용해서 특정 파티션에 배정하는 방식
   - 카프카를 기준으로, 파티션으로 토픽을 분리하고, 메시지키를 해싱해서 각 토픽에 분배되는 개념을 생각하면 된다
   ![3-11](/Images/%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%EC%84%9C%EB%B9%84%EC%8A%A4%ED%8C%A8%ED%84%B4/3-11.jpg)

중복 메시지 처리
- 메시지 브로커는 보통 '적어도' 한번 이상 메시지를 전달한다는 것을 약속한다. 중복 메시지가 전달 될 수 있다.
- 해결 법
   - 멱등한 메시지 핸들러를 작성
      - 멱등하다: 동일한 입력 값을 반복 호출해도 아무런 부수 효과가 없는 상태
   - 중복을 솎아 낼 수 있도록 개발한다
      - 메시지 핸들러와 같은 트랜잭션에서, 메시지 ID를 DB에 저장해서 이미 처리된 것인지 확인한다

트랜잭셔널 메시징
- DB 업데이트와 메시지 전송이 같은 트랜잭션에 없다면, DB는 업데이트 되었는데 메시지 전송이 안되는 등의 문제가 발생할 수 있다
- 트랜잭션 메시지 처리: DB 테이블을 메시지 큐로 활용
   - 예: 트랜잭셔널 아웃박스 패턴
   ![3-11](/Images/%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%EC%84%9C%EB%B9%84%EC%8A%A4%ED%8C%A8%ED%84%B4/3-11.jpg)
- 이벤트 발행
   - 폴링 발행기 패턴: 폴링을 통해서 메시지에서 발행되지 않은 메시지를 가져와서 브로커로 보내고, 삭제하는 작업
   - 트랜잭션 로그 테일링 패턴: DB 트랜잭션 로그를 테일링하는 방법

## 비동기 메시징으로 가용성 개선
동기 메시징으로 인한 가용성 저하
- REST의 경우는 대중적인 IPC이지만, 동기 통신이라는 단점이 있다.
   - 연관된 서비스가 모두 가동 중이어야한다

비동기 상호 작용 스타일
- 메시지 요청/응답 채널을 이용해서 비동기 상호작용을 하는 방법. eventually consistency를 적용
   ![3-16](/Images/%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%EC%84%9C%EB%B9%84%EC%8A%A4%ED%8C%A8%ED%84%B4/3-16.jpg)

데이터 복제
- 다른 서비스의 데이터를 변경 이벤트를 기준으로 내 서비스에 저장하는 방법
- 복제 데이터를 가지고 있기 때문에 해당 서비스를 호출할 필요가 없어진다

응답 반환 후 마무리
- 클라이언트로 부터 받은 동기 요청에 대해서 최소한의 처리 후 응답을 하고, 이후에 타 서비스와 연동을 이어가는 방식
   - 최소한의 처리이기 때문에 이때의 처리 상태는 PENDING같은 처리중인 상태로 응답하게 된다
- 타 서비스와의 연동은 비동기 방식으로 처리한다
   - 이 과정에서 각 서비스에서 받은 응답을 기준으로 상태를 업데이트한다
   - 메시지를 이용한 통신이기 때문에 나중에 타 서비스가 내려갔다가 올라와도 메시지를 소비하면서 내용을 처리할 수 있는 장점이 있다
- 클라이언트의 구현이 조금 복잡해진다
   - 예를 들어 주문 생성이라고 할 때, 처음 응답은 최소한의 주문 데이터만 가지고있다. 
   - 변경되는 데이터를 알아내려면 주기적으로 폴링하거나 알람 메시지를 전달해야한다. 

