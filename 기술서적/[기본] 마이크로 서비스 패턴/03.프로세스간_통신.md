# 프로세스 간 통신
모놀리식 애플리케이션은 언어 수준의 메서드나 함수를 통해 호출되기 때문에 IPC는 크게 신경 쓸 필요가 없었다. 

## 마이크로서비스 아키텍처 IPC 개요
상호작용
- 일대일
   - 요청/응답
   - 비동기 요청/응답
   - 단방향 알림: 클라이언트는 서비스에 요청만하고, 서비스는 응답을 보내지 않는다
- 일대다
   - 발행/구독: 클라이언트가 알람 메시지를 발행하고, 관심있는 0개 이상의 서비스가 메시지를 소비한다
   - 발행/비동기 응답: 클라이언트가 요청메시지를 발행하고, 주어진 시간동안 응답이 오기를 기다린다
- 동기
- 비동기

API 발전
- 시맨틱 버저닝
   - MAJOR: 하위 호환되지 않는 변경을 반영
   - MINOR: 하위 호환되는 변경을 반영
   - PATCH: 하위 호환되는 오류 수정
- 변경을 하더라도 하위 호환을 보장하는 방향으로 변경한다
- 하위 호환이 되지 않는다면, 일정 시간동안은 신/구 API를 모두 유지해야한다
   - REST API라면 URL에 메이저 버전 번호를 붙일 수 있다. 예: /v1/, /v2/

메시지 포맷
- 텍스트: JSON, XML 등. 메시지가 긴 담점
- 이진 메시지: 컴파일러가 메시지를 직렬화/역질렬화하는 코드를 생성한다. 프로토콜 버퍼, 아브로가 유명하다

## 동기 RPI 패턴
RPI는 클라이언트가 서비스에 요청을 보내면 서비스가 처리후 응답을 회신하는 IPC. 

REST
- 장점
   - 단순하고 익숙하다
   - curl, 포스트맨 등으로 간단히 API를 테스트할 수 있다
   - 요청/응답 스타일의 통신을 지원한다
   - 방화벽 친화적이다 (단일 포트 사용, 인터넷에서 서버 접속 가능, TCP를 사용한다) 
   - 중간 브로커가 필요하지 않아서 아키텍처가 단순해진다
- 단점
   - 요청/응답 스타일만 지원한다
   - 가용성이 떨어진다. 중간 매개체가 없어서 양쪽이 모두 실행중이어야한다
   - 서비스 URL을 알고 있어야한다
   - 하나의 요청으로 여러 리소스를 가져오기가 어렵다
   - 다중 업데이트 작업을 HTTP 동사에 매핑하기 어려울때가 많다

gRPC
- 특징
   - 다양한 언어로 클라이언트/서버를 작성할 수 있다 (https://en.wikipedia.org/wiki/Remote_procedure_call)
   - 메시지기반 프로토콜이라서 API 우선 방식으로 설계해야한다
- 장점
   - 큰 메시지를 교환할 때 컴팩트하고 효율적이다
   - 양방향 스트리밍 때문에 RPI, 메시징 두가지를 모두 지원
- 단점
   - 구형 방화벽이 HTTP2를 지원하지 않을 수 있다

회로 차단기
- 연속 실패 횟수가 주어진 임계치를 초과하면 일정 시간동안 호출을 즉시 거부하는 RPI 프록시
- 견고한 RPI 프록시 설계
   - 네트워크 타임아웃을 설정
   - 미처리 요청(outstanding request) 개수 제한: 클라이언트가 특정 서비스에 요청 가능한 미처리 요청의 최대 개수를 설정. 이 개수에 다다르면 더이상의 요청은 무의미하므로 즉시 실패한다
   - 회로차단기 패턴
- 여러 서비스를 비동기로 호출하는 과정에서 중요하지 않은 서비스가 동작하지 않을 경우에는, 앞단에서 폴백 값이나 정해진 응답의 캐시를 리턴하는 방법도 있다. 
   ![3-3](/Images/%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%EC%84%9C%EB%B9%84%EC%8A%A4%ED%8C%A8%ED%84%B4/3-3.jpg)

서비스 디스커버리
- 서비스 인스턴스의 위치를 레지스트리에 저장한다
- 패턴
   - 자가등록: 서비스가 직접 레지스트리에 자기자신을 등록 (예: 스프링 클라우드 유레카)
   - 서드파티 등록: 서드파티가 인스턴스를 레시지스트리에 등록 (예: 쿠버네티스)

   