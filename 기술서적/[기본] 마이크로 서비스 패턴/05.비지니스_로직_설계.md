# 비지니스 로직 설계
마이크로서비스에서 비지니스 로직을 개발하기 어려운 이유
1. 도메인 모델은 상호 연관된 클래스가 뒤얽혀 있는데, 클래스가 여러 서비스에 산재된 마이크로서비스 아키텍처에서는 서비스 경계를 넘나드는 객체 레퍼런스를 제거해야한다
2. 마이크로서비스의 트랜잭션 제약조건 하에서도, 작동하는 비지니스 로직을 만들어야한다
   - 4장의 사가패턴을 이용해서 해결할 수 있다

DDD 애그리거트 패턴
- 애그리거트: 한 단위로 취급 가능한 객체를 모아놓은것
- 마이크로서비스 아키텍처에서 애그리거트가 좋은 이유
   - 객체 레퍼런스가 서비스 경계를 넘나들 일이 없다. 다른 서비스의 레퍼런스는 기본키(P.K)를 이용해서 참조한다
   - 애그리거트의 생성/수정이 트랜잭션의 단위이기 때문에, 마이크로서비스 아키텍처의 트랜잭션 제약조건에 잘 맞는다
- DDD 패턴
   ```
   전략적 패턴 (https://thedomaindrivendesign.io/what-is-strategic-design/)
   - Bounded Context, Uniquitous Lanaguges, Context Maps
   전술적 패턴 (https://thedomaindrivendesign.io/what-is-tactical-design/)
   - Entities, Value Objects, Aggregates, Services, Repositories, Factories, Events
   ```

이 장에서는 아래의 내용을 알아봅니다
- DDD 애그리거트 개념 소개
- 왜 애그리거트가 비지니스 로직을 구축하는데 적합한지
- 도메인 이벤트 패턴 소개
- 왜 도메인 이벤트 패턴이 유용한지

## 비지니스 로직 구성 패턴
비지니스 로직을 구성할 때, 사용할 수 있는 패턴을 소개

예: 주문 서비스 아키텍처 구성 (비지니스 로직의 위치, 중요성을 설명하기 위한 예시)
![5-1](/Images/%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%EC%84%9C%EB%B9%84%EC%8A%A4%ED%8C%A8%ED%84%B4/5-1.png)
- 육각형 아키텍처
   - 비지니스 로직: 중앙에 위치
   - 포트: 비지니스 로직을 끝점에서 비지니스 로직을 보호한다
   - 어댑터: 포트를 구현 또는 호출
      - 인바운드 어댑터
         - REST API 어댑터: 비지니스 로직을 호출하는 REST API가 구현된 어댑터
         - OrderCommandHandler: 메시지 채널을 통해서 들어온 커맨드 메시지를 받아서 비지니스 로직을 호출
      - 아운바운드 어댑터
         - DB 어댑터: DB 접근을 위해서 호출하는 어댑터
         - 도메인 이벤트 발행 어댑터: 이벤트를 메시지 브로커에 발행하는 아웃바운드 어댑터

### 비지니스 로직 설계: 트랜잭션 스크립트 패턴
개념
- 객체지향 설계를 하지 않고, 절차적으로 하나의 메서드에서 트랜잭션을 처리하는 동작을 수행하는 방법
- Patterns of Enterprise Application Architecture, Matrin Fowler
   ```
   Most business applications can be thought of as a series of transactions. A transaction may view some information as organized in a particular way, another will make changes to it. Each interaction between a client system and a server system contains a certain amount of logic. In some cases this can be as simple as displaying information in the database. In others it may involve many steps of validations and calculations.

   A Transaction Script organizes all this logic primarily as a single procedure, making calls directly to the database or through a thin database wrapper. Each transaction will have its own Transaction Script, although common subtasks can be broken into subprocedures.
   ```
- 단순한 비지니스 구조에 적합하다. (반대로는 비지니스 로직이 복잡해지면 관리가 어려워진다)

구조
![5-2](/Images/%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%EC%84%9C%EB%B9%84%EC%8A%A4%ED%8C%A8%ED%84%B4/5-2.png)

### 비지니스 로직 설계: 도메인 모델 패턴
개념
- 객체 지향적으로 비지니스 로직을 설계한다. 비교적 작은 클래스가 그물망처럼 얽히게 된다.
   ```
   객체 지향적: 오브책트 책에서는 '객체간의 협력'으로 설명
   ```
- 각각의 객체 모델 클래스 상태와 동작을 모두 가지고, 문제 영역에 직접 대응한다.
- 객체 클래스에 비지니스 로직이 있기 때문에, 서비스 로직(이 단순해진다(DB 저장, 비지니스 로직 호출).

이점
- 소수의 책임을 맡은 여러 클래스로 구성되기 때문에 설계를 이해하기 쉽다
- 테스트하기 쉽다. (_클래스가 작어지고, 개별책임을 가지고 있기 때문인듯_)
- 잘 알려진 설계 패턴(예: 전략패턴, 템플릿 메서드 패턴)을 응용할 수 있기 때문에 확장하기 쉽다

하지만 '도메인 모델 패턴' 만으로는 마이크로서비스 아키텍처에서의 문제를 해결할 수 없기 때문에 `DDD`가 필요하다

### 도메인 주도 설계 (DDD) 개요
DDD
- '[Domain-Driven Design](http://www.yes24.com/Product/Goods/5312881)', 2003, 에릭에반스
- 복잡한 비지니스 로직을 개발하기 위한 접근 방식
   - DDD를 사용하면 각 서비스가 자체의 도메인 모델을 가지게 되고, 도메인 모델 하나가 애플리케이션 전반에 사용되는 문제를 피할 수 있습니다.(problems of a single, application-wide domain model)

DDD에서 도메인 모델 구축에 사용되는 빌딩 블록. (전술적 패턴))
- 엔티티: 영속성을 가진 객체. 고유한 ID를 가진다. 두 엔티티의 속성값이 동일해도 ID가 다르면 다른 객체이다. 
- 밸류 객체: 여러 값을 모아 놓은 객체. 속성이 같은 2개의 밸류 객체는 서로 바꾸어 사용할 수 있다. 예: Money, Address
- 팩토리: 일반 생성자로 직접 만들기에 복잡한 객체 생성 로직이 구현된 객체 또는 메서드. 도메인 로직이 들어갈 수 있기 때문에 생성 시 조심해야 한다. 
- 리포지토리: 엔티티를 저장하는 DB 접근 로직을 캡슐화한 객체
- 서비스: 엔티티, 밸류 객체에 속하지 않은 비지니스 로직 구현 객체
   - application service: 도메인로직은 없고, Presentation 계층과 Domain 계층을 연결하는 파사드 역할. 트랜잭션 관리
   - domain service: 비지니스 로직 구현 과정에서 1개 애그리거트로 다 처리가 어려운 로직을 domain 서비스에서 구현
- 애그리거트

전략적 패턴
- 바운디드 컨텍스트: 도메인 모델의 경계
- 유비쿼터스 언어: 도메인 내에서 사용되는 언어. 유비쿼터스 언어로 이야기한다. 
- 컨텍스트 맵: 바운디드 컨텍스트 사이의 연관관계를 정의

## 도메인 모델 설계: DDD 애그리거트 패턴
### 불분명한 경계 문제
전통적인 도메인 모델 예시
- ![5-4](/Images/%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%EC%84%9C%EB%B9%84%EC%8A%A4%ED%8C%A8%ED%84%B4/5-4.png)
- 경계가 명확하지 않은 문제
   - 경계가 명확하지 않으면 비지니스 로직에서 객체를 업데이트 할 때 문제가 발생할 수 있다. (주로 일관성이 깨질 수 있다)
   - 예: Order에 어떤 변경이 발생했을 때, 영향을 주는 범위가 어디까지 인지 명확하지 않다
   - 예: 최소 주문량 충족 이슈
      - 상황
         - 2개의 컨슈머(샘, 메리)가 동시에 주문을 하는 상황
         - 예산 문제로 각자 자신이 주문한 품목의 수량을 줄이는데, 이 과정에서 최소 주문량이 깨질 수 있는 문제가 있다
         ![5-1-ex](/Images/%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%EC%84%9C%EB%B9%84%EC%8A%A4%ED%8C%A8%ED%84%B4/5-1-ex.png)
      - 해결: Version이 Order에 있어야하지 않을까?

### 애그리거트는 경계가 분명하다
애그리거트
- 한 단위로 취급 가능한 경계 내부의 도메인 객체들
- 하나의 루트 엔티티와 하나 이상의 '기타 엔티티' + '밸류 객체'로 구성된다
- 작업은 애그리거트 일부가 아닌 전체 애그리거트에 작용한다
   - 작업의 호출은 애그리거트 루트를 통해서 호출된다.
   - 애그리거트 루트에 잠금이 적용된다. 
   - 일관성 문제를 해소할 수 있다

전통적인 도메인 모델을 애그리거트로 구분
- ![5-5](/Images/%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%EC%84%9C%EB%B9%84%EC%8A%A4%ED%8C%A8%ED%84%B4/5-5.png)
   

__DDD 도메인 모델 설계의 핵심은 애그리거트와 그 경계, 그리고 루트를 식별하는 것이다.__



기타
- https://youtu.be/QUMERCN3rZs
