# 2. 분해전략
## 아키텍처 스타일
아키텍처의 중요성
- 애플리케이션의 서비스 품질 요건을 충족시킬 수 있도록 한다
- 예: 확장성, 신뢰성 등

아키텍처 스타일
- 계층화 아키텍처 스타일
- 육각형 아키텍처 스타일
   - 비지니스 로직이 어댑터에 의존하지 않는다
   - 포트를 이용해서 외부 서비스와 상호작용한다
- 마이크로서비스 아키텍처
   - 서비스: 어떤 기능이 구현되어 단독 배포가 가능한 소프트웨어 컴포넌트
      - 서비스는 클라이언트가 자신이 서비스하는 기능에 접근할 수 있도록 커맨드,쿼리,이벤트로 구성된 API를 제공한다
      ![2-4](/Images/%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%EC%84%9C%EB%B9%84%EC%8A%A4%ED%8C%A8%ED%84%B4/2-4.jpg)
   - 느슨한 결합
      - 유지보수성, 테스트성을 높이고, 개발시간을 단축한다
      - 개발자가 서비스를 이해하기 쉽다
      - DB를 공유하지 않고 API를 통해서 통신하며, 이때문에 여러 서비스에 걸쳐서 데이터를 쿼리하고 일관성을 유지하는 작업은 복잡해질 수 있다
   - 크기
      - 코드의 크기 보다는, 작은 팀이 가장 짧은 시간에, 다른팀과 협동하는 부분을 취소로해서 개발가능한 서비스를 설계해야한다
      - 배포성이 올라간다

## 마이크로서비스 정의
### 1. 시스템 작업 식별
1. 사용자 스토리를 작성해서 기능 요건을 정의한다
2. 도메인 모델 생성
   - 도메인 모델은 사용자 스토리의 명사에서 도출한다
   ![p82](/Images/%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%EC%84%9C%EB%B9%84%EC%8A%A4%ED%8C%A8%ED%84%B4/p_82.jpg)
3. 시스템 작업 정의
   - 애플리케이션이 어떤 작업을 처리할지 식별하는 과정으로 커맨드와 쿼리로 크게 나뉜다
      - 커맨드: 데이터 생성, 수정, 삭제
      - 쿼리: 데이터 읽기
      ![t2-1](/Images/%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%EC%84%9C%EB%B9%84%EC%8A%A4%ED%8C%A8%ED%84%B4/t_2-1.jpg)

### 2. 서비스 정의
비지니스 패턴별 분해
- 비지니스 객체에 집중해서, 능력을 구분한다. 상위능력이 있고 그 아래 하위 능력이 있다. 
- 비지니스 능력을 식별하고, 연관된 그룹에 따라서 서비스를 정의한다. 
   ![2-8](/Images/%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%EC%84%9C%EB%B9%84%EC%8A%A4%ED%8C%A8%ED%84%B4/2-8.jpg)
- 서비스를 거의 변하지 않는 비지니스 능력에 따라 구성하면, 비굑적 안정적인 아키텍처를 구성할 수 있다. 

하위 도메인 패턴별 분해
- DDD는 도메인 내부에서 문제 해결이 가능한 형태로 도메인을 모델링하는 기법
   - 도메인을 구성하는 각 하위 도메인마다 도메인 모델을 따로 정의한다. (비지니스 능력과 비슷하게 도메인이 도출된다)
- 마이크로서비스에 DDD를 적용하면 각 서비스들이 바운디드컨텍스트가 된다

분해지침
- SRP, 단일 책임 원칙: 클래스는 오직 하나의 변경 사유를 가져야한다
- CCP, 공동 폐쇄 원칙: 어떤 두 클래스가 동일한 사유로 맞물려 변경되면, 동일한 패키지에 있어야한다

서비스 분해의 장애물
- 네트워크 지연
- 동기 IPC로 인한 성능저하
   - 메시징 방법으로 가용성을 높이는 방법이 있다
- 여러 서비스에 데이터 일관성 유지
   - 사가 방식을 사용. (최종일관성, eventual consistency를 보장)
- 일관된 뷰 확보
- __만능 클래스__
   - 애플리케이션의 여러 측면에 대한 비지니스 로직이 존재한다
   - DDD를 적용하고, 각 서비스를 자체 도메인 모델을 갖고 있는 개별 하위 도메인으로 취급하는 방법
      - FTGO의 경우, 주문과 조금이라도 연관된 서비스는 모두 각자 버전의 Order클래스를 가진 도메인 모델을 따로 두는 방법
      - 배달서비스에서는 Delivery라는 모델을 사용해서 구현, 주방 서비스에서는 Ticket이라는 이름으로 구현될 수 있다
      - __각 도메인 모델의 Order 클래스는 Order라는 동일한 비지니스 엔티티의 상이한 측면을 나타낸다__

### 3. 서비스 API 정의
시스템 작업을 서비스로 배정
- 시스템 작업을 어느 서비스에 매핑할지를 정한다
   예: crateOrder() -> 주문 서비스, findAvailableRestaurants() -> 음식점 서비스

서비스간 협동 지원에 필요한 API 확정
- 예를 들어서 createOrder()는 '소비자서비스', '음식점서비스', '주방서비스', '회계서비스'를 호출해야한다