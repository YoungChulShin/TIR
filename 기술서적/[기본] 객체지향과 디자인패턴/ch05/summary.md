# 설계 원칙: SOLID
## 단일 책임 원칙(SRP, Single Responsibility Principle)
클래스는 단 한개의 책임을 가져야한다. 클래스가 여러 책임을 갖게되면 각 책임마다 변경되는 이유가 발생하기 때문에, 클래스가 한 개의 이유로만 변경되려면 클래스는 한 개의 책임만을 가져야한다. 

단일 책임을 어떻게하면 지킬 수 있을까?
- 메서드를 실행하는 것이 누구인지 확인해보는 것이다. 서로 다른 클라이언트에서 서로 이유로 같은 클래스를 참조한다면 각각의 책임을 가지고 있을 가능성이 높다.

## 개방 폐쇄 원칙 (OCP, Open-Closed Principle)
확장에는 열려 있어야하고, 변경에는 닫혀 있어야한다.
- 기능을 변경하거나 확장할 수 있으면서, 그 기능을 사용하는 코드는 수정하지 않는다

인터페이스를 이용한 추상화를 이용하면 클라이언트 입장에서는 추장클래스를 사용하면서 변화에 변경되는 않도록 할 수 있고, 추상 클래스의 구현체를 다양화 함으로써 확장에는 열려있도록 할 수 있다.

상위 클래스에서 instanceof와 같은 타입 확인 연산자가 사용되거나, 비슷한 if-else 블록이 존재한다면 의심을 해봐야한다. 

개방 폐쇄 원칙은 변경의 유연함과 관련된 원칙이다. 만약 기존 기능을 확장하기 위해 기존 코드를 수정해 주어야 한다면, 새로운 기능을 추가하기가 점점 어려워진다. 이 경우 변화되는 부분을 __추상화함으로써 사용자 입장에서 변화를 고정시키는__ 방법을 사용해보자. 

## 리스코프 치환 원칙(LSP, Liskov Substitution Principle)
상위 타입의 객체를 하위 타입의 객체로 치환해도 상위 타입을 사용하는 프로그램은 정상적으로 동작해야한다. 

하위 타입이 명세에서 벗어난 동작을 하게 되면, 이 명세에 기반해서 구현한 코드는 (클라이언트 입장에서) 비정상적으로 동작할 수 있기 때문에, 하위 타입은 상위 타입에서 정의한 명세를 벗어나지 않는 범위 내에서 구현해야 한다. 
- 명세에서 벗어난 값을 리턴한다
- 명세에서 벗어난 익셉션을 발생한다
- 명세에서 벗어난 기능을 수행한다

타입을 확인하는 기능을 사용한다는 것은 전형적인 리스코프 치환 원칙을 위반하는 것이다. 클라이언트가 타입 확인 연산자를 사용한다는 것은 상위 타입만을 이용해서 프로그래밍할 수 없다는 것을 뜻하며, 이는 하위 타입이 상위 타입을 대체할 수 없다는 것을 의미한다. 이는 새로운 하위 타입이 추가되면 상위 타입을 사용하는 코드를 수정해줘야하는 것인데, OCP을 지킬 수 없게 만든다. 

## 인터페이스 분리 원칙(ISP, Interface Segregation Principle)
인터페이스는 그 인터페이스를 사용하는 클라이언트를 기준으로 분리해야한다

클라이언트 입장에서 사용하는 기능만 제공하도록 인터페이스를 분리함으로써 한 기능에 대한 변경의 여파를 최소하할 수 있게 된다. 

SRP가 잘 지켜질 때 인터페이스와 콘트리트 클래스의 재사용 가능성을 높일 수 있으므로 ISP는 결국 인터페이스와 콘크리트 클래스의 재사용성을 높여주는 효과도 갖는다. 

## 의존 역전 원칙(DIP, Dependency Inversion Principle)
고수준 모듈은 저수준 모듈의 구현에 의존해서는 안 된다. 저수준 모듈이 고수준 모듈에서 정의한 추상타입에 의존해야한다. 
- 고수준 모듈: 어떤 의미있는 단일 기능을 제공하는 모듈. 예: 데이터를 조회한다
- 저수준 모듈: 고수준 모듈의 기능을 구현하느기 위해 필요한 하위 기능의 실제 구현. 예: MySQL DB에서 데이터를 조회한다, InMemory에서 데이터를 조회한다

DIP를 사용하면 컴파일 타임의 의존성은 역전되지만 런타임 의존성은 고수준 모듈이 저수준 모듈을 향하게 된다.
- 런타임 시점에는 추상타입에 확장한 구현체 클래스가 들어올 것이기 때문에 당연하다