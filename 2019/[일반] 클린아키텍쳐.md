기간 
- 시작: 2019.12.03 
- 종료: 

소감
- TBD
---
# 서문
소프트웨어 아키텍처의 규칙이란 프로그램의 구성요소를 정렬하고 조립하는 방법에 관한 규칙이다. 그리고 이 구성요소가 보편적이며 변하지 않았으므로, 이들을 정렬하는 규칙 역시도 보편적이며 변한 것이 없다. 

## 1장. 설계와 아키텍처란?
소프트웨어 아키텍처의 목표는 필요한 시스템을 만들고 유지보수하는 데 투입되는 인력을 최소화 하는데 있다.<br>
설계 품질을 재는 척도는 고객의 요구를 만족시키는 데 드는 비용을 재는 척도와 다름없다. 

개발자는 "코드는 나중에 정리하면 돼. 당장은 시장에 출시하는 게 먼저야!"라는 흔해 빠진 거짓말에 속는다. 이렇게 속아 넘어간 개발자라면 나중에 코드를 정리하는 경우는 한 번도 없는데, 시장의 압박은 절대로 수그러들지 않기 때문이다. '시장 출시가 먼저'라는 생각을 하는 이유는 바로 뒤에 여러 무리의 경쟁자가 뒤쫓고 있고, 경쟁자보다 앞서 가려면 가능한 한 빠르게 달려야 하기 때문이다.<br>
결국 개발자는 절대로 태세를 전환하지 않는다. 이전에 작성한 코드로 돌아가 정리하는 일은 일어나지 않는데, 바로 다음에 만들어야 할 새로운 기능이 기다리고 있고, 다음 기능, 또 다음 기능, 또 다음 기능이 계속 기다리고 있기 때문이다. 결국 엉망진창이 되고, 생산성은 0을 향해 수렴하기 시작한다. 

빨리 가는 유일한 방법은 제대로 가는 것이다.<br>
자신을 과신한다면 재설꼐 하더라도 원래의 프로젝트와 똑같이 엉망으로 내몰린다.
- _어떤 아키텍쳐가 좋은지 모른다면, 다시 설계해도 동일한 결과가 나온다_

## 2장. 두 가지 가치에 대한 이야기
모든 소프트웨어 시스템은 이해관계자에게 서로 다른 두 가지 가치를 제공하는데, 행위(behavior)와 구조(structure)가 바로 그것이다. 소프트웨어 개발자는 두 가치를 모두 반드시 높게 유지해야 하는 책임을 진다. 불행하게도 개발자는 한가지 가치에만 집중하고 나머지 가치를 배제하곤 한다. 

소프트웨어가 가진 본연의 목적을 추구하려면 소프트웨어는 반드시 '부드러워'야 한다. 다시 말해 변경하기 쉬워야 한다.(중략). 이러한 변경 사항을 적용하는 데 드는 어려움은 변경되는 범위(scope)에 비례해야 하며, 변경사항의 형태(shape)와는 관련이 없어야 한다. 

아키텍처가 특정 형태를 다른 형태보다 선호하면 할수록, 새로운 기능을 이 구조에 맞추는 게 더 힘들어진다. 따라서 아키텍처는 형태에 독립적이어야 하고, 그럴수록 더 실용적이다. 

아이젠하워 매트릭스의 우선 순위
1. 긴급하고 중요한 (아키텍처, 행위)
2. 긴급하지는 않지만 중요한 (아키텍처)
3. 긴급하지만 중요하지 않은 (행위)
4. 긴급하지도 중요하지도 않은

업무 관리자와 개발자가 흔하게 저지르는 실수는 세 번째에 위치한 항목을 첫 번째로 격상시켜 버리는 일이다. 다시 말해 긴급하지만 중요하지 않은 기능과 진짜로 긴급하면서 중요한 기능을 구분하지 못한다. 

## 3장. 패러다임 개요
3가지 패러다임
- 구조적 프로그래밍
- 객체 지향 프로그래밍
- 함수형 프로그래밍

## 4장. 구조적 프로그래밍
_4장은 한번 더 읽을 필요가 있음_

데이크스트라
- 모든 프로그램은 설령 단순할지라도 인간의 뇌로 감당하기에는 너무 많은 세부사항을 담고 있었다. 아주 작은 세부사항이라도 간과하면 프로그램이 동작하는 것처럼 보이더라도 결국엔 예외 방식으로 실패파곤 했다
- 증명(Proof)이라는 수학적 원리를 적용해서 이 문제를 해결하려고 노력

뵘, 야코피니
- 모든 프로그램을 순차(sequence), 분기(selection), 반복(interation)이라는 세가지 구조만으로 표현할 수 있다는 사실을 증명
- 모듈을 증명 가능하게 하는 바로 그 제어구조가 모든 프로그램을 만들 수 있는 제어 구조의 최소 집합과 동일하다는 사실이었다. 구조적 프로그래밍은 이렇게 탄생했다

## 5장. 객체 지향 프로그래밍
캡슐화
- OO ㅍ로그래밍은 프로그래머가 충분히 올바르게 행동함으로써 캡슐화된 데이터를 우회해서 사용하지 않을 거라는 믿음 기반으로 한다. 하지만 OO를 제공한다고 주창한 언어들이 실제로는 C언어에서 누렸던 완벽한 캡슐화를 약화시켜 온 것은 틀림없다. 
   - _C에서는 구조(=Header)와 구현(.c)이 분리되어 있기 때문에 완벽한 캡슐화가 가능하다_

상속

다형성
- C에서도 다형성은 구현 가능하다. 하지만 포인터를 응용한 다형성이기 때문에 구현의 어려움이 있다.<br>
OO언어를 사용하면 다형성은 대수롭지 않은 일이 된다. OO언어는 과거 C프로그래머가 꿈에서나 볼 수 있는 강력한 능력을 제공한다. 이러한 이유로 OO는 제어흐름을 간접적으로 전환하는 규칙을 부과한다고 결론지을 수 있다.
- 플러그인 아키텍쳐는 이처럼 입출력 장치 독립성을 지원하기 위해 만들어졌고, 등장 이후 거의 모든 운영체제에서 구현되었다. 그럼에도 대다수의 프로그래머는 직접 작성하는 프로그램에서는 이러한 개념을 확장하여 적용하지 않았는데, 함수를 가리키는 포인터를 사용하면 위험을 수반하기 때문이었다. OO의 등장으로 언제 어디서든 플러그인 아키텍쳐를 적용할 수 있게 되었다. (=의존성 역전)

의존성 역전
- OO언어가 다형성을 안전하고 편리하게 제공한다는 사실은 소소 코드의 의존성을 언제 어디에서든 역전시킬 수 있다는 뜻이기도 하다. 
- 이러한 접근법을 사용한다면, OO언어로 개발된 시스템을 다루는 소프트웨어 아키텍트는 시스템의 소스 코드 의존성 전부에 대해 방향을 결정할 수 있는 절대적인 권한을 갖는다. 즉, 소스 코드 의존성이 제어흐름의 방향과 일치되도록 제한되지 않는다. 호출하는 모듈이든 아니면 호출 받는 모듈이든 관계 없이 소프트웨어 아키텍트는 소스 코드 의존성을 원하는 방향으로 설정할 수 있다.<br>
이것이 힘이다! 이것이 바로 OO가 제공하는 힘이다. 그리고 이것이 바로 OO가 지향하는 것이다. 
- 배포 독립성 (Independent deployablity)
   - 특정 컴포넌트의 소스 코드가 변경되면, 해당 코드가 포함된 컴포넌트만 다시 배포하면 된다
- 개발 독립성 (Independent Developability)
   - 시스템의 모듈을 독립적으로 배포할 수 있게 되면, 서로 다른 팀에서 각자 모듈을 독립적으로 개발할 수 있다. 

__OO란 다형성을 이용하여 전체 시스템의 모든 소스 코드 의존성에 대한 절대적인 제어 권한을 획득할 수 있는 능력이다. OO를 사용하면 아키텍트는 플러그인 아키텍쳐를 구성할 수 있고, 이를 통해 고수준의 정책을 포함하는 모듈은 저수준의 세부 사항을 포함하는 모듈에 대해 독립성을 보장할 수 있다. 저수준의 세부사항은 중요도가 낮은 플러그인 모듈로 만들 수 있고, 고수준의 정책을 포함하는 모듈과는 독립적으로 개발하고 배포할 수 있다.__

## 6장. 함수형 프로그래밍
함수형 패러다임에서 핵심이 되는 기반은 람다(Lamda) 계산법으로 알로조 처지(Alonzo Church)가 1930대에 발명했다.

자바와 클로저의 차이 (정수 제곱 기능 예시)
- 자바 샘플 코드
   ```java
   for (int i = 0; i < 25; i++) {
      System.out.println(i*i);
   }
   ```
- 클로저 샘플 코드
   ```clojure
   (pintln(take 25 (map (fn [x] (* x x))(range))))
   ```

- 위 코드는 클로저와 자바의 프로그램 사이의 극단적인 차이를 보여준다.<br>
자바 프로그램은 가변 변수(mutable variable)를 사용하는데, 가변 변수는 프로그램 실행 중에 상태가 변할 수 있다. 앞의 예제에서 반복문을 제어하는 변수인 i가 가변 변수다. 클로저 프로그램에서는 이러한 가변 변수가 전혀 없다. 클로저에서는 x와 같은 변수가 한 번 초기화되면 절대로 변하지 않는다.<br>
이는 놀라운 사실을 알려주는데, 함수형 언어에서 변수는 변경되지 않는다

### 불변성과 아키텍쳐
아키텍쳐를 고려할 때 이러한 내용이 왜 중요한가? 아키텍트는 왜 변수의 가변성을 염려하는가? 터무없게도 대답은 단순하다. 경합(race) 조건, 교착상태(deadlock) 조건, 동시 업데이트(concurrent update) 문제가 모두 가변 변수로 인해 발생하기 때문이다. 만약 어떤 변수도 갱신되지 않는다면 경합 조건이나 동시 업데이트 문제가 일어나지 않는다. 락(lock)이 가변적이지 않다면 교착상태도 일어나지 않는다.<br>
다시 말해 우리가 동시성 애플리케이션에서 마주치는 모든 문제, 즉 다수의 스레드와 프로세스를 사용하는 애플리케이션에서 마주치는 모든 문제는 가변 변수가 없다면 절대로 생기지 않는다.<br>
아키텍트라면 동시성 문제에 지대한 관심을 가져야만 한다. 우리는 스레드와 프로세스가 여러 개인 상황에서도 설계한 시스템이 여전히 강건하기를 바란다. 그렇다면 이제 불변성이 정말로 실현 가능한지를 스스로에게 물어봐야 한다. 

### 가변성의 분리
불변성과 관련하여 가장 주요한 타협 중 하나는 애플리케이션, 또는 애플리케이션 내부의 서비스를 가변 컴포넌트와 불변 컴포넌트로 분리하는 일이다. 불변 컴포넌트에서는 순수하게 함수형 방식으로만 작업이 처리되며, 어떤 가변 변수도 사용되지 않는다. 불변 컴포넌트는 변수의 상태를 변경할 수 있는, 즉 순수 함수형 컴포넌트가 아닌 하나 이상의 다른 컴포넌트와 서로 통신한다. 

현명한 아키텍트라면 가능한 한 많은 처리를 불변 컴포넌트로 옮겨야 하고, 가변 컴포넌트에서는 가능한 한 많은 코드를 빼내야 한다. 

### 이벤트 소싱
기본 발상
- 데이터를 관리할 때 변경 시점(=Transaction)에 관련된 데이터를 변경하는 거이 아니라, 트랜잭션을 기준으로 모두 저장한다
- 시간이 지날수록 트랜잭션이 터무니 없이 증가하겠지만, 애플리케이션의 수명주기 동안이다

이벤트 소싱은 상태가 아닌 트랜잭션을 저장하는 전략이다. 상태가 필요해지면 단순히 상태의 시작점부터 모든 트랜잭션을 처리한다.<br>
더 중요한 점은 데이터 저장소에서 삭제되거나 변경되는 것이 하나도 없다는 사실이다. 결과적으로 애플리케이션은 CRUD가 아니라 그저 CR만 수행한다. 또한 데이터 저장소에서 변경과 삭제가 전혀 발생하지 않으므로 동시 업데이트 문제 또한 일어나지 않는다.<br>
저장 공간과 처리 능력이 충분하면 애플리케이션이 완전한 불변성을 갖도록 만들 수 있고, 따라서 완전한 함수형으로 만들 수 있다. 

# 2부 결론 (4장, 5장, 6장)
규율
- 구조적 프로그래밍은 제어흐름의 직접적인 전환에 부과되는 규율이다
- 객체지향 프로그래밍은 제어흐름의 간접적인 전환에 부과되는 규율이다
- 함수형 프로그래밍은 변수 할당에 부과되는 규율이다

__도구가 달라졌고 하드웨어도 변했지만, 소프트웨어의 핵심은 여전히 그대로다<br>
소프트웨어, 즉 컴퓨터 프로그램은 순차(sequence), 분기(selection), 반복(interation), 참고(indirection)로 구성된다. 그 이상도 그 이하도 아니다__

# 3부 설계 원칙
SOLID 원칙의 목적은 중간 수준의 소프트웨어구조가 아래와 같도록 만드는데 있다
- 변경에 유리하다
- 이해하기 쉽다
- 많은 소프트웨어 시스템에 사용될 수 있는 컴포넌트의 기반이 된다

'중간 수준' 이라 함은 프로그래머가 이들 원칙을 모듈 수준에서 작업할 대 적용할 수 있다는 뜻이다. 즉, 코드 수준보다는 조금 상위에서 적용되며 모듈과 컴포넌트 내부에서 사용되는 소프트웨어 구조를 정의하는데 도움을 준다

SRP(Single Responsible Principle)
- 소프트웨어 시스템이 가질 수 있는 최적의 구조는 시스템을 만드는 조직의 사회적 구조에 커다란 영향을 받는다. 따라서 각 소프트웨어 모듈은 변경의 이유가 하나, 단 하나여야만 한다. 

OCP(Open-Closed Principle)
- 기존 코드를 수정하기 보다는 새로운 코드를 추가하는 방식으로의 행위를 변경할 수 있도록 설계해야만 소프트웨어 시스템을 쉽게 변경할 수 있는 것이 이 원칙의 요지다

LSP(Liskov Substitution Principle)
- 상호 대체 가능한 구성요소를 이용해 소프트웨어 시스템을 만들 수 있으려면, 이들 구성요소는 반드시 서로 치환 가능해야 한다는 계약을 반드시 지켜야 한다

ISP(Interface Segregation Printciple)
- 소프트웨어 설계자는 사용하지 않는 것에 의존하지 않아야 한다

DIP (Dependency Inversion Principle)
- 고수준 정책을 구현하는 코드는 저수준 세부사항을 구현하는 코드에 절대로 의존해서는 안 된다. 대신 세부사항이 정책에 의존해야 한다. 

## 7장. SRP: 단일 책임 원칙
SRP의 잘못된 전달
- 모듈이 단 하나의 일만 해야 한다

SRP 원칙
- 하나의 모듈은 하나의, 오직 하나의 사용자 또는 이해관계자에 대해서만 책임져야 한다
- 하나의 모듈은 하나의, 오직 하나의 액터에 대해서만 책임져야 한다
   - _2개 이상의 액터를 위한 동작이 소스에 들어가면 특정 이해관계자를 위한 기능 변경이 다른 사람에게 영향을 줄 수 있다_
   - _각각의 이해당사를 위한 각자의 부서에서 개발될 수 있고 이를 병합하는 과정에서 어려움 또는 문제가 발생할 수 있다_
- 모듈의 가장 단순한 정의는 소스파일이다. 

_퍼사드(Facade) 패턴_

## 8장. OCP: 개방-폐쇄 원칙
정의
- 1998, 버트란트 마이어(Bertrand Meyer)
- 소프트웨어 개체(artifact)는 확장에는 열려 있어야 하고, 변경에는 닫혀 있어야 한다

컴포넌트의 의존 관계
- 재무재표 프로그램 예시 (책 참조)
- 모든 컴포넌트 관계는 단방향으로 이루어 진다. 화살표 방향은 변경으로부터 보호하려는 컴포넌트를 향하도록 그려진다
   - _이 뜻은 보호되어야 할 컴포넌트 코드는 유지하면서 변경이 되는 코드만 영향을 받도록 하는 것_
   - _보호되어야 할 컴포넌트를 인터페이스로 보호하면 인터페이스를 구현하는 부분이 구현체를 변경해도, 보호될 컴포넌트는 구조만 가지고 있기 때문에 변화에 안정적으로 대응이 가능하다_
   - _도메인의 개념이 아닐까?_
- A컴포넌트에서 발생한 변경으로부터 B 컴포넌트를 보호하려면 A컴포넌트가 B컴포넌트에 의존해야 한다
   - _의존성 화살표가 A -> B로 가야한다_
- Interactor는 OCP를 가장 잘 준수할 수 있는 곳에 위치한다. Database, Controller, Presenter, View에서 발생한 어떤 변경도 Interactor에 영향을 주지 않는다. (_Interactor를 도메인 개념으로 봐야 할 것 같다_)<br>
왜 Interactor가 이처럼 특별한 위치를 차지해야만 하는가? 그 이유는 바로 Interactor가 업무 규칙을 포함하기 때문이다. Interactor는 애플리케이션에서 가장 높은 수준의 정책을 포함한다. Interactor 이외의 컴포넌트는 모두 주변적인 문제를 처리한다. 가장 중요한 문제는 Interactor가 담당한다. 

아키텍처 수준에서 OCP가 동작하는 방식
- 아키텍트는 기능이 어떻게, 왜, 언제 발생하는지에 따라서 기능을 분리하고, 분리한 기능을 컴포넌트의 계층구조로 조직화한다. 컴포넌트 계층 구조를 이와 같이 조직화하려면 저수준 컴포넌트에서 발생한 변경으로부터 고수준 컴포넌트를 보호할 수 있다. 

추이 종속성(transitive dependency)
- 클래스 A가 클래스 B에 의존하고, 다시 클래스 B가 클래스 C에 의존한다면, 클래스 A는 클래스 C에 의존하게 된다. 이를 추이 종속성이라고 한다. 클래스 이외의 소프트웨어의 모든 엔티티에도 동직하게 적용된다. 만약 클래스 의존성이 순환적이라면, 모든 클래스가 서로 의존하게 되는 문제가 있다. 
- 추이 종속성을 가지게 되면, 소프트웨어 엔티티는 '자신이 직접 사용하지 않는 요소에는 절대로 의존해서는 안 된다'는 소프트웨어 원칙을 위반하게 된다. 

## 9장. LSP: 리스코프 치환 원칙
정의
- 1988, 바바라 리스코프(Barbara Liskov)
- 하위 타입에 대해서 아래와 같이 정의.<br>
여기에서 필요한 것은 다음과 같은 치환(substitution) 원칙이다. S 타입의 객체 o1 각각에 대응하는 T 타입의 객체 o2가 있고, T타입을 이용해서 정의한 모든 프로그램 P에서 o2 자리에 o1을 치환하더라도 P의 행위가 변하기 않는다면, S는 T의 하위 타입이다

LSP 위반 사례
- 정사각형/직사각형 문제
   - User -> Retangle(+setH, +setW)  <- Square(+setSide)
   ```
   Rectangle r = ...
   r.setW(5);
   r.SetH(2);
   assert(r.area() == 10)
   ```
   - 위 코드에서 '`...`' 부분에 Squre를 생성한다면 assert는 실패하게 된다
- 택시 업체 사례 참고 (p.85)

LSP는 아키텍처 수준까지 확장할 수 있고, 반드시 확장해야만 한다. 치환 가능성을 조금이라도 위배하면 시스템 아키텍처가 오염되어 상당량의 별도 메커니즘을 추가해야 할 수 있기 때문이다. 

_하위 구현체 변경에 대응하기 위해서 상위 구현체가 변경되면 안된다. 이 경우 if-else만 추가되고, bug를 만들 수 있다_

## 10장. ISP: 인터페이스 분리 원칙
의존성
- User1~3 클래스가 OPS를 사용하고 있다고 가정하자. OPS 클래스에는 op1~op3까지 함수가 있고, 각각은 User1~3에서 사용한다.
- 이러한 의존성으로 인해서 OPS 클래스에서 op2 소스 코드가 변경되면 User1도 다시 컴파일 한 후 재배포 해야 한다. User1과 관련된 코드는 전혀 변경되지 않았음에도 말이다. 

ISP와 아키텍처
- 문제가 있는 아키텍처
   - System S -> Framework F -> Database D
   - F에는 불필요한 기능, 따라서 S와는 전혀 관계없이 기능이 D에 포함된다고 가정하자. 그 기능때문에 D 내부가 변경되면, F를 재배포할 수도 있다. 따라서 S까지 재배포 해야할 지도 모른다. 

## 11장. DIP: 의존성 역전 원칙
의존성 역전 원칙(DIP)에서 말하는 '유연성이 극대화된 시스템'이란 소스 코드 의존성이 추상(abstraction)에 의존하며 구체(concretion)에는 의존하지 않는 시스템이다. 

DIP 논의에서 무시되는 케이스
- DIP를 논의할 때 운영체제나 플랫폼 같이 안정성이 보장된 환경에 대해서는 무시하는 편이다. 우리는 이들 환경에 대한 의존성은 용납하는데, 변경되지 않는다면 의존할 수 있다는 사실을 알고 있기 때문이다
- 우리가 의존하지 않도록 피하고자 하는 것은 바로 변동성이 큰 구체적인 요소다. 그리고 이 구체적인 요소는 우리가 열심히 개발하는 중이라 자주 변경될 수 밖에 없는 모듈들이다. 
- 예: String 클래스

### 안정된 추상화
인터페이스는 구현체보다 변동성이 낮다.

실제로 뛰어난 소프트웨어 설계자와 아키텍트라면 인터페이스의 변동성을 늦추지 위해 애쓴다. 인터페이스를 변경하지 않고도 구현체에 기능을 추가할 수 있는 방법을 찾기 위해 노력한다. 이는 소프트웨어 설계의 기본이다.<br>
__즉 안정된 소프트웨어 아키텍처란 변동성이 큰 구현체에 의존하는 일은 지양하고, 안정된 추상 인터페이스를 선호하는 아키텍처라는 뜻이다.__

__실천 코딩 법__
- 변동성이 큰 구체 클래스를 참조하지 말라. 
   - 대신 추상 인터페이스를 참조하라. 이 규칙은 언어가 정적타입이든 동적타입이든 관계없이 모두 적용된다. 또한 이 규칙은 객체 생성 방식을 강하게 제약하며, 일반적으로 추상 팩토리를 사용하도록 강제한다. 
- 변동성이 큰 구체 클래스로부터 파생하지 말라. 
   - 이 규칙은 이전 규칙의 따름정리이지만, 별도로 언급할만한 가치가 있다. 정적 타입언어에서 상속은 소스 코드에 존재하는 모든 관계 중에서 가장 강력한 동시에 뻣뻣해서 변경하기 어렵다. 따라서 상속은 아주 신중하게 사용해야 한다. 
   - 동적 타입 언어라면 문제가 덜 되지만, 의존성을 가진다는 사실에는 변함이 없다. 따라서 신중에 신중을 거듭하는게 가장 현명한 선택이다. 
- 구체 함수를 오버라이드 하지 말라
   - 대체로 구체 함수는 소스 코드 의존성을 필요로 한다. 따라서 구체 함수를 오버라이드 하면 이러한 의존성을 제거할 수 없게 되며, 실제로는 그 의존성을 상속하게 된다. 이러한 의존성을 제거하려면, 차라리 추상 함수로 선언하고 구현체들에서 각장의 용도에 맞게 구현해야 한다. 
- 구체적이며 변동성이 크다면 절대로 그 이름을 언급하지 말라. 
   - 사실 이 실천법은 DIP 원칙을 다른 방식으로 풀어쓴 것이다. 


제어 프름은 소스 코드 의존성과는 정반대 방향으로 곡선을 가로지른다는 점에 주목하자. 다시 말해 소스코드 의존성은 제어흐름과는 반대 방향으로 역전된다. 이러한 이유로 이 원칙을 의존성 역전이라고 부른다. 

# 4부 컴포넌트 원칙
SOLID 원칙이 벽과 방에 벽돌을 배치하는 방법을 알려준다면, 컴포넌트 원칙은 빌딩에 방을 배치하는 방법을 설명해준다. 큰 빌딩과 마찬가지로 대규모 소프트웨어 시스템은 작은 컴포넌트들도 만들어진다. 

## 12장. 컴포넌트
컴포넌트 단위
- 컴포넌트는 배포 단위다
- 시스템의 구성요소로 배포할 수 있는 가장 작은 단위. (자바 jar, 루비 gem, 닷넷 dll)
- 잘 설계된 컴포넌트라면 반드시 독립적으로 배포 가능한, 따라서 독립적으로 개발 가능한 능력을 갖춰야 한다. 

컴포넌트의 역사
1. 프로그래머가 라이브러리 함수의 소스코드를 애플리케이션 코드에 포함시켜 단일 프로그램으로 컴파일
   - 컴파일 오래 걸림
2. 함수의 라이브러리 코드를 애플리케이션 코드로 부터 분리
   - 라이브러리 코드를 개별적으로 컴파일하고 메모리에 로드
   - 애플리케이션을 실행하면 특정 메모리의 라이브러리를 로드하고 애플리케이션을 로드
   - 애플리케이션이 커지면서 문제가 생김
3. 재배치 가능한 바이너리
   - 로더를 사용해서 메모리에 재배치 할 수 있는 형태의 바이너리를 생성하도록 컴파일러를 수정
   - 프로그래머는 함수 라이브러리를 로드할 위치와 애플리케이션을 로드할 위치를 로더에게 지시할 수 있게 되었다
   - 로더는 여러개의 바이너리를 입력 받은 후 단순히 하나씩 메모리로 로드하면서 재배치 작업을 처리
4. 링크와 로더를 두 단계로 분리
   - 링커
      - 별도의 애플리케이션
      - 링크가 완료된 재배치 코드를 만들어주었다
5. 1990년대 후반이 되자 프로그래머가 프로그램을 성장시키는 속도보다 링크 시간이 줄어드는 속도가 빨리지기 시작
   - H/W의 발전
   - 컴포넌트 플러그인 아키텍처의 탄생 


# 5부 아키텍처
## 15장. 아키텍처란 
소프트웨어 아키텍트는 코드와 동떨어져서는 안 된다. 소프트웨어 아키텍트는 최고의 프로그래머이며, 앞으로도 계속 프로그래밍 작업을 맡을 뿐만 아니라 동시에 나머지 팀원들이 생산성을 극대화 할 수 있는 설계를 하도록 방향을 이끌어 준다. 소프트웨어 아키텍트는 다른 프로그래머만큼 코드를 많이 작성하지 않을 수도 있지만, 프로그래밍 작업에는 지속적으로 참여한다. 

아키텍처의 주된 목적은 시스템의 생명주기를 지원하는 것이다. 아키텍처의 궁긱적인 목표는 시스템의 수명과 관련된 비용은 최소화하고, 프로그래머의 생산성은 최대화하는 데 있다. 
- 시스템을 쉽게 이해
- 쉽게 개발
- 쉽게 유지보수
   - 요지보수의 가장 큰 비용은 탐사(spelunking)와 이로 인한 위험부담에 있다. 탐사란 기존 소프트웨어에 새로운 기능을 추가하거나 결함을 수정할 때, 소프트웨어를 파헤쳐서 어디를 고치는 게 최선인지, 그리고 어떤 전략을 쓰는게 최적일지를 결정할 때 드는 비용이다. 이러한 변경사항을 반영할 때 의도치 않은 결함이 발생할 가능성은 항상 존재하며, 이로 인한 위험부담 비용이 추가된다. 
   - 주의를 기울여 신중하게 아키텍처를 만들면 이 비용을 크게 줄일 수 있다. 시스템을 컴포넌트로 분리하고, 안정된 인터페이스를 두어 서로 격리한다. 이를 통해 미래에 추가될 기능에 대한 길을 밝혀 둘 수 있을 뿐만 아니라 의도치 않은 장애가 발생할 위험을 크게 줄일 수 있다. 
- 쉽게 배포
   - 소프트웨어 시스템이 사용될 수 있으려면 반드시 배포할 수 있어야 한다. 배포 비용이 높을수록 시스템의 유용성은 떨어진다. 따라서 소프트웨어 아키텍처는 시스템을 단 한 번에 휩게 배포할 수 있도록 만드는 데 그 목표를 두어야 한다.

아키텍트의 목표는 시스템에서 정책을 가장 핵심적인 요소로 식별하고, 동시에 세부사항은 정책에 무관하게 만들 수 있는 형태의 시스템을 구축하는데 있다. 
- 정책
   - 모든 업무 규칙과 업무 절차를 구체화 한다
- 세부사항
   - 사람, 외부 시스템, 프로그래머가 정책과 소통할 때 필요한 요소이지만, 정책이 가진 행위에는 조금도 영향을 미치지 않는다
   - 예: 입출력 장치, 데이터베이스, 웹 시스템, 서버 등
   - 사례 예시 
      1. 개발 초기에는 DB 시스템을 선택할 필요가 없다
      2. 개발 초기에는 웹 서버를 선택할 필요가 없다
      3. 개발 초기에는 REST를 적용할 필요가 없다
      4. 개발 초기에는 DI 프레임워크를 적용할 필요가 없다

좋은 아키텍트는 세부사항을 정책으로부터 신중하게 가려내고, 정책이 세부사항과 결합되지 않도록 엄격하게 분리한다. 이를 통해 정책은 세부사항에 관한 어떠한 지식도 갖지 못하게 되며, 어떤 경우에도 세부사항에 의존하지 않게 된다. 좋은 아키텍트는 세부사항에 대한 결정을 가능한 한 오랫동안 미룰 수 있는 방향으로 정책을 설계한다. 

## 16장. 독립성
### 좋은 아키텍처
유스케이스
- 시스템의 아키텍처는 시스템의 의도를 지원해야 한다는 뜻이다.<br>
만약 시스템이 장바구니 애플리케이션이라면, 이 아키텍트는 장바구니와 관련된 유스케이스를 지원해야 한다. 
- 좋은 아키텍처가 행위를 지원하기 위해 할 수 있는 가장 중요한 사항은 행위를 명확히 하고 외부로 드러내며, 이를 통해 시스템이 지닌 의도를 아키텍처 수준에서 알아볼 수 있게 만드는 것이다. 

운영
- 시스템이 초당 100,000명의 고객을 처리해야 한다면, 아키텍처는 이 요구와 관련된 각 유스케이스에 걸맞은 처리량과 응답시간을 보장해야 한다

개발
- 콘웨이 법칙
   - 시스템을 설계하는 조직이라면 어디든지 그 조직의 의사소통 구조와 동일한 구조의 설계를 만들어 낼 것이다.<br>
   _뭔가 DDD의 느낌이 난다. 결국 도메인의 기능을 동일하게 설계 녹이라는 것일까_
- 많은 팀으로 구성되며 관심사가 다양한 조직에서 어떤 시스템을 개발해야 한다면, 각 팀이 독립적으로 행동하기 편한 아키텍처를 반드시 확보하여 개발하는 동안 팀들이 서로를 방해하지 않도록 해야 한다.
- 이러한 아키텍처를 만들려면 잘 격리되어 독립적으로 개발 가능한 컴포넌트 단위로 시스템을 분할 할 수 있어야 한다. 그래야만 컴포넌트를 독립적으로 작업할 수 있는 팀에 할당할 수 있다. 

배포
- 아키텍처는 배포 용이성을 결정하는 데 중요한 역할을 한다. 
- 이때 목표는 '즉각적인 배포'다

선택사항 열어놓기
- 현실에서는 시스템이 생명주기의 단계를 거침에 따라 요구 사항들이 계속 변해간다. 
- 좋은 아키텍처는 선택사항을 열어 둠으로써, 향후 시스템에 변경이 필요 할 때 어떤 방향으로든 쉽게 변경할 수 있도록 한다

계층 결합 분리
- 아키텍트는 단일 책임 원칙(SRP)과 공통 폐쇄 원칙(OCP)을 적용하여 다른 이유로 변경되는 것들은 분리하고, 동일한 이유로 변경되는 것들은 묶는다. 
   - 서로 다른 이유로 변경되는 것
      - 예: 사용자 인터페이스와 업무 규칙. (둘은 관련이 없다)
      - 이들은 각자 다른 속도로, 그리고 다른 이유로 변경될 것이다. 따라서 서로 분리하고, 독립적으로 변경할 수 있어야 한다.

유스케이스 분리
- 시스템에서 서로 다른 이유로 변경되는 요소들의 결합을 분리하면 기존 요소에 지장을 주지 않고도 새로도 유스케이스를 계속해서 추가할 수 있다.

개발 독립성

배포 독립성

중복
- 중복이 진짜 중복인지, 우발적 중복(=비슷한 경우)인지 확인하라
- 우발적 중복은 통합하지 않도록 주의해야 한다. 이후에 다시 분리하느라 큰 수고를 감수해야 할 수 있다.

결합 분리 모드
- 소스 수준 분리 모드
   - 소스 코드 모듈 사이의 의존성 제어
   - 하나의 모듈을 변경하더라도 다른 모듈을 변경하거나 재컴파일 하지 않도록 만들 수 있다(예, 루비)
   - 모노리틱 구조
- 배포 수준 분리 모드
   - DLL, jar 와 같이 배포 가능한 단위들 사이의 의존성 제어
- 서비스 수준 분리 모드
   - 의존하는 수준을 데이터 구조 단위까지 낮출 수 있다
   - 모든 실행 가능한 단위는 소스와 바이너리 변경에 대해 완전히 독립적이다 (예: 서비스 또는 마이크로서비스)

좋은 아키텍처는 모노리틱 구조로 태어나서 단일 파일로 배포되더라도, 이후에는 독립적으로 배포 가능한 단위들의 집합으로 성장하고, 또 독립적인 서비스나 마이크로서비스 수준까지 성장할 수 있도록 만들어져야 한다. 또한 나중에 상황이 바뀌었을 때 이 진행 방향을 거꾸로 돌려 원래 형태인 모노리틱 구조로 되돌릴 수 있어야 한다. 

중요한 것은 시스템의 결합 분리 모드는 시간이 지나면 바뀌기 쉬우며, 뛰어난 아키텍트라면 이러한 변경을 예측하여 큰 무리없이 반영할 수 있도록 만들어야 한다. 

## 17장. 경계: 선 긋기
경계 (boundary)
- 경계는 소프트웨어 요소를 서로 분리하고, 경계 한편에 있는 요소가 반대편에 있는 요소를 알지 못하게 막는다.
   - _의존성을 관리한다_
- 초기에 그어지는 선들은 가능한 한 오랫동안 결정을 연기시키기 위해, 그래서 이들 결정이 핵심적인 업무 로직을 오염시키기 못하게 막으려는 목적으로 쓰인다
   - _인터페이스로 미리 경계를 그어서 개발할 때 특정 영역에 집중하기 위해서_
   - _부가적인 요소는 이후에 선택 가능하도록 한다_
- 아키텍트의 목표는 필요한 시스템을 만들고 유지하는 데 드는 인적 자원을 최소화하는 것
   - 이 인적자원의 효율을 떨어뜨리는 것은 결합(coupling)이다
- 좋은 시스템 아키텍처는 이러한 결정을 가능한 한 최후의 순간에 내릴 수 있게 해주며, 결정에 따른 영향이 크지 않게 만든다
   - _부수적인 요소는 선택 가능한 구조로 설계한다_


외부 사양을 고려하지 않는 개발 예시 (WikiPage 개발)
1. 연관되는 부분은 Stub으로 만든다: MockPage
2. 필요시 메모리를 사용하도록 변경한다: InMemoryPage
3. 필요시 파일시스템을 사용하도록 한다: FileSystemPage
4. 필요시 DB를 사용한다: MySQLPage
- _이 모든 것들은 Interface를 통해서 정해진 양식만 맞추면 가능하도록 한다_

### 어떻게 선을 그을까? 그리고 언제 그을까?
어떻게 선을 그을까?
- 관련이 있는 것과 없는 것 사이에 선을 긋는다. 
   - 예를 들어 GUI는 업무 규칙과는 관련이 없기 때문에 이 둘 사이에는 반드시 선이 있어야 한다
- 업무 규칙은 스키마, 쿼리 언어, 또는 데이터베이스와 관련된 나머지 세부사항에 대해 어떤 것도 알아서는 안된다. 
   - 업무 규칙이 알아야 할 것은 데이터를 가져오고 저장할 때 사용할 수 있는 함수 집합이 있다는 사실이 전부다
   - 데이터베이스는 업무 규칙이 간접적(= _필수적으로 결합이 필요하지 않은_)으로 사용할 수 있는 도구
   - __아래와 같다__
      - 'Business Rules' -> 'DataBaseInterface' <- 'Database Access' -> 'Database'
      - 'Business Rules'에 있어서 'Database'는 문제가 되지 않지만, 'Database'는 'BusinessRules' 없이는 존재할 수 없다

### GUI와 BusinessRules의 기준에서 본다면?
관련성이 낮은 컴포넌트가 관련성이 높은 컴포넌트에 의존한다는 사실은 변경이 없다. 
- GUI는 다른 종류의 인터페이스로 얼마든지 교체될 수 있다
- BusinessRules는 여기에 전혀 개의치 않는다

### 플러그인 아키텍처
컴포넌트 추가에 대한 패턴
- 소프트웨어 개발 기술의 역사는 플러그인을 손쉽게 생성하여, 확장 가능하며 유지보수가 쉬운 시스템 아키텍처를 확립할 수 있게 만드는 방법에 대한 이야기다
- 우리는 특정 모듈이 나머지 모듀레 영향받지 않기를 바란다
- 시스템을 플러그인 아키텍처로 배치함으로써 변경이 전파될 수 없는 방화벽을 생성할 수 있다. 

### 결론
소프트웨어 아키텍처에서 경계선을 그리려면 먼저 시스템을 컴포넌트 단위로 분할해야 한다. 일부 컴포넌트는 핵심업무 규칙에 해당한다. 나머지 컴포넌트는 플러그인으로, 핵심 업무와는 직접적인 관련이 없지만 필수 기능을 포함한다. 그런 다음 컴포넌트 사이에 화살표가 특정 방향, 즉 핵심업무를 향하도록 이들 컴포넌트의 소스를 배치한다. 

## 18장. 경계 해부학
### 경계별 특징
경계 횡단하기
- 적절한 위치에서 경계를 횡단하게 하는 비결은 소스 코드 의존성 관리에 있다
- 경계는 변경이 전파되는 것을 막는 방화벽을 구축하고 관리하는 수단으로써 존재한다

두려운 단일체
- 소스 수준 분리 모드
- 배포 관점에서 볼 때 단일체는 경계가 드러나지 않는다
- 호출 방향
   - 가장 단순한 형태의 경계 횡단은 저수준 클라이언트에서 고수준 서비스로 향하는 함수 호출이다.<br>
   이 경우 란타임 의존성과 컴파일타임 의존성은 모두 같은 방향, 즉 저수준 컴포넌트에서 고수준 컴포넌트로 향한다. 
   - 고수준 클라이언트가 저수준 서비스를 호출해야 한다면, Interface를 사용해서 의존성 방향을 역전시킬 수 있다. 

배포형 컴포넌트
- DLL, JAR 등 배포 가능형태로 분리하는 것
- 배포 과정에서만 차이가 날 뿐, 단일체와 동일하다
   - 일반적으로 모든 함수가 동일한 프로세서와 주소 공간에 위치하며, 컴포넌트를 분리하거나 컴포넌트 간 의존성을 관리하는 전략도 단일체와 동일하다


로컬 프로세스
- 동일한 프로세서 또는 하나의 멀티코어 시스템에 속한 여러 프로세서들에서 실행되지만, 각각이 독립된 주소 공간에서 실행된다
   - _윈도우에서 별도의 실행가능한 프로그램을 실행하는 것이라고 보면 된다_
- 이러한 통신에는 운영체제 호출, 데이터 마샬링 및 언마샬링, 프로세스 간 문맥 교환 등이 있으며, 이들은 제법 비싼 작업에 속한다.<br>
따라서 통신이 너무 빈번하게 이뤄지지 않도록 신중하게 제한해야 한다. 

서비스
- 물리적인 형태를 띠는 가장 강력한 경계
- 서비스들은 모든 통신이 네트워크를 통해 이뤄진다고 가정하기 때문에 속도는 당연히 느리다.
   - 지연 문제가 있을 수 있으며, 고수준에서 이러한 문제를 해결할 수 있어야 한다
- 저수준 서비스는 반드시 고수준 서비스에 '플러그인'되어야 한다

## 19장. 정책과 수준
좋은 아키텍처라면 각 컴포넌트를 연결할 때 의존성의 방향이 컴포넌트의 수준을 기반으로 연결되도록 만들어야 한다. 즉, 저수준 컴포넌트가 고수준 컴포넌트에 의존하도록 설계되어야 한다. 

수준 (Level)
- 입력과 출력까지의 거리
   - __시스템의 입력과 출력 모두로부터 멀리 위치할수록 정채그이 수준은 높아진다__
   - 입력과 출력을 다루는 정책이라면 시스템에서 최하위 수준에 위치한다
- 데이터의 흐름과 소스코드 의존성이 항상 같은 방향을 가리키지는 않는다
   - 소스코드 의존성은 그 수준에 따라 결합되어야 하며, 데이터 흐름을 기준으로 결합되어서는 안 된다
   - _데이터 흐름을 기준으로 하면 Presenter로 나가는 코드는 고수준에서 저수준으로 데이터가 흐르게 되는데, 소스코드 의존성은 이를 따라가면 안된다. 따라서 Interface를 통해서 의존성을 역전시켜야 한다_
- 소스코드에서 의존성의 방향이 고수준 정책을 향할 수 있도록 정책을 분리했다면 변경의 영향도를 줄일 수 있다
   - _상대적으로 고수준의 코드는 정책을 반영하는 것이 많기 때문에 저수준의 코드보다 변경이 적다_

## 20장. 업무 규칙
업무 규칙
- 사업적으로 수익을 얻거나 비용을 줄일 수 있는 규칙 또는 절차
- 컴퓨터 상으로 구현했는지와 상관없이, 업무 규칙은 사업적으로 수익을 얻거나 비용을 줄일 수 있어야 한다
- 보통 이를 핵심 업무 규칙이라고 한다
- 핵심 업무 데이터: 핵심 업무 규칙이 필요로 하는 데이터

엔티티
- 정의
   - 컴퓨터 시스템 내부의 객체
   - 핵심 업무 데이터를 기반으로 동작하는 일련의 조그만 핵심 업무 규칙을 구체화 한다. (= _핵심업무 규칙과 핵심엄무 데이터로 구성된다_)
- 데이터베이스, 사용자 인터페이스, 3rd 파티 프레임워크에 대한 고려사항들로 인해 오염되어서는 절대 안된다.

유스케이스
- 자동화된 시스템이 사용되는 방법을 설명한다
- 엔티티 내의 핵심 업무 규칙과는 반대로, 유스케이스는 애플리케이션에 특화된 업무 규칙을 설명한다
   - _엔티티 외부에 위치하면서 엔티티를 사용한다_
- 엔티티 내부의 핵심 업무 규칙을 어떻게, 그리고 언제 호출할지를 명시하는 규칙을 담는다
- 유스케이스는 시스템이 사용자에게 어떻게 보이는지를 설명하지 않는다. 이보다는 애플리케이션에 특화된 규칙을 설명하며, 이를 통해 사용자와 엔티티 사이의 상호작용을 규정한다. 시스템에 데이터가 들어오고 나가는 방식은 유스케이스와는 무관하다. 
   - _사용자에게 어떻게 보이는지는 더 저수준에서 관리한다. 저수준에서 데이터 처리를 할 때 유스케이스를 참조해서 진행한다_

## 21장. 소리치는 아키텍처
아키텍처의 테마
- 아키텍처는 프레임워크에 대한 것이 아니다. 그리고 절대로 그래서도 안된다.<br>
프레임워크는 사용하는 도구일 뿐, 아키텍처가 준수해야 할 대상이 아니다. 
- 아키텍처를 프레임워크 중심으로 만들어버리면 유스케이스가 중심이 되는 아키텍처는 절대 나올 수 없다. 

아키텍처의 목적
- 좋은 아키턱처는 프레임워크, 데이터베이스, 웹 서버 그리고 여타 개발 환경 문제나 도구에 대해서는 결정을 미룰 수 있도록 만든다. 

테스트하기 쉬운 아키텍처
- 아키텍처가 유스케이스를 우선으로 하고, 프레임워크와는 거리를 둔다면 프레임워크를 준비하지 않더라도 유스케이스에 대해서 단위 테스트를 할 수 있어야 한다.
- 테스트를 돌리는데 웹 서버가 반드시 필요한 상황이 되어서는 안된다.

## 22장. 클린 아키텍처
아키텍처의 목표
- 관심사의 분리(separation of concerns)
- 소프트웨어를 계층으로 분리함으로써 관심사의 분리라는 목표를 달성할 수 있었다.

아키텍처 특징
- 프레임워크 독립성: 프레임워크의 존재 여부에 의존하지 않는다
- 테스트 용이성: 업무 규칙은 UI, DB 기타 외부 요소 없이도 테스트할 수 있다
- UI 독립성: 시스템의 나머지 부분을 변경하지 않고도 UI를 쉽게 변경할 수 있다
- 데이터베이스 독립성: 업무 규칙은 데이터베이스에 결합되지 않는다
- 모든 외부 에이전시에 대한 독립성: 실제로 업무 규칙은 외부 세계와의 인터페이스에 대해 전혀 알지 못한다
![클린아키텍처](/Images/클린아키텍처/22-1.jpg)

의존성 규칙
- 소스코드 의존성은 반드시 안쪽으로, 고수준의 정책을 향해야 한다

엔티티
- 핵심 업무 규칙
- 외부에 변경에 대해서 변경될 가능성이 낮다

유스케이스
- 애플리케이션에 특화된 업무 규칙
- 엔티티로 들어오고 나가는 데이터 흐름을 조정하며, 엔티티가 자신의 핵심 업무 규칙을 사용해서 유스케이스와 목적을 달성하도록 이끈다

인터페이스 어댑터
- 데이터를 유스케이스와 엔티티에게 가장 편리한 형식에서 데이터베이스나 웹 같은 외부 에이전시에세 가장 편리한 형식으로 변환한다
- GUI의 MVC 아키텍처를 모두 포괄한다
   - Prensenter, View, Controller 등의 이 계층에 속한다
   - 모델은 그저 데이터 구조 정도에 지나지 않는다
   - 데이터를 컨트롤러에서 유스케이스로 전달되고, 다시 유스케이스에서 프레젠터와 뷰로 되돌아 간다

경계 횡단하기
- 동적 다형성(Interface)를 이용하여 소스 코드 의존성을 제어흐름과는 반대로 만들 수 있고, 이를 통해 제어흐름이 어느 방향으로 흐르더라도 의존성 규칙을 준수할 수 있다
- 경계를 횡단하는 데이터를 그 전체를 전달하면서 의존성이 위배하게 하면 안된다
   - 예를 들어서 Database의 Row를 모두 전달하는 것: 이는 고수준 컴포넌트가 전달되는 Row의 항목을 알아야 한다

## 23장. 프레젠터와 험블 객체
험블 객체 패턴
- 디자인 패턴으로 테스트하기 어려운 행위와 테스트하기 쉬운 행위를 단위 테스트 작성자가 분리하기 쉽게 하는 방법
- 방법은 행위들을 2개의 모듈 또는 클래스로 나누는 것이다
   - 이 모듈 중 하나가 험블이다
   - 기본적인 본질은 남기고, 테스트 하기 어려운 행위는 험블 객체로 옮긴다

프레젠터와 뷰
- 뷰: 험블객체. 테스트하기 어렵다
- 프레젠터: 테스트 하기 쉬운 객체
- 화면에 표시되고 애플리케이션에서 어느 정도 제어할 수 있는 요소라면 무조건 뷰 모델 내부에 문자열, Boolean 또는 열거형 형태로 표현한다. 뷰는 뷰 모델의 데이터를 화면으로 로드할 뿐이며, 이 외에 뷰가 맡은 역할은 전혀 없다. 

테스트와 아키텍처
- 행위를 테스트하기 쉬운 부분과 테스트하기 어려운 부분으로 분리하면 아키텍처 경계가 정의된다

데이터베이스 게이트웨이
- 구조: 유스케이스 인터랙터 <-> DB Gateway <-> DB
   - 인터랙터는 애플리케이션에 특화된 업무 규칙을 캡슐화하기 때문에 험블 객체가 아니다 -> 테스트 하기 쉽다
      - 게이트웨이가 스텁이나 테스트 더블(=Stub, Mock, fake 등을 묶어서 지칭할 때)

결론
- 각 아키텍처 경계마다 경계 가까이 숨어 있는 험블 객체 패턴을 발견할 수 있을 것이다. 경계를 넘나드는 통신은 거의 모두 간단한 데이터 구조를 수반할 때가 많고, 대개 그 경계는 테스트하기 어려운 무언가와 테스트하기 쉬운 무언가로 분리될 것이다. 이러한 아키텍처 경계에서 험블 객체 패턴을 사용하면 전체 시스템의 테스트 용이성을 크게 높일 수 있다

## 24장. 부분적 경계
부분적 경계 (Partial Boundary)
- 아키텍처의 경계를 만드는 것은 비용이 많이 든다
- YAGNI(You Aren't Going to Need It) 원칙 위배
   - 아키텍트의 입장에서는 당장은 필요 없더라도 나중에 필요할 수 있으므로 경계에 대한 필요한 공간을 확보하길 원할 수 있다
   - 애자일 커뮤니티에서는 YAGNI 원칙 위배로 좋아하지는 않음
   - 그렇다면 부분적 경계를 생각해 볼 수 있다

### 3가지 방법
방법 1 - 마지막 단계를 건너뛰기
- 독립적으로 컴파일하고 배포할 수 있는 컴포넌트를 만들기 위한 작업은 모두 수행 수, 단일 컴포넌트에 그대로 모아만 두는 것
- 사전 설계와 코드가 필요하겠지만, 배포나 버전 관리에 대한 부담이 없는데, 이 차이는 꽤 크다

방법 2 - 일차원 경계
- Client -> _SourviceBioundary_ <- ServiceImplement

방법 3 - 퍼사드 (Facade)
- 경계를 Facade 클래스로만 간단히 구현
- Client -> Facade -> Service1, Service2, Service 3...

## 25장. 계층과 경계
배경
- 시스템이 세 가지 컴포넌트 (UI, 업무 규칙, DB)로만 구성된다고 생각하기 쉽다
- 몇몇 시스템은 이로도 충분파지만, 대다수의 시스템에서 컴포넌트의 개수는 이보다 훨씬 많다

인터페이스와 의존성
- Boundary 인터페이스가 정의하는 API는 의존성 흐름의 상위에 위치한 컴포넌트에 속한다

결론
- YAGNI의 철학이 중요할 수도 있고, 이후에 새로운 경계를 추가하는 것에 대한 큰 위험이 중요할 수도 있다
- 이에 대해서 아키텍트가 미래를 내다봐야 하는데, 중요한 것은 이 결정이 일회성이 되어서는 안된다
   - 프로젝트 초반에는 구현할 경계와 무시할 경계가 무엇인지 쉽게 결정할 수 없다
   - 시스템의 발전을 계속 주목하면서 경계가 없어서 발생하는 첫 조짐을 잘 관찰해야 한다

## 26장. 메인(Main) 컴포넌트
메인 컴포넌트
- 메인 컴포넌트는 궁극적인 세부사항으로, 가장 낮은 수준의 정책이다
- 운영체제를 제외하면 어떤 것도 메인에 의존하지 않는다
- 메인은 클린 아키텍처에서 가장 바깥 원에 위치하는, 지저분한 저수준 모듈이라는 점이다
- 메인은 고수준의 시스템을 위한 모든 것을 로드한 후, 제어권을 고수준의 시스템에 넘긴다

## 27장. '크고 작은 모든' 서비스들
서비스 아키텍처
- 시스템의 아키텍처는 의존성 규칙을 준수하며 고수준의 정책을 저수준의 세부사항으로 분리하는 경계에 의해 정의된다
- 단순히 애플리케이션의 행위를 분리할 분인 서비스라면 값비싼 함수 호출에 불과하며, 아키텍처 관점에서 꼭 중요하다고 볼 수는 없다
- 결국 서비스는 프로세스나 플랫폼 경계를 가로지르는 함수 호출에 지나지 않는다

서비스 이점과 오류
1. 결합 분리의 오류
   - 시스템을 서비스들로 분리함으로써 얻게 되리라 예상되는 큰 이점중 하나는 서비스 사이의 결합이 확실히 분리된다는 점이다
   - 그런데 이런 분리는 개별 변수 수준에서는 분리가 되지만, 서비스 사이에 공유 자원이 존재한다면 더 강력하게 결합이 되어 버린다
2. 개발 및 배포 독립성의 오류
   - 대규모 엔터프라이즈 시스템은 서비스 기반 시스템 이외에도 모노리틱이나 컴포넌트 기반으로 구축할 수 있다. 유일한 선택지는 아니라는 말이다. 
   - 서비스라고해서 항상 독립적으로 개발, 배포, 운영할 수 있는 것은 아니다

횡단 관심사(Cross-cutting concern)의 문제
- 모든 소프트웨어 시스템은 서비스 지향이든 아니든 이 문제에 직면하게 된다
- 해결법
   - 서비스 내부는 의존성 규칙도 준수하는 컴포넌트 아키텍처로 설계해야 한다
      - 이 서비스들은 시스템의 아키텍처 경계를 정의하지는 않는다.
      - 기능 변경에 대해서 서비스의 존재는 변경이 없으면서, 확장 가능한 내부 구조에 기능을 추가해서 구현한다

결론
- 시스템의 아키텍처는 시스템 내부에 그어진 경계와 경계를 넘나드는 의존성에 의해 정의된다
- 시스템의 구성요소가 통신하고 실행되는 물리적인 매커니즘에 의해 아키텍처가 정의되는 것은 아니다

## 28장. 테스트 경계
시스템 컴포넌트인 테스트
- 테스트는 태생적으로 의존성 규칙을 따른다
- 테스트는 세부적이며 구체적인 것으로, 의존성은 항상 테스트 대상이 되는 코드를 향한다
- 실제로 테스트는 아키텍처에서 가장 바깥쪽 원으로 생각할 수 있다. 시스템 내부의 어떤 것도 테스트에는 의존하지 않는다

테스트를 고려한 설계
- 시스템에 강하게 결합된 테스트라면 시스템이 변경될 때 함께 변경되어야만 한다.
   - 시스템 컴포넌트에서 생긴 아주 사소한 변경도, 이와 결합된 수많은 테스트를 망가뜨릴 수 있다
- 깨지기 쉬운 테스트는 시스템을 뻣뻣하게 만든다는 부작용을 낳을 때가 많다. 
   - 시스템에 가한 간단한 변경이 대량의 테스트 실패로 이어진다는 사실을 알게 되면, 개발자는 그러한 변경을 하지 않으려 할 것이다
- 이 문제를 해결하려면 테스트를 고려해서 설계해야 한다
   - 변동성 있는 것에 의존하지 마라. 
      - 예를 들어 GUI는 변동성이 크다. 그리고 이러한 테스트는 깨지기 쉽다.
      - 따라서 GUI를 사용하지 않고 업무 규칙을 테스트할 수 있어야 한다

테스트 API
- 테스트 API는 테스트를 애플리케이션으로부터 분리할 목적으로 사용한다.<br>
단순히 테스트를 UI에서 분리하는 것만이 아니라, 테스트 구조를 애플리케이션 구조로부터 결합을 분리하는게 목표다
- 구조적 결합
   - 모든 상용 클래스에 테스트 클래스가 각각 존재하고, 또 모든 사용 메서드에 테스트 메서드 집합이 각각 존재한다고 생각해보자. 이는 애플리케이션 구조에 강하게 결합되어 있다.<br>
   상용 클래스나 메서드 중 하나라도 변경되면 딸려있는 다수의 테스트가 변경되어야 한다. 테스트는 깨지기 쉽고, 상용코드를 뻣뻣하게 만든다.

## 29장. 클린 임베디드 아키텍처
펌웨어
- 정의
   - 무엇에 의존하는지, 하드웨어 발전에 맞춰 수정하기가 얼마나 어려운지에 따라 정의된다
      - 임베디드 엔지니어가 아니라도 코드에 SQL을 심어 놓거나 개발하는 코드 전반에 플랫폼 의존성을 퍼뜨려 놓는다면, 본질적으로 펌웨어를 작성하는 것이다
   - 위치(예: ROM)에 기반하는 코드로 펌웨어를 정의하지는 않는다

소프트웨어를 구축하는 3가지 활동 (by Kent Beck)
1. 먼저 동작하게 만들어라
   - 소프트웨어가 동작하지 않는다면 사업은 망한다
2. 그리고 올바르게 만들어라
   - 코드를 리팩터링해서 당신을 포함한 나머지 사람들이 이해할 수 있게 만들고, 요구가 변경되거나 요구를 더 잘 이해하게 되었을 때 코드를 개선할 수 있게 만들어라
3. 그리고 빠르게 만들어라
   - 코드를 리팩터링해서 '요구되는' 성능을 만족시켜라
- 임베디드 개발자는 보통 1을 염두해두고 개발하거나 3에 집착한다. 

하드웨어나 OS에 대한 의존성을 줄이는 방법
- 하드웨어나 운영체제는 세부사항이기 때문에 코드를 분리시켜야 한다
- HAL(Hardware Abstract Layer)나 OSAL(Operation System Abstract Layer)를 만들어서 분리한다
   - 하드웨어 - 펌웨어 - __HAL__ - OS - __OSAL__ - 소프트웨어
   