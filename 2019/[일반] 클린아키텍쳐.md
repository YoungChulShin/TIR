기간 
- 시작: 2019.12.03 
- 종료: 

소감
- TBD
---
# 서문
소프트웨어 아키텍처의 규칙이란 프로그램의 구성요소를 정렬하고 조립하는 방법에 관한 규칙이다. 그리고 이 구성요소가 보편적이며 변하지 않았으므로, 이들을 정렬하는 규칙 역시도 보편적이며 변한 것이 없다. 

## 1장. 설계와 아키텍처란?
소프트웨어 아키텍처의 목표는 필요한 시스템을 만들고 유지보수하는 데 투입되는 인력을 최소화 하는데 있다.<br>
설계 품질을 재는 척도는 고객의 요구를 만족시키는 데 드는 비용을 재는 척도와 다름없다. 

개발자는 "코드는 나중에 정리하면 돼. 당장은 시장에 출시하는 게 먼저야!"라는 흔해 빠진 거짓말에 속는다. 이렇게 속아 넘어간 개발자라면 나중에 코드를 정리하는 경우는 한 번도 없는데, 시장의 압박은 절대로 수그러들지 않기 때문이다. '시장 출시가 먼저'라는 생각을 하는 이유는 바로 뒤에 여러 무리의 경쟁자가 뒤쫓고 있고, 경쟁자보다 앞서 가려면 가능한 한 빠르게 달려야 하기 때문이다.<br>
결국 개발자는 절대로 태세를 전환하지 않는다. 이전에 작성한 코드로 돌아가 정리하는 일은 일어나지 않는데, 바로 다음에 만들어야 할 새로운 기능이 기다리고 있고, 다음 기능, 또 다음 기능, 또 다음 기능이 계속 기다리고 있기 때문이다. 결국 엉망진창이 되고, 생산성은 0을 향해 수렴하기 시작한다. 

빨리 가는 유일한 방법은 제대로 가는 것이다.<br>
자신을 과신한다면 재설꼐 하더라도 원래의 프로젝트와 똑같이 엉망으로 내몰린다.
- _어떤 아키텍쳐가 좋은지 모른다면, 다시 설계해도 동일한 결과가 나온다_

## 2장. 두 가지 가치에 대한 이야기
모든 소프트웨어 시스템은 이해관계자에게 서로 다른 두 가지 가치를 제공하는데, 행위(behavior)와 구조(structure)가 바로 그것이다. 소프트웨어 개발자는 두 가치를 모두 반드시 높게 유지해야 하는 책임을 진다. 불행하게도 개발자는 한가지 가치에만 집중하고 나머지 가치를 배제하곤 한다. 

소프트웨어가 가진 본연의 목적을 추구하려면 소프트웨어는 반드시 '부드러워'야 한다. 다시 말해 변경하기 쉬워야 한다.(중략). 이러한 변경 사항을 적용하는 데 드는 어려움은 변경되는 범위(scope)에 비례해야 하며, 변경사항의 형태(shape)와는 관련이 없어야 한다. 

아키텍처가 특정 형태를 다른 형태보다 선호하면 할수록, 새로운 기능을 이 구조에 맞추는 게 더 힘들어진다. 따라서 아키텍처는 형태에 독립적이어야 하고, 그럴수록 더 실용적이다. 

아이젠하워 매트릭스의 우선 순위
1. 긴급하고 중요한 (아키텍처, 행위)
2. 긴급하지는 않지만 중요한 (아키텍처)
3. 긴급하지만 중요하지 않은 (행위)
4. 긴급하지도 중요하지도 않은

업무 관리자와 개발자가 흔하게 저지르는 실수는 세 번째에 위치한 항목을 첫 번째로 격상시켜 버리는 일이다. 다시 말해 긴급하지만 중요하지 않은 기능과 진짜로 긴급하면서 중요한 기능을 구분하지 못한다. 

## 3장. 패러다임 개요
3가지 패러다임
- 구조적 프로그래밍
- 객체 지향 프로그래밍
- 함수형 프로그래밍

## 4장. 구조적 프로그래밍
_4장은 한번 더 읽을 필요가 있음_

데이크스트라
- 모든 프로그램은 설령 단순할지라도 인간의 뇌로 감당하기에는 너무 많은 세부사항을 담고 있었다. 아주 작은 세부사항이라도 간과하면 프로그램이 동작하는 것처럼 보이더라도 결국엔 예외 방식으로 실패파곤 했다
- 증명(Proof)이라는 수학적 원리를 적용해서 이 문제를 해결하려고 노력

뵘, 야코피니
- 모든 프로그램을 순차(sequence), 분기(selection), 반복(interation)이라는 세가지 구조만으로 표현할 수 있다는 사실을 증명
- 모듈을 증명 가능하게 하는 바로 그 제어구조가 모든 프로그램을 만들 수 있는 제어 구조의 최소 집합과 동일하다는 사실이었다. 구조적 프로그래밍은 이렇게 탄생했다

## 5장. 객체 지향 프로그래밍
캡슐화
- OO ㅍ로그래밍은 프로그래머가 충분히 올바르게 행동함으로써 캡슐화된 데이터를 우회해서 사용하지 않을 거라는 믿음 기반으로 한다. 하지만 OO를 제공한다고 주창한 언어들이 실제로는 C언어에서 누렸던 완벽한 캡슐화를 약화시켜 온 것은 틀림없다. 
   - _C에서는 구조(=Header)와 구현(.c)이 분리되어 있기 때문에 완벽한 캡슐화가 가능하다_

상속

다형성
- C에서도 다형성은 구현 가능하다. 하지만 포인터를 응용한 다형성이기 때문에 구현의 어려움이 있다.<br>
OO언어를 사용하면 다형성은 대수롭지 않은 일이 된다. OO언어는 과거 C프로그래머가 꿈에서나 볼 수 있는 강력한 능력을 제공한다. 이러한 이유로 OO는 제어흐름을 간접적으로 전환하는 규칙을 부과한다고 결론지을 수 있다.
- 플러그인 아키텍쳐는 이처럼 입출력 장치 독립성을 지원하기 위해 만들어졌고, 등장 이후 거의 모든 운영체제에서 구현되었다. 그럼에도 대다수의 프로그래머는 직접 작성하는 프로그램에서는 이러한 개념을 확장하여 적용하지 않았는데, 함수를 가리키는 포인터를 사용하면 위험을 수반하기 때문이었다. OO의 등장으로 언제 어디서든 플러그인 아키텍쳐를 적용할 수 있게 되었다. (=의존성 역전)

의존성 역전
- OO언어가 다형성을 안전하고 편리하게 제공한다는 사실은 소소 코드의 의존성을 언제 어디에서든 역전시킬 수 있다는 뜻이기도 하다. 
- 이러한 접근법을 사용한다면, OO언어로 개발된 시스템을 다루는 소프트웨어 아키텍트는 시스템의 소스 코드 의존성 전부에 대해 방향을 결정할 수 있는 절대적인 권한을 갖는다. 즉, 소스 코드 의존성이 제어흐름의 방향과 일치되도록 제한되지 않는다. 호출하는 모듈이든 아니면 호출 받는 모듈이든 관계 없이 소프트웨어 아키텍트는 소스 코드 의존성을 원하는 방향으로 설정할 수 있다.<br>
이것이 힘이다! 이것이 바로 OO가 제공하는 힘이다. 그리고 이것이 바로 OO가 지향하는 것이다. 
- 배포 독립성 (Independent deployablity)
   - 특정 컴포넌트의 소스 코드가 변경되면, 해당 코드가 포함된 컴포넌트만 다시 배포하면 된다
- 개발 독립성 (Independent Developability)
   - 시스템의 모듈을 독립적으로 배포할 수 있게 되면, 서로 다른 팀에서 각자 모듈을 독립적으로 개발할 수 있다. 

__OO란 다형성을 이용하여 전체 시스템의 모든 소스 코드 의존성에 대한 절대적인 제어 권한을 획득할 수 있는 능력이다. OO를 사용하면 아키텍트는 플러그인 아키텍쳐를 구성할 수 있고, 이를 통해 고수준의 정책을 포함하는 모듈은 저수준의 세부 사항을 포함하는 모듈에 대해 독립성을 보장할 수 있다. 저수준의 세부사항은 중요도가 낮은 플러그인 모듈로 만들 수 있고, 고수준의 정책을 포함하는 모듈과는 독립적으로 개발하고 배포할 수 있다.__

## 6장. 함수형 프로그래밍
함수형 패러다임에서 핵심이 되는 기반은 람다(Lamda) 계산법으로 알로조 처지(Alonzo Church)가 1930대에 발명했다.

자바와 클로저의 차이 (정수 제곱 기능 예시)
- 자바 샘플 코드
   ```java
   for (int i = 0; i < 25; i++) {
      System.out.println(i*i);
   }
   ```
- 클로저 샘플 코드
   ```clojure
   (pintln(take 25 (map (fn [x] (* x x))(range))))
   ```

- 위 코드는 클로저와 자바의 프로그램 사이의 극단적인 차이를 보여준다.<br>
자바 프로그램은 가변 변수(mutable variable)를 사용하는데, 가변 변수는 프로그램 실행 중에 상태가 변할 수 있다. 앞의 예제에서 반복문을 제어하는 변수인 i가 가변 변수다. 클로저 프로그램에서는 이러한 가변 변수가 전혀 없다. 클로저에서는 x와 같은 변수가 한 번 초기화되면 절대로 변하지 않는다.<br>
이는 놀라운 사실을 알려주는데, 함수형 언어에서 변수는 변경되지 않는다

### 불변성과 아키텍쳐
아키텍쳐를 고려할 때 이러한 내용이 왜 중요한가? 아키텍트는 왜 변수의 가변성을 염려하는가? 터무없게도 대답은 단순하다. 경합(race) 조건, 교착상태(deadlock) 조건, 동시 업데이트(concurrent update) 문제가 모두 가변 변수로 인해 발생하기 때문이다. 만약 어떤 변수도 갱신되지 않는다면 경합 조건이나 동시 업데이트 문제가 일어나지 않는다. 락(lock)이 가변적이지 않다면 교착상태도 일어나지 않는다.<br>
다시 말해 우리가 동시성 애플리케이션에서 마주치는 모든 문제, 즉 다수의 스레드와 프로세스를 사용하는 애플리케이션에서 마주치는 모든 문제는 가변 변수가 없다면 절대로 생기지 않는다.<br>
아키텍트라면 동시성 문제에 지대한 관심을 가져야만 한다. 우리는 스레드와 프로세스가 여러 개인 상황에서도 설계한 시스템이 여전히 강건하기를 바란다. 그렇다면 이제 불변성이 정말로 실현 가능한지를 스스로에게 물어봐야 한다. 

### 가변성의 분리
불변성과 관련하여 가장 주요한 타협 중 하나는 애플리케이션, 또는 애플리케이션 내부의 서비스를 가변 컴포넌트와 불변 컴포넌트로 분리하는 일이다. 불변 컴포넌트에서는 순수하게 함수형 방식으로만 작업이 처리되며, 어떤 가변 변수도 사용되지 않는다. 불변 컴포넌트는 변수의 상태를 변경할 수 있는, 즉 순수 함수형 컴포넌트가 아닌 하나 이상의 다른 컴포넌트와 서로 통신한다. 

현명한 아키텍트라면 가능한 한 많은 처리를 불변 컴포넌트로 옮겨야 하고, 가변 컴포넌트에서는 가능한 한 많은 코드를 빼내야 한다. 

### 이벤트 소싱
기본 발상
- 데이터를 관리할 때 변경 시점(=Transaction)에 관련된 데이터를 변경하는 거이 아니라, 트랜잭션을 기준으로 모두 저장한다
- 시간이 지날수록 트랜잭션이 터무니 없이 증가하겠지만, 애플리케이션의 수명주기 동안이다

이벤트 소싱은 상태가 아닌 트랜잭션을 저장하는 전략이다. 상태가 필요해지면 단순히 상태의 시작점부터 모든 트랜잭션을 처리한다.<br>
더 중요한 점은 데이터 저장소에서 삭제되거나 변경되는 것이 하나도 없다는 사실이다. 결과적으로 애플리케이션은 CRUD가 아니라 그저 CR만 수행한다. 또한 데이터 저장소에서 변경과 삭제가 전혀 발생하지 않으므로 동시 업데이트 문제 또한 일어나지 않는다.<br>
저장 공간과 처리 능력이 충분하면 애플리케이션이 완전한 불변성을 갖도록 만들 수 있고, 따라서 완전한 함수형으로 만들 수 있다. 

# 2부 결론 (4장, 5장, 6장)
규율
- 구조적 프로그래밍은 제어흐름의 직접적인 전환에 부과되는 규율이다
- 객체지향 프로그래밍은 제어흐름의 간접적인 전환에 부과되는 규율이다
- 함수형 프로그래밍은 변수 할당에 부과되는 규율이다

__도구가 달라졌고 하드웨어도 변했지만, 소프트웨어의 핵심은 여전히 그대로다<br>
소프트웨어, 즉 컴퓨터 프로그램은 순차(sequence), 분기(selection), 반복(interation), 참고(indirection)로 구성된다. 그 이상도 그 이하도 아니다__

# 3부 설계 원칙
SOLID 원칙의 목적은 중간 수준의 소프트웨어구조가 아래와 같도록 만드는데 있다
- 변경에 유리하다
- 이해하기 쉽다
- 많은 소프트웨어 시스템에 사용될 수 있는 컴포넌트의 기반이 된다

'중간 수준' 이라 함은 프로그래머가 이들 원칙을 모듈 수준에서 작업할 대 적용할 수 있다는 뜻이다. 즉, 코드 수준보다는 조금 상위에서 적용되며 모듈과 컴포넌트 내부에서 사용되는 소프트웨어 구조를 정의하는데 도움을 준다

SRP(Single Responsible Principle)
- 소프트웨어 시스템이 가질 수 있는 최적의 구조는 시스템을 만드는 조직의 사회적 구조에 커다란 영향을 받는다. 따라서 각 소프트웨어 모듈은 변경의 이유가 하나, 단 하나여야만 한다. 

OCP(Open-Closed Principle)
- 기존 코드를 수정하기 보다는 새로운 코드를 추가하는 방식으로의 행위를 변경할 수 있도록 설계해야만 소프트웨어 시스템을 쉽게 변경할 수 있는 것이 이 원칙의 요지다

LSP(Liskov Substitution Principle)
- 상호 대체 가능한 구성요소를 이용해 소프트웨어 시스템을 만들 수 있으려면, 이들 구성요소는 반드시 서로 치환 가능해야 한다는 계약을 반드시 지켜야 한다

ISP(Interface Segregation Printciple)
- 소프트웨어 설계자는 사용하지 않는 것에 의존하지 않아야 한다

DIP (Dependency Inversion Principle)
- 고수준 정책을 구현하는 코드는 저수준 세부사항을 구현하는 코드에 절대로 의존해서는 안 된다. 대신 세부사항이 정책에 의존해야 한다. 

## 7장. SRP: 단일 책임 원칙
SRP의 잘못된 전달
- 모듈이 단 하나의 일만 해야 한다

SRP 원칙
- 하나의 모듈은 하나의, 오직 하나의 사용자 또는 이해관계자에 대해서만 책임져야 한다
- 하나의 모듈은 하나의, 오직 하나의 액터에 대해서만 책임져야 한다
   - _2개 이상의 액터를 위한 동작이 소스에 들어가면 특정 이해관계자를 위한 기능 변경이 다른 사람에게 영향을 줄 수 있다_
   - _각각의 이해당사를 위한 각자의 부서에서 개발될 수 있고 이를 병합하는 과정에서 어려움 또는 문제가 발생할 수 있다_
- 모듈의 가장 단순한 정의는 소스파일이다. 

_퍼사드(Facade) 패턴_