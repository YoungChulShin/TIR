# 아키텍처 개요
## 영역 설명
Presentaion
- 사용자의 요청을 받아서 Application에 전달하고, Application의 처리 결과를 다시 사용자에게 보여주는 역할

Application
- 시스템에 사용자에게 제공해야할 기능을 구현
- 예: 주문등록, 주문취소, 상세상품조회 와 같은 기능
- 이 기능을 구현하기 위해서 Domain 영역의 Domain Model을 이용한다
   - 로직을 직접 수행하기 보다는 Domain Model에 로직 수행을 위임한다
   - 주문취소라고 하면 `Order`라는 Domain Model을 가져와서 취소한다. 실제 취소 기능은 `Order` Domain Model에 구현되어 있다. 

Domain
- Domain의 핵심 로직을 구현
- 예: 배송지 변경, 결제완료, 주문총액 계산

Infrastructure
- DB연동, 메시지 처리 같은 구현 기술에 대한 것을 다룬다
- Application 영역에서 DB에 보관된 데이터가 필요하다면 Infrastructure 영역의 DB 모듈을 이용해서 데이터를 가져온다

## 계층 구조 아키텍처
### 일반적인 구조
Presentation -> Application -> Domain -> Infrastrucure

특정
- 상위계층에서 하위계층으로의 의존만 존재하고 하위계층은 상위계층에 의존하지 않는다
- 구현의 편리함을 위해서 계층구조는 유연하게 적용한다
   - **Application계층은 아래 계층인 Domain계층에 의존하지만 외부 시스템과의 연동을 위해서 더 아래 계층인 Infrastructure 계층에 의존하기도 한다**

주의 - 의존성!
- Presentation, Application, Domain 영역이 Infrastructure 계층을 이용할 때, Infrastructure 계층에 중속될 수 있다는 점을 주의해야 한다. (p.42)
- 예를 들면, Application에서 Infrastructure에 있는 특정 기술에 직접적으로 참조가 발생한다.이렇게 되면 아래 2가지 문제가 발생한다
   1. 테스트하기 어려운 코드
   2. 기능 확장의 어려움

### DIP
해결 - DIP
- 정의: 저수준 모듈이 고수준 모듈에 의존하도록 바꾼다. 
   - 고수준 모듈: 의미있는 기능을 하는 단일 기능을 제공하는 모듈 (상위 계층)
   - 저수준 모듈: 하위 기능을 실제로 구현한 것
   - 고수준 모듈이 제대로 동작하려면 저수준 모듈을 사용해야 하는데, 고수준 모듈이 저수준 모듈을 사용하면 테스트 어려움과 기능 확장의 어려움이 발생한다
- Interface를 이용해서 구현
   - Interface는 고수준 영역에 구현한다
- 주의 사항
   - DIP를 잘못 생각하면 단순히 인터페이스와 구현 클래스르르 분리하는 정도로 받아들일 수 있다. DIP의 핵심은 고수준 모듈이 저수준 모듈에 의존하지 않도록 하기 위함이다

**DIP와 아키텍쳐**
- DIP를 적용하면 저수준 Infrastructure 계층이 Application과 Domain 계층에 의존하는 구조가 된다

## Domain 영역의 주요 구성요소
### 주요 구성 요소
|요소|설명|
|--|--|
|Entity|고유의 식별자를 갖는 객체로 자신의 라이프사이클을 갖는다.<br>오더(Order), 회원(Member), 상품(Product)과 같이 도메인의 고유한 개념을 표현한다. 도메인 모델의 데이터를 포함하며 해당 데이터와 관련된 기능을 함께 제공한다|
|Value|고유한 식별자를 갖지 않는 객체로 개념적으로 하나인 도메인 객체의 속성을 포현할 때 사용된다.<br>배송 주소를 표현하기 위한 Address나 금액을 위한 Money같은 타입이 속한다|
|Aggregate|Entity와 Value 객체를 개념적으로 하나로 묶은 것이다.<br>예를 들어 주문과 관련된 Order entity, OrderLine value, Orderer value 객체를 '주문' Aggregate로 묶을 수 있다.|
|Repository|도메인 모델의 영속성을 처리한다.<br>예를 들어, DBMS 테이블에서 엔티티 객체를 로딩하거나 저장하는 기능을 제공한다|
|Domain Service|특정 엔티티에 속하지 않은 도메인 로직을 제공한다.<br>예를 들어, '할인 상품 계산'은 상품, 쿠폰, 회원 등급 등 다양한 조건을 이용해서 구현하게 되는데, 이렇게 도메인 로직이 여러 엔티티와 밸류를 필요로 할 경우 도메인 서비스에서 로직을 구현한다|

### 애그리거트 (Aggregate)
정의: 관련 객체를 하나로 묶은 군집

애그리거트는 군집에 속한 객체들을 관리하는 루트 엔티티를 갖는다. 
- 루트 엔티티는 애그리거트에 속해 있는 엔티티와 밸류 객체를 이용해서 애그리거트가 구현해야 할 기능을 제공한다
- 애그리거트 루트를 통해서 간접적으로 애그리거트 내의 다른 엔티티나 밸류 객체에 접근하게 된다

### 리포지터리 (Repository)
리포지터리는 애그리거트 단위로 도메인 객체를 저장하고 조회하는 기능을 정의한다. 
- 엔티티나 밸류: 요구사항에서 도출되는 도메인 모델
- 리포지터리: 구현을 위한 도메인 모델
   ```c#
   // 주문 애그리거트를 위한 리포지터리
   // 대상을 찾고, 저장하는 단위가 애그리거트 루트인 Order이다
   public interface OrderRepository 
   {
      public Order findByNumber(OrderNumber number);
      public void save(Order order);
      public void delete(Order order);
   }
   ```

구조
- Application: `CancelOrderService`
   - DI를 통해서 실제 리포지터리 구현 객체에 접근한다
- Domain: `Order<Root>`, `OrderRepository<Interface>`
- Infrastructure: `JpaOrderRepository`

**응용서비스와 리포지터리 관계**
- 응용서비스는 필요한 도메인 객체를 구하거나 저장할 때 리포지터리를 사용한다
   - 리포지터리 구현 객체는 Interface를 통해서 DI 를 통해 사용
- 응용 서비스는 트랜잭션을 관리하는데, 트랜잭션 처리는 리포지터리 구현 기술에 영향을 받는다

리포지터리의 사용주체가 응용서비스이기 때문에 리포지터리는 응용 서비스가 필요로 하는 메서드를 제공한다
- 애그리거트를 저장하는 메서드
- 애그리거트 루트 식별자로 애그리거트를 조회하는 메서드
   ```c#
   public interface SomeRepository
   {
      void Save(Some some);
      Some findById(SomeId id);
   }
   ```


# 애그리거트
### 특징
- 복잡한 도메인을 이해하고 관리하기 쉬운 단위로 만들려면 상위 수준에서 모델을 조망할 수 있는 방법이 필요한데, 그 방법이 애그리거트다
- 수많은 객체를 애그리거트로 묶어서 바라보면 더 상위 수준에서 모메인 모델간의 관계를 파악할 수 있다
- 애그리거트는 관련된 모델을 하나로 모은 것이기 때문에 한 애그리거트에 속헤 객체는 유사하거나 동일한 라이프사이클을 갖는다
- 한 애그리거트에 속한 객체는 다른 애그리거트에 속하지 않는다. 자기 자신을 관리할 뿐 다른 애그리거트를 관리하지 않는다. 
- 도메인 규칙에 따라 함께 생성되는 구성요소는 한 애그리거트에 속할 가능성이 높다
   - 예: 주문할 상품 개수, 배송지 정보, 주문자 정보는 주문 시점에 함께 생성되므로 이들은 한 애그리거트에 속한다
- 'A가 B를 갖는다'라고 하면 한 애그리거트로 묶어서 생각하기 쉽지만 필수는 아니다
   - 묶는 경우: 주문의 경우 Order가 ShippingInfo와 Orderer를 가지므로 타당성이 있다
   - 분리 경의: Product와 Review는 2개가 함께 생성되지 않고 함께 변경되지도 않는다. 게다가 Product의 변경 주체는 상품담당자라면 Review는 고객이다


## 애그리거트 루트
- 애그리거트는 여러 객체로 구성되기 때문에 한 객체만 상태가 정상이어서는 안된다. 
- 애그리거트에 속한 모든 객체가 일관된 상태를 유지하려면 애그리거트 전체를 관리할 주체가 필요한데 이 책임을 지는 것이 바로 애그리거트의 루트 엔티티이다. 

### 도메인 규칙과 일관성
- 애그리거트 루트의 핵심 역할은 애거리거트의 일관성이 깨지지 않도록 하는 것이다. 이를 위해서 애그리거트 루트는 애그리거트가 제공해야 할 도메인 기능을 구현한다.<br>
예를 들어, 주문 애그리거트는 배송지 변경, 상품 변경과 같은 기능을 제공하는데 애그리거트 루트인 Order가 이 기능을 구현한 메서드를 제공한다
- **애그리거트 루트가 아닌 다른 객체가 애그리거트에 속한 객체를 직접 변경하면 안된다. 이는 애그리거트 루트가 강제하는 규칙을 적용할 수 없어 모델의 일관성을 깨는 원인이 된다**
   ```c#
   ShippingInfo si = order.GetShippingInfo();
   so.setAddress(newAddress);    // 루트인 Order가 아니라 ShippingInfo에서 배송 정보를 변경하고 있다
   ```
- 불필요한 중복을 피하고, 애그리거트 루트를 통해서만 도메인 로직을 구현하게 만들려면 아래 2가지를 습관적으로 적용해야 한다
   1. 단순히 필드를 변경하는 set 메서드를 public으로 만들지 않는다
   2. value 타입은 불변으로 구현한다

### 애그리거트 루트의 기능 구현
- 애그리거트 루트는 애그리거트 내부의 다른 객체를 조합해서 기능을 완성한다
   - 예: Order는 총 주문 금액을 구하기 위해서 OrderLine 목록을 사용한다
   ```c#
   public class Order 
   {
      private Money totalAmounts;
      private List<OrderLine> orderLines;

      private void calculateTotalAmounts()
      {
         int sum = orderLines.stream()
                   .mapToInt(ol -> ol.getPrice() * ol.quantity()).sum();
         this.totlaAmounts = new Money(sum);
      }
   }
   ```

### 트랜잭션 범위
- 한 트랜잭션에서는 한 개의 애그리거트만 수정해야 한다. 이는 애그리거트에서 다른 애그리거트를 변경하지 않는다는 것을 뜻한다.<br>
예를 들어 배송지 정보를 변경하면서 동시에 배송지 정보를 회원의 주소로 설정하는 기능이 있을 때, 주문 애그리거트는 회원 애그리거트의 정보를 변경하면 안된다.
   ```c#
   public class Order
   {
      private Orderer orderer;

      public void shipTo(.....)
      {
         verifyNotYetShipped();
         setShippingInfo(newShippingInfo);   // 배송지 정보 변경
         if (xxxx)
         {
            orderer.getCustomer().changeAddress(...); // 다른 애그리거트의 상태를 변경하면 안됨!
         }
      }
   }
   ```
- 이렇게 되면 애그리거트간 결합도가 높아지게 된다. 결합도가 높아지면 수정 비용이 증가하므로 피해야 한다. 
- 만약 부득이하게 두개 이상의 애그리거트를 수정해야 한다면, 응용 서비스(Application)에서 두 애그리거트를 수정하도록 구현해야 한다. 

## 리포지터리와 애그리거트
애그리거트는 개념상 한 개의 도메인 모델을 표현하므로 객체의 영속성을 처리하는 리포지터리는 애그리거트 단위로 존재한다
   - 예: Order와 OrderLine이 물리적으로 별도의 DB에 저장된다고 해도, Order가 애그리거트 루트이고 OrderLine이 구성요소 이므로 Order를 위한 리포지터리만 존재한다

새로운 리포지터리를 만들면 적어도 아래 2개의 기능이 지원되어야 한다
- save: 애그리거트 저장
- findById: ID로 애그리거트를 구함

## ID를 이용한 애그리거트 참조
애그리거트의 관리 주체가 애그리거트 루트이므로 애그리거트에서 다른 애그리거트를 참조한다는 것은 애그리거트의 루트를 참조한다는 것과 같다
   ```c#
   // Order Aggregate
   public class Order 
   {
      private Orderer orderer;
   }
   public class Orderer
   {
      private Member member;
   }

   // Member Aggregate
   public class Member {}
   ```

### 한 애그리거트에서 다른 애그리거트를 참조할 때 발생할 수 있는 문제
- 편한 탐색 오용
   - 애그리거트가 관리하는 범위는 자기 자신으로 한정되어야 하는데, 다른 애그리거트로 접근이 편리해지면 수정하고자 하는 유혹에 빠지기 쉽다
      ```c#
      orderer.getCustomer().changeAddress(XXXX);   // Order Aggregate에서 Member Aggregate를 변경 시도
      ```
- 성능 저하
- 확장
   - 사용자가 늘고 트래픽이 증가하면서 도메인별로 시스템이 분리될 수 있다.
      - 서로 다른 DBMS를 사용할 수 있고, 또는 SQL, NOSQL로 분리될 수도 있다
   - 이렇게 되면 JPA(=ORM)을 이용해서 애그리거트 루트를 참조하는게 어려워 질 수 있다

### ID를 이용한 참조
- `편한 탐색 오용`은 ID를 이용한 참조를 통해서 해결할 수 있다.<br>
- ID 참조를 이용하면 모든 객체가 참조로 연결되지 않고 한 애그리거트에 속한 객체들만 참조로 연결된다
   - 애그리거트간 물리적인 연결을 제거하기 때문에 모델의 복잡도를 낮춘다
   - 애그리거트간의 의존을 제거하므로 응집도를 높여준다
   - 구현 복잡도도 낮아진다
   - 애그리거트 별로 서로 다른 구현 기술(예: RDBMS, NoSQL)도 가능하다
- 속도
   - ID 참조를 사용할 경우에 서로 다른 애그리거트 데이터를 가져오려면 각각의 쿼리가 실행되어야 해서 속도 이슈가 있다
   - 이 경우 전용 조회 쿼리를 사용한다. 데이터 조회를 위한 별도의 DAO를 만든다

## 애그리거트를 팩토리로 사용하기
중요한 도메인 로직 처리가 응용 서비스(=Application Layer)에 노출되었을 경우, 도메인에서 해당 기능을 구현하는 것을 검토해볼 필요가 있다

### 예시
```c#
public class RegisterProductService
{
   public ProductId registerNewProduct(....) 
   {
      Store account = accountRepository.findStoreById(....);
      // 상점이 생성 가능한지 테스트
      // Product 생성
      productRepository.save(product);
   }
}
```
- 위 코드는 Store가 Product를 생성할 수 있는지 여부를 판단하고 Product를 생성한다. 그런데 이는 논리적으로 하나의 도메인 기능인데 분리되어 있을 뿐 아니라, 이 기능을 응용 서비스에서 구현하고 있다. 
- 애그리거트가 갖고 있는 데이터를 이용해서 다른 애그리거트를 생성해야 한다면 애그리거트 팩토리 메서드를 구현하는 것을 고려해봐야 한다. 
- 위 예시에서 Product의 경우 Store의 식별자를 필요로 한다. 즉 Store의 데이터를 이용해서 Product를 생성한다. 그리고 Product를 생성할 수 있는 조건을 판단할 때 Store의 상태를 이용한다. 따라서 Store에 Product를 생성하는 팩토리 메서드를 추가하면 Product를 생성할 때 필요한 데이터의 일부를 직접 제공하면서 동시에 도메인로직을 구현할 수 있다. 

```c#
public class Store extends Member 
{
   public Product createProduct(....)
   {
      // 상점이 생성 가능한지 테스트
      // Product 생성
   }
}

public class RegisterProductService
{
   public ProductId registerNewProduct(....) 
   {
      Store account = accountRepository.findStoreById(....);
      // 상점이 생성 가능한지 테스트
      Product product = account.createProduct(...) // store를 이용해서 product 생성
      productRepository.save(product);
   }
}
```

# 4. 리포지터리와 모델 구현 (JPA 중심)
### 모듈 위치
- 인터페이스: Domain 영역
- 인터페이스 구현: Infrastucture 영역

### 리포지터리 기본 기능 구현
두가지 기능 구현

# 6. 응용 서비스와 표현 영역
## 표현 영역과 응용 영역
표현 영역 (Presentation Layer)
- 사용자의 요청을 해석
- 웹 브라우저라고 하면 전달된 웹 정보를 해석해서 그 기능을 제공하는 응용 서비스를 실행한다
   - 이때 응용 서비스가 요구하는 형식으로 사용자 요청을 변환한다

응용 영역 (Application Layer)
- 실제 사용자가 기능을 제공하는 서비스가 위치
- 응용 영역은 사용자가 웹 브라우저를 사용하는지 REST API를 호출하는지 알 필요가 없다.<br>
단지 실행에 필요한 입력 값을 전달 받고 실행 결과만 리턴하면 될 뿐이다

## 응용 서비스의 역할
- 주요 역할은 도메인 객체를 사용해서 사용자의 요청을 처리하는 것
   - 도메인 객체는 리포지터리로 부터 구한다
- 기능 예시
   ```c#
   // 예시 1
   public Result DoSomeFunc(SomeReq req) 
   {
      // 1. 리포지터리에서 애그리거트를 구한다
      SomeAgg agg = SomeAggRepository.findById(req.getId());
      CheckNull(agg);

      // 2. 애그리거트의 도메인 기능을 실행한다
      agg.doFunc(req.GetValue());

      // 3. 결과를 리턴한다
      return CreateSuccessResult(agg);
   }

   // 예시 2
   public Result DoSomeCreation(CreateSomeReq req) 
   {
      // 1. 데이터 유효성 검사
      CheckValid(req);

      // 2. 애그리거트를 생성
      SomeAgg newAgg = CreateSome(req);

      // 3. 리포지터리에 애그리거트를 저장한다
      SomeAggRepository.Save(newAgg);

      // 4. 결과를 리턴한다
      return CreateSuccessResult(newAgg);
   }
   ```
   - 응용 서비스가 이것보다 복잡하다면 응용 서비스에서 도메인 로직의 일부를 구현하고 있을 가능성이 높다

- 트랜잭션 범위에서 응용 서비스를 실행해야 한다

### 응용 서비스에 도메인 로직을 넣지 않기
1. 응집도가 떨어진다
   - 수정해야 할 곳이 여기저기 퍼진다
2. 코드 중복이 발생한다
   - 여러 서비스에서 동일 기능을 구현할 가능성이 있다

## 응용 서비스의 구현
### 응용 서비스 크기
서비스를 구현하는 방법
- 한 응용 서비스 클래스에 모든 기능 구현하기
- 구분되는 기능별로 응용 서비스 클래스를 따로 구현하기


한 응용 서비스 클래스에 모든 기능 구현하기
- 장점
   - 관련된 기능이 모두 한 곳에 위치하므로 동일 로직에 대한 코드 중복을 제거할 수 있다
- 단점
   - 서비스 클래스의 크기가 커진다
   - 연관성이 적은 코드가 섞여서 코드를 이해하는데 방해가 될 수 있다
      - 특정 몇개 함수에서 사용되는 변수가 존재할 수 있다
   - 기능을 분리하기 좋은 상황임에도 습관적으로 기존에 존재하는 코드에 넣게 된다 -> 코드 품질이 떨어진다

구분되는 기능별로 응용 서비스 클래스를 따로 구현하기
- 구현
   - 한 클래스에서 1~3개 정도의 기능을 구현한다
   - 중복되는 코드는 별도의 Helper 클래스를 만들어서 구현한다
- 장점
   - 코드 품질을 일정 수준으로 유지하는데 도움이 된다

### 인터페이스
인터페이스와 클래스를 따로 구현하면 소스 파일만 많아지고 구현클래스에 대한 간접 참조가 증가해서 전체 구조만 복잡해지는 문제가 발생한다.<br>
따라서 인터페이스가 명확하게 필요하기 전까지는 응용 서비스에 대한 인터페이스를 작성하는 것이 좋은 설계라고 볼 수 없다

### 메서드 파라미터와 값 리턴
메서드 파라미터
- 도메인을 이용해서 사용자가 요구한 기능을 실행하는데 필요한 값을 파라미터를 통해 전달 받아야 한다
- 별도의 데이터 클래스를 만들어서 전달 받을 수도 있다

값 리턴
- 표현 영역에서 필요한 데이터만 리턴한다

### 표현영역에 의존하지 않기
응용서비스는 파라미터나 리턴 값으로 표현영역의 기술을 사용하지 않아야 한다
- 응용 서비스 단독 테스트가 어려워진다
- 표현영역이 변경되면 응용 서비스의 구현도 함께 변경해야 한다
- 응용 서비스가 표현 영역의 역할을 대신할 수도 있다

### 도메인 이벤트 처리
응용 서비스의 역할 중 하나는 도메인 영역에서 발생시킨 이벤트를 처리하는 것이다
- 예: 암호 변경됨, 주문 취소함 등 

이벤트 사용 이유
- 직접 이벤트의 기능을 구현하는 기능을 넣어도 되는데, 이벤트를 사용하는 이유는 도메인간의 의존성이나 시스템에 대한 의존을 낮춰주는 장점이 있다

## 표현 영역
책임
- 사용자가 시스템을 사용할 수 있는 (화면)흐름을 제공하고 제어한다
- 사용자의 요청을 알맞은 응용 서비스에 전달하고 결과를 사용자에게 제공한다
- 사용자 세션을 관리한다

## 값 검증
원칙적으로 모든 값에 대한 검증은 응용서비스에서 처리한다. 그런데 이 경우 에러가 2개 이상일 때, 표현영역에서는 한번에 모든 에러를 보여주지 못할 때가 있다.

응용 서비스를 사용하는 표현 영역 코드가 한곳이라면 아래와 같이 검증을 나누어 구현할 수 도 있다. 
- 표현 영역: 필수 값, 값의 형식, 범위 등을 검증한다
- 응용 서비스: 데이터의 존재 유무와 같은 논리적 오류를 검증한다

## 권한 검증

## 조회 전용 기능과 응용 서비스
응용 서비스가 존재해야 한다는 강박관념을 가지면, 컨트롤러와 같은 표현 영역에서 응용 서비스 없이 조회 전용 기능이나 도메인 리포지터리에 접근하는 것이 처음에는 이상하게 느껴질 수 있다.<br>
하지만 응용 서비스가 사용자 요청 기능을 실행하는 데 별다른 기여를 하지 못한다면 굳이 서비스를 만들지 않아도 된다고 생각한다. 
- Controller -> 조회 응용 서비스 -> 조회 전용 기능 (DAO/리포지터리)
- Controller -> 조회 전용 기능

# 7. 도메인 서비스
## 여러 애그리거트가 필요한 기능
도메인 영역의 코드를 작성하다면 한 애그리거트로 기능을 구현할 수 없을 때가 있다. 

한 애그리거트에 넣기에 애매한 도메인 기능을 특정 애그리거트에 억지로 구현하면 안된다. 

## 도메인 서비스
- 응용 서비스가 응용 로직을 다른다면 도메인 서비스는 도메인 로직을 다른다
- 도메인 영역의 애그리거트나 밸류와 다른 점이라면 상태 없이 로직만 구현한다는 점이다
- 사용 주체는 애그리거트가 될 수도 있고, 응용 서비스가 될 수도 있다
   - 애그리거트 객체에 도메인 서비스를 전달하는 것은 응용 서비스 책임이다
- 특정 기능이 응용 서비스인지 도메인 서비스인지 감을 잡기 어려울 때는 해당 로직이 애그리거트의 상태나 값을 변경하는지 검사해보면 된다

### 패키지 위치
도메인 서비스는 도메인 로직을 실행하므로 동일 패키지에 위치한다

### 도메인 서비스의 인터페이스와 클래스
도메인 서비스의 로직으 고정되어 있지 않을 경우에는 서비스 자체를 인터페이스로 구현하고 이를 구현한 클래스를 둘 수 있다

# 8. 애그리거트 트랜잭션 관리
## 애그리거트와 트랜잭션
2개 이상의 스레드가 1개의 애그리거트에 접근할 때 트랜잭션에 대한 잠금이 없으면 일관성이 깨질 수 있다.<br>
이를 막기 위해서 아래 2개의 방법 중 하나를 선택해야 한다
   - A가 값을 조회하고 상태를 변경하는 동안, B가 애그리거트에 접근하지 못하게 한다
   - A가 값을 조회한 이후에 B가 값을 변경하면, A가 애그리거트를 다시 조회한 뒤에 수정하도록 한다

이는 애그리거트 자체의 트랜잭션과 관련이 있는데, DBMS가 지원하는 트랜잭션과 함께 애그리거트를 위한 추가적인 트랜잭션 처리 기법이 필요하다

## 선점 잠금
기능
- 애그리거트를 구한 스레드가 사용이 끝날 때까지 다른 스레드가 애그리거트를 수정하는 것을 막는 방식
- DBMS가 제공하는 행 단위 잠금을 사용해서 구현

### 교착 상태
상대적으로 사용자 수가 많을 경우에는 교착 상태(Deadlock)이 발생할 수 있다.

이런 문제를 막기 위해서 잠금을 구할 때 최대 대기 시간을 지정해야 한다. 

## 비선점 잠금
모든 케이스에 대해서 선점 잠금을 적용할 수 없다(항상 잠금을 가지고 있을 수 없기 때문이다). 이 경우 적용할 수 있는 것이 비선점 잠금이다. 

구현 방법
- 애그리거트에 버전으로 사용할 숫자 타입의 프로퍼티를 추가한다
- 수정할 애그리거트와 매핑되는 테이블의 버전 값이 동일할 경우에만 값을 업데이트 한다
- 쿼리를 수행한 결과에 대해서 행의 개수가 0이면 누군가 데이터를 수정한 것이기 때문에 트랜잭션 종료 시점에 Exception을 발생시킨다

# 9. 도메인 모델과 BOUNDED CONTEXT
## 모데인 모델과 경계
처음 도메인 모델을 만들 때 빠지기 쉬운 함정은 도메인을 완벽하게 표현하는 단일 모델을 만드는 시도를 하는 것이다<br>
이렇게 되면 한 도메인은 다시 여러개의 하위 도메인으로 구분되기 때문에 여러 하위 도메인을 모두 표현하려고 시도하면 하위 도메인에 맞지 않는 모델을 만들게 된다

하위 도메인마다 사용하는 용어가 다르기 때문에 올바른 모델을 개발하려면 하위 도메인마다 모델을 만들어야 한다
   - 사용자의 경우 아래와 같이 모메인 마다 용어와 의미가 다르다
      - 회원 도메인: 회원
      - 주문 도메인: 주문자
      - 배송 도메인: 보내는 사람
   
## Bounded Context
이상적으로 하위 도메인과 Bounded Context가 1:1 관계를 가지면 좋겠지만 현실은 그렇지 않을 때가 많다

비록 한개의 Bounded Context에서 여러 하위 도메인을 포함하더라도 하위 도메인마다 구분되는 패키지를 갖도록 구현해야 하위 도메인을 위한 모델이 서로 뒤섞이지 않아서 하위 도메인마다 Bounded Context를 갖는 효과를 낼 수 있다

## Bounded Context의 구현
Bounded Context는 모데인 모델만 포함하는 것은 아니고, 도메인 기능을 사용자에게 제공하는데 필요한 표현, 응용서비스, 인프라 영역등을 모두 포함한다

CQRS (Command Query Responsibility Segregation)
- 상태를 변경하는 명령 기능과 내용을 조회하는 쿼리 기능을 위한 모델을 구분하는 패턴

## Bounded Context간 통합
기존에 있는 시스템을 다른 시스템과 연동을 해야 한다면 통합작업이 필요하다. 

예를 들어서 기존 카탈로그 시스템이 있는데, 추천 시스템이 추가되는 상황을 가정해보자
- 사용자가 카탈로그 Bounded context에 추천 제품 목록을 요청하면 카탈로그 bounded context는 추천 bounded context로부터 추천 정보를 읽어와서 추천 제품 목록을 보여준다
- 두 context의 도메인 모델은 다르기 때문에 도메인 모델간의 변경 작업이 필요하다. 
- 여기서는 추천 시스템이 카탈로그 시스템으로 데이터를 보내주기 때문에 카탈로그 시스템에서는 추천 시스템의 데이터를 받아서 카탈로그 시스템으로 변환해주는 기능을 추가해야 한다

   ```java
   // RecSystemClient 는 Infra 영역에 위치한 클래스
   // 외부 추천 시스템으로 부터 REST Api를 통해서 데이터를 가져온다
   // Interface는 도메인 영역에 선언되어 있다
   // 리턴 값은 카탈로그 시스템에서 사용하는 List<Product> 이다
   public class RecSystemClient implements ProductRecommendationService {
      @Override
      public List<Product> getRecommendationsOf(ProductId id) {
         // 구현 
      }
   }
   ```

## Bounded Context간 관계
Open Host Service
- 한쭉에서 API를 제공하고 다른 한쪽에서 호출하는 형식
- 제공하는 쪽을 상류(upstream) 또는 공급자라고 하고, 제공 받는 쪽은 하류(downstream) 또는 고객이라 한다
- 상류 컴포넌트는 하류 컴포넌트가 사용할 수 있는 통신 프로토콜을 정의하고 이를 공개한다
- 하퓨 컴포넌트에서는 상류 서비스의 모델이 자신의 도메인 모델에 영향을 주지 않게 하기 위해서 완충 지대를 만드는데 이를 `Anticorruption Layer`라고 한다.<br>
위 예에서 `RecSystemClient`가 그 역할을 한다
- 두 Bounded Context가 모델을 공유하는 경우도 있는데, 이를 공유 커널(Shared Kernel)이라고 한다

Separate Way
- 서로 통합하지 않는 것
- 수기로 통합하거나, 통합 시스템을 구축

## 컨텍스트 맵
Bounded Context 간의 관계를 정의

# 10. 이벤트
## 시스템간 강결합의 문제
쇼핑몰에서 구매를 취소하면 환불을 해주는 경우를 생각해보자
- 환불을 실행하는 주체는 주문 도메인이다
- 도메인 객체에서 환불 기능을 수행하려면 환불 기능을 제공하는 도메인 서비스를 파라미터로 전달 받고 취소 기능을 수행하게 된다
- 이 경우 아래 2가지 문제가 발생할 수 있다
   1. 외부 시스템이 정상이 아닐 경우 트랜잭션을 어떻게 처리해야 할까?
      - 환불 과정에서 실패했으면 주문 취소 트랜잭션을 롤백해야 할 수 있다
      - 아니면 취소 상태로 변경하고, 환불은 나중에 처리할 수도 있다
   2. 성능
      - 서비스의 수행 속도가 늦어지면 전체적인 시스템 성능에 영향을 미친다
   3. 로직
      - 서비스로 인해서 메서드에서 처리하는 로직이 기능적으로 2개가 될 수 있다
      - 위 예에서는 주문 로직(=주문 취소)과 결제 로직(=환불)이다

이벤트를 이용해서 이 문제를 해결할 수 있다

## 이벤트 개요
도메인 모델에서도 UI컴포넌트와 유사하게 상태 변경을 이벤트로 표현할 수 있다.
- 예를 들어 `주문을 취소할 때 이벤트를 보낸다`라는 요구사항을 보면 `주문을 취소할 때`가 주문의 상태가 변경되는 것이기 때문에 `주문 취소됨 이벤트`를 활용해서 구현할 수 있다

이벤트 관련 구성 요소<br>
- [이벤트 생성 주체]  <<- 이벤트 ->>   [이벤트 디스패처(이벤트 퍼블리셔)]   <<- 이벤트 ->>   [이벤트 핸들러(이벤트 구독자)]
- 이벤트 주체
   - 엔티티, 밸류, 도메인 서비스와 같은 도메인 객체
   - 도메인 로직을 실행해서 상태가 바뀌면 관련 이벤트를 발생한다
- 이벤트 핸들러
   - 이벤트 주체가 발행한 이벤트에 반응한다
- 이벤트 디스패처
   - 이벤트 생성 주체는 이벤트를 생성해서 디스패처에 이벤트를 전달한다
   - 이벤트를 전달 받은 디스패처는 해당 이벤트를 처리할 수 있는 핸들러에 이벤트를 전파한다

### 이벤트의 구성
- 이벤트 구성
   - 이벤트 종류: 클래스 이름으로 이벤트 종류를 표현
   - 이벤트 발생 시간
   - 추가 데이터: 주문번호, 신규 배송지 정보등 이벤트와 관련된 정보
- 이벤트는 현재 기준으로 과거에 벌어진 것을 표현하기 때문에 이벤트 이름에는 과거 시제를 사용한다
- 이벤트는 이벤트 핸들러가 작업을 수행하는데 필요한 최소한의 데이터를 담아야 한다
   - 이 데이터가 부족할 경우에는 핸들러는 필요한 데이터를 읽기 위해 관련 API를 호출하거나 DB에서 데이터를 직접 읽어와야 한다

### 이벤트 용도
1. 트리거
   - 도메인의 상태가 바뀔때 다른 후처리를 해야 할 경우 후처리를 실행하기 위한 트리거로 이벤트를 사용할 수 있다
2. 서로 다른 시스템 간의 데이터 동기화

### 이벤트의 장점
- 서로 다른 도메인 로직이 섞이는 것을 방지
   - 처음 예시에서는 환불 로직을 이벤트로 분리할 수 있다
- 기능 확장이 편리하다
   - 핸들러를 구현하고 디스패처에 등록하면 되기 때문에

## 비동기 이벤트 처리
우리가 구현해야 할 것들 중에서 `A하면 이어서 B하라` 는 내용을 담고 있는 요구사항은 실제로 `A하면 최대 언제까지 B하라`인 경우가 많다. 즉 후속조치를 바로 할 필요 없이 일정 시간 안에만 처리하면 되는 경우가 적지 않다. 

앞에서 말했지만 `A하면 이어서 B하라`는 요구사항 중에서 `A하면 최대 언제까지 B하라`로 바꿀 수 있는 요구 사항은 이벤트를 비동기로 처리하는 방식으로 바꿀 수 있다. 

처리 방식
1. 로컬 핸들러의 비동기 실행
   - 이벤트 핸들러를 별도 스레드로 실행하는 방식
   - 별도 스레드로 이벤트 핸들러를 사용한다는 것은 raise() 메서드와 관련된 트랜잭션 범위에 이벤트 핸들러 실행이 묶이지 않는 것을 의미한다.<br>
   따라서 한 트랜잭션으로 실행해야 하는 이벤트 핸들러는 비동기로 처리해서는 안된다
2. 메시지 큐를 사용
   - RabbitMQ나 Kafka같은 메시지 큐 프로그램
   - 많은 경우 메시지 큐를 사용하면 보통 이벤트를 발생하는 주체와 이벤트 핸들러가 별도 프로세스에서 동작한다
3. 이벤트 저장소와 이벤트 포워더 사용
   - 이벤트 정보를 DB에 저장하고, 별도의 포워더가 저장소에서 이벤트를 가져와서 이벤트 핸들러로 보내는 방식
   - 도메인의 상태와 이벤트 저장소로 동일한 DB를 사용한다. 즉 도메인의 상태 변화와 이벤트 저장이 로컬 트랜잭션으로 처리된다
   - 이벤트를 물리적 저장소에 바관하기 때문에 핸들러가 이벤트 처리에 실패할 경우, 포워더는 다시 이벤트 저장소에서 이벤트를 읽어와 핸들러를 실행하면 된다
   - 이벤트를 어디까지 처리했는지 추적하는 역할이 포워더에게 있다
4. 이벤트 저장소와 이벤트 제공 API 사용
   - REST와 같은 방식으로 이벤트를 외부에 제공하는 방식
   - 이벤트 목록을 요구하는 외부 핸들러가 자신이 어디까지 이벤트를 처리했는지 기억해야 한다

## 이벤트 적용 시 고려사항
1. 이벤트 소스를 EventEntry에 추가할지 여부
2. 포워더에서 전송 실패를 얼마나 허용할 것인가
   - 포워더는 이벤트 전송에 실패하면 실패한 이벤트로 부터 읽어와 다시 전송을 시도한다
   - 계속 실패할 경우 다음 이벤트를 제공할 수 없기 때문에, 포워더를 구현할 때는 실패한 이벤트의 재전송 횟수에 제한을 두어야 한다
3. 이벤트 손실
   - 로컬 핸들러를 이용해서 이벤트를 비동기로 처리하면 처리에 실패할 경우 이벤트를 유실할 수 있다
   - 이벤트 저장소를 사용하면 보관이 되기 때문에 이 부분은 보장이 된다
4. 이벤트 순서
   - 이벤트를 발생 순서대로 외부 시스템에 전달해야 할 경우 이벤트 저장소를 사용하는 것이 좋다
5. 이벤트 재처리
   - 동일한 이벤트를 다시 처리해야 할 때 어떻게 처리할지 결정해야 한다
   - 가장 쉬운 방법은 처리할 이번트의 순번을 기억해 두었다가 이미 처리한 순번의 이벤트가 오면 무시하는 것이다
   - 이벤트 처리를 멱등으로 하는 방법도 있다 

### 멱등성(idempotent)
- 연산을 여러번 처리해도 결과가 달라지지 않는 것
- 예를 들어 abs()의 경우 absabs(abs(x)))해도 결과가 동일하다
- 이 경우 멱등성을 갖는다라고 한다

# 11. CQRS (Command Query Responsibility Segregation)
## 단일 모델의 단점
일반적으로 조회의 경우 여러 애그리거트에서 데이터를 가져와야 할 경우가 많다. 이때 속도에 대한 고민이 생길 수 있다. 

그 이유는 시스템의 상태를 변경할 때와 조회할 때 단일 도메인 모델을 사용하기 때문이다. 객체지향으로 도메인 모델을 구현한다고 할 때 도메인의 상태를 변경하는 데는 적합하지만, 여러 애그리거트에서 데이터를 가져와 출력하는 기능을 구현하기에는 고려해야 할 것들이 많아서 구현을 복잡하게 만드는 원인이 된다

## CQRS
정의
- 상태를 변경하는 명령을 위한 모델과 상태를 제공하는 조회를 위한 모델을 분리하는 패턴

대상
- 복잡한 도메인에 적합한데 도메인이 복잡할 수록 명령 기능과 조회 기능이 다루는 데이터 범위에 차이가 발생하는데, CQRS를 통해서 조회를 위한 모델을 별도로 만들기 때문에 도메인 모델이 복잡해지는 것을 막을 수 있다
- 도메인이 복잡하지 않은데 CQRS를 도입하면 두 모델을 유지하는 비용만 높아지고 얻을 수 있는 이점은 없다

기능 
- 각 모델에 맞는 구현 기술을 택할 수도 있다 (DB를 다르게 구성하거나 필요없는 계층을 제거하거나)
- 서로 다른 DB를 사용할 경우 동기화가 필요한데 이벤트를 이용해서 대응할 수 있다
   - 실시간으로 동기화가 되어야 한다면 글로벌 트랜잭션을 사용할 수 있지만 성능이 떨어지는 문제가 있을 수 있다
   - 특정 시간 안에만 동기화하면 된다면 비동기로 전송해도 괜찮다

장점
- 명령 모델을 구현할 때 도메인 자체에 집중할 수 있다
- 조회 성능을 향상시키는데 도움이 된다

단점
- 구현할 코드가 많아진다 (각 모델을 위한 구현 코드가 생기기 때문에)
- 더 많은 구현 기술이 필요하다