# 1장. 웹과 네트워크의 기본에 대해 알아보자
WWW 구성하는 기술
- HTML: 문서 기술 언어로는 SGML을 베이스로
- HTTP: 문서 전송 프로토콜
- URL(Uniform Resource Locator): 문서의 주소를 지정하는 방법

진보 안하는 HTTP
- HTTP/0.9
   - HTTP가 등장한 때는 1990년인데, 이 당시 HTTP가 정식 사양서는 아니었습니다. 이 당시 등장한 HTTP는 1.0 이전이라는 의미에서 HTTP/0.9로 불리고 있습니다. 
- HTTP/1.0 
   - HTTP가 정식 사양으로 공개된 것은 1996년 5월이었습니다. 이 때 HTTP/1.0으로 RFC1945가 발생되었습니다. 초기의 사양이지만 현재에도 아직 많은 서버상에서 현역으로 가동괴 욌는 프로토콜 사양입니다. 
   - [RFC 1945 - HTTP.1.0](http://www.ietf.org/rfc/rfc1945.txt)
- HTTP/1.1
   - 1997년 1월에 공개된 HTTP/1.1 버전이 현재 가장 많이 사용되는 버전입니다. 그 당시의 사양은 RFC2068이지만 개정판으로 발행된 RFC2616이 최신 버전입니다. 
   - [RFC 2616 - HTTP.1.0](http://www.ietf.org/rfc/rfc2616.txt)

인터넷과 관련된 프로토콜을 모은 것을 TCP/IP라고 부릅니다. TCP와 IP 프로토콜을 가리켜 TCP/IP라고 부르기도 하지만, IP 프로ㄴ토콜을 사용한 통신에서 사용되고 있는 프로토콜을 총칭해서 TCP/IP라는 이름이 사용되고 있습니다. (p.20)

TCP/IP 계층
- 애플리케이션 계층
   - 애플리케이션 계층은 유저에게 제공되는 애플리케이션에서 사용하는 통신의 움직임을 결정하고 있습니다. 
   - TCP/IP에는 여러 가지의 공통 애플리케이션이 준비되어 있습니다. 예를 들면, FTP랑 DNS등도 애플리케이션의 한 가지 입니다. HTTP도 이 계층에 포함됩니다. 
- 트랜스포트 계층
   - 트랜스포트 계층은 애플리케이션 계층에 네트워크로 접속되어 있는 2대의 컴퓨터 사이의 데이터 흐름을 제공합니다. 트랜스포트 계층에서는 서로 다른 성질을 가진 TCP(Transmission Control Protocol)와 UDP(User Data Protocol) 두 가지 프로토콜이 있습니다. 
- 네트워크 계층
   - 네트워크 계층은 네트워크 상에서 패킷의 이동을 다룹니다. 패킷이란 전송하는 데이터의 최소 단위입니다. 이 계층에서는 어떠한 경로를 거쳐 상대의 컴퓨터까지 패킷을 보낼지를 결정하기도 합니다. 
   - 인터넷의 경우라면 상대 컴퓨터에 도달하는 동안에 여러 대의 컴퓨터랑 네트워크 기기를 거쳐서 상대방에게 배송됩니다. 그러한 여러 가지 선택지 중에서 하나의 길을 결정하는 것이 네트워크 계층의 역할입니다. 
- 링크 계층
   - 네트워크에 접속하는 하드웨어적인 면을 다룹니다. 운영체제가 하드웨어를 제어하기 때문에 디바이스 드라이버랑 네트워크 인터페이스 카드를 포함합니다. 그리고 케이블 등과 같이 물리적으로 보이는 부분도 포함합니다. 하드웨어적 측면은 모두 링크 계층의 역할입니다. 

URI와 URL (p.31)
- URI (Uniform Resources Identifier)
   - 리소스를 식별하기 위한 문자열 전반
- URL (Unitform Resources Locator)
   - 리소스의 장소(네트워크 상의 위치)
   - URL은 URI의 서브셋
- URL 포멧
   - 예: http://user:pass@www.example.jp:80/dir/index.htm?uid=1#ch1
      - http:// -> 스키마
      - user:pass -> 자격정보
      - www.example.jp -> 서버 주소
      - 80 -> 서버 포트
      - dir/index.html -> 계측정 파일 경로
      - uid=1 -> 쿼리 문자열
         - 파일 경로로 지정된 리소스에 임의의 파라미터를 넘겨주기 위해 쿼리 문자열을 사용
      - ch1 -> 프래그먼트 식별자
         - 주로 취득한 리소스에서 서브 리소스를 가리키기 위해서 사용

# 2장. 간단한 프로토콜 HTTP
HTTP Request Message (p.40)
   ```
   POST /form/entry HTTP/1.1
   Host: hack.jp
   Connection: keep-alive
   Content-Type: application/x-www-form-urlencoded
   Content-Length: 16

   name=ueno&apge=37
   ```
- POST -> 메소드
- /form/entry -> URI
- HTTP/ 1.1 -> 프로토콜 버전
- Host ~ -> 리퀘스트 헤더 필드

HTTP Response Message (p.42)
   ```
   HTTP/ 1.1 200 OK
   Date: Tue, 10 ..
   Content-Length: 362
   Content-Type: text/html

   <html>
   ....
   ```
- HTTP/ 1.1 -> 프로토콜 버전
- 200 -> 상태코드
- OK -> 상태코드 설명
- Date ~ -> 리스폰스 헤더 필드
- html~ -> 바디

HTTP 1.0과 1.1에서 지원하고 있는 메소드
- GET: 리소스 취득 (1.0, 1.1)
- POST: 엔티티 바디 전송 (1.0, 1.1)
- PUT: 파일 전송 (1.0, 1.1)
- HEAD: 메시지 헤더 취득 (1.0, 1.1)
- DELETE: 파일 삭제 (1.0, 1.1)
- OPTIONS: 서포트하고 있는 메소드 문의 (1.1)
- TRACE: 경로 조사 (1.1)
- CONNECT: 프록시에서의 터널링 요구 (1.1)
- LINK: 리소스 간에 링크 관계를 확립 (1.0)
- UNLINK: 링크 관계 삭제 (1.0)

지속 연결(Persistent Connections)
- HTTP/1.1와 일부 HTTP/1.0에서는 TCP 연결 문제를 해결하기 위해서 지속연결이라는 방법을 고안하였습니다 (연결문제: 매 리소스를 획득할 때마다 TCP연결을 하고 종료하는 것). 지속 연결의 특징은 어느 한 쪽이 명시적으로 연결을 종료하지 않는 이상 TCP 연결을 계속 유지합니다. 

파이프라인화(HTTP pipelining)
- 지속 연결은 여러 리퀘스트를 보낼 수 있도록 파이프라인화를 가능하게 합니다. 파이프라인화에 의해서, 이전에는 리퀘스트 송신 후에 리소폰스를 수신할 때까지 기다린 뒤에 발행하던 것을, 리스폰스를 기다리지 않고 바로 다음 리퀘스트를 보낼 수 있습니다. 

쿠키 (Cookie)
- HTTP는 Stateless 프로토콜이기 때문에, 과거에 교환했었던 리퀘스트와 리스폰스의 상태를 관리하지 않습니다. 결국, 과거 상태를 근거로해서 현재 리퀘스트를 처리한다는 것은 불가능합니다.
- 물론 Stateltess 프로토콜에도 이점이 있습니다. 상태를 유지하지 않는다는 점에서 서버의 CPU나 메모리 같은 리소스의 소비를 억제할 수 있습니다. 또한 단순한 프로토콜이기에 HTTP가 다양한 곳에서 이용되는 측면이 있습니다. 
- Stateless 프로토콜이라는 특징은 남겨둔 채, 이와 같은 문제를 해결하기 위해 쿠키라는 시스템이 도입되었습니다. 쿠키는 리퀘스트와 리스폰에 쿠키 정보를 추가해서 클라이언트의 상태를 파악하기 위한 시스템입니다.
- 쿠키는 서버에서 리스폰스로 보내는 Set-Cookie 라는 헤더 필드에 의해 쿠키를 클라이언트에 보존하게 됩니다. 다음 번에 클라이언트가 같은 서버로 리퀘스트를 보낼 때, 자동으로 쿠키 값을 넣어서 송신합니다. 서버는 클라이언트가 보낸 쿠키를 확인해서 어느 클라이언트가 접속했는지 체크하고 서버 상의 기록을 확인해서 이전 상태를 확인할 수 있습니다. 

   ```
   * 리퀘스트 (쿠키가 없는 상태)
   GET /reader/ HTTP /1.1
   Host: www.youngin.com
   * 헤더 필드에 쿠키는 없다
   ```

   ```
   * 리스폰스(서버가 쿠키를 발행)
   HTTP /1.1 200 OK
   ....
   <Set-Cookie: sid=133423434 ...>
   ```

   ```
   * 리퀘스트(보관하고 있던 쿠키를 자동 송신)
   GET /image/ HTTP /1.1
   Host: www.youngin.com
   Cookie: sid=133423434
   ```

# 3장. HTTP 정보는 HTTP 메시지에 있다
HTTP 메시지
- 메시지 헤더: 서버와 클라이언트가 꼭 처리해야 하는 리퀘스트와 리스폰스 내용과 속성 등
- 개행 문자(CL + LF)
- 메시지 바디: 꼭 전송해야 하는 데이터 그 자체

메시지 바디와 엔티티 바디의 차이
- Message
   - HTTP 통신의 기본 단위로 옥텟 시퀀스(Octet sequence)로 구성되고 통신을 통해서 전송됩니다
   - HTTP 메시지 바디의 역할은 리퀘스트랑 리스폰스에 관한 엔티티 바디를 운반하는 일<br>
   기본적으로 둘은 같지만 전송 코딩이 적용된 경우에는 엔티티 바디의 내용이 변화하기 때문에 메시지 바디와 달라진다
- Entity
   - 리퀘스트랑 리스폰스의 페이로드(payload, 부가물)로 전송되는 정보로 엔티티 헤더 필드와 엔티티 바디로 구성된다

콘텐츠 코딩(Contents Codings)
- 엔티티에 적용되는 인코딩을 가리킨다
- 엔티티 정보를 유지한채로 압축한다. 콘텐츠를 수신한 클라이언트에서는 디코딩한다

청크 전송 코디(Chunked trasfer Coding)
- 사이즈가 큰 데이터를 전송하는 경우에 데이터를 분할해서 조금씩 표현할 수 있다

멀티파트

# 4장. 결과를 전달하는 HTTP 상태 코드
1XX (Informational) - 리퀘스트를 받아들여 처리중

2XX (Success) - 리퀘스트를 정상적으로 처리했음
- 200 OK
   - 클라이언트가 보낸 메시지를 서버가 정상 처리 하였음
- 204 No Content
   - 서버가 리퀘스트를 받아서 처리하는 데는 성공했지만 리스폰스에 엔티티 바디를 포함하지 않는다
   - 브라우저에서는 204를 받았을 때 화면이 변하는 것은 없다
- 206 Partial Content
   - Range에 의해서 범위가 지정된 리퀘스트ㅔ 의해서 서버가 부분적 GET 리퀘스트를 받았음을 나타낸다
   - Response에는 Content-Range로 지정된 범위의 엔티티가 포함된다

3XX (Redirection) - 리퀘스트를 완료하기 위해서 브라우저 측에서 추가 동작이 필요
- 301 Moved Permanently
   - 리퀘스트된 리소스에 새로운 URI가 부여되어 있기 때문에, 이후로는 그 리소스를 참조하는 URI를 사용해야 한다는 것을 나타낸다
- 302 Found
   - 리퀘스트된 리소스에 새로운 URI가 부여되어 있기 때문에, 이후로는 그 리소스를 참조하는 URI를 사용해야 한다는 것인데, 301과 차이점은 영구적인 이동이 아닌 일시적인 것
- 303 See Other
   - 해당 URI가 새것으로 변경되었기 때문에 클라이언트에서는 리다이렉트 장소를 GET 메소드를 통해서 다시 얻어야 한다

4XX (Client Error) - 클라이언트의 원인으로 에러 발생
- 400 Bad Request
   - 리퀘스트 구문이 잘못되었음
   - 이 메시지를 받으면 리퀘스트를 재검토하고 재송신할 필요가 있다
- 401 Unautorized
   - 인증정보가 필요하다
   - 첫번째 리스폰스의 경우에는 인증 페이지가 뜨고, 두번째 401리스폰스는 인증 실패 에러가 발생한다
- 403 Forbidden
   - 리퀘스트된 리소스의 엑세스가 거부되었다
- 404 Not Found
   - 리퀘스트한 리소스가 서버에 없을 때

5XX (Server Error) - 서버의 원인으로 에러 발생
- 500 Internal Server Error
   - 서버에서 리퀘스트를 처리하는 도중에 에러가 발생
- 503 Service Unavailable
   - 일시적으로 서버가 과부하 상태이거나 점검중으로 현재 리퀘스트를 처리할 수 없는 상태

# 5장. HTTP와 연계하는 웹 서버
가상 호스트 (Virtual Host)
- 가상 호스트 기능을 사용하면 물리적으로는 서버가 1대지만 가상으로 여러대가 있는 것처럼 설정하는 것이 가능하다
- 같은 IP 주소에서 다른 호스트명과 도메인명을 가진 여러 개의 웹사이트가 실행되고 있는 가상 호스트의 시스템이 있기 때문에, HTTP 리퀘스트를 보내는 경우에는 호스트명과 도메인 명을 완전하게 포함한 URI를 지정하거나, 반드시 Host 헤더 필드에서 지정해야 한다. 

프록시 (Proxy)
- 클라이언트에서 받은 리퀘스트를 서버로 전송하는 것
- 리소스 본체를 가진 서버를 오리진 서버 (클라이언트 <-> 프록시 서버 <-> 오리진 서버)
- 사용하는 이유
   1. 캐시를 사용해서 네트워크 등을 효율적으로 사용하는 것 (=캐싱 프록시, Cashing Proxy)
   2. 조직 내에 특정 웹사이트에 대한 액세스 제한, 액세스 로그를 획득하는 정책을 철저하게 지키려는 목적 (=투명 프록시, Transparent Proxy)

게이트 웨이 (Gateway)
- 프록시와 유사한데, 그 다음에 있는 서버가 HTTP 서버 이외의 서비스를 제공하는 서버가 된다
- 사용 예
   - 데이터베이스에 접속해 SQL 쿼리를 사용해서 데이터를 얻는 곳으로 이용 가능
   - 쇼핑 사이트 등에서 신용 카드 결제 시스템과 연계할 때도 사용

터널(Tunnel)
- 요구에 따라서 다른 서버와의 통신 경로를 확립한다
- 이때 클라이언트는 SSL 같은 암호화 통신을 통해 서버와 안전하게 통신을 하기 위해 사용한다

캐시 (Cache)
- 프록시 서버와 클라이언트의 로컬 디스크에 보관된 리소스의 사본
- 캐시를 사용하면 리소스를 가진 서버에의 액세스를 줄이는 것이 가능하기 때문에 통신량과 통신 시간을 절약할 수 있다
- 캐시를 가지고 있더라도 클라이언트의 요구나 캐시의 유효기간 등에 의해서 오리진 서버에 리소스의 유효성을 확인하거나 새로운 리소스를 다시 획득하러 가게 되는 경우가 있다
- 클라이언트가 사용하는 브라우저에도 캐시를 가질 수 있다. (인터넷 익스프롤러에서는 '인터넷 임시 파일' 이라고 부른다)

# 7장. 웹을 안전하게 지켜주는 HTTPS
HTTP의 약점
- 평문(암호화 하지 않은) 통신이기 때문에 도청 가능
   - 중간에 누군가가 패킷을 가로챈다면 통신 내용을 확인할 수 있다
   - 도청을 막기 위해서 기술들이 연구되고 있는데 그 중에 하나는 암호화
      1. 통신 암호화
         - SSL(Secure Socket Layer), TLS(Transport Layer Security)와 같은 다른 프로토콜을 조합해서 암호화
      2. 콘텐츠 암호화
         - 메시지 자체를 암호화
         - 받는 쪽에서 복호화가 필요하다
- 통신 상대를 확인하지 않기 때문에 위장 가능
   - HTTP는 요청을 받으면 누군지 모르는 상태에서 일단 응답을 줘야 한다
   - 이에 대한 대응으로 SSL에서 제공하는 증명서를 이용해서 파악할 수 있따
- 완전성을 증명할 수 없기 때문에 변조 가능
   - 그런데 누가 패킷을 보냈는지 모르기 때문에 중간에 패킷을 가로채서 보내도 알 수가 없다
   - 변조 방지를 위해서는 MD5나 SHA-1 같은 해시를 사용하고 있다


HTTPS (HTTP Secure)
- HTTP + 암호화 + 인증 + 완전성 보호
- 구조
   - HTTP: IP <-> TCP <-> HTTP
   - HTTPS: IP <-> TCP <-> SSL <-> HTTP
      - SSL을 사용함으로써 암호화와 증명서와 완전성 보호를 이용할 수 있게 된다

HTTPS 암호화
- 공통키 암호화 방식
   - 방법: 암호화와 복호화에 하나의 키를 같이 사용하는 방식 (=상대방에게 키를 넘겨줘야 한다)
   - 키를 넘겨줘야 하기 때문에 네트워크를 통해서 키를 넘겨주는 과정에서 공격자가 키를 손에 넣으면 누구라도 암호를 해독할 수 있다
- 공개키 암호화 방식
   - 2개의 키 페어를 사용
      - 비밀키 (Private Key): 누구에게도 알려지면 안되는 키
      - 공개키 (Public Key): 누구에게나 공개된 키
   - 방법
      1. 암호를 보내는 측이 상대의 공개키를 사용해서 암호화한다
      2. 암호화된 정보를 받아들인 상대는 자신의 비밀키를 사용해서 복호화 한다
         - 비밀키를 보낼 필요가 없기 때문에 빼앗길 걱정이 없다
- HTTPS 암호화
   - 공통키와 공개키를 하이브리드로 사용
   - 처음 공통키를 얻기 위해서 공개키 암호화 방식을 사용하고, 그 이후에는 공통키로 통신한다
      - 공개키 암호가 공통키 암호호보다 처리 속도가 느리다

인증서
- 공개키 방식으로 암호화를 하더라도, 공개키가 올바른 것인지 증명할 수 없는 이슈가 있다
- 이를 위해서 인증기관(CA, Certificate Authority, 예: VeriSign)에서 인증서를 발급해주면서 키에 대한 보장을 해준다
   1. 공개키를 인증 기관에 전달
   2. 인증기관에서 공개키를 포함하는 증명서를 발급
   3. 증명서를 통해서 공개키를 사용하는 쪽에서는 해당 키가 올바르게 발행된 키인지 확인 가능

SSL, TLS
- SSL(Secure Socket Layer)
   - 넷스케이프에서 내놓은 프로토콜로 SSL3.0까지 개발되었고, 현재는 IETF로 옮겨졌다
   - 서버와 클라이언트에서 암호화와 복호화처리가 필요하기 때문에 속도가 느리다 (HTTP의 2배에서 100배)
       - SSL에 필요한 통신이 추가되고
       - 하드웨어 적으로 암호화 복호화 처리를 위한 리소스가 필요하기 때문에
- TLS(Transport Layer Security)
   - SSL 3.0을 기반으로 TLS1.0이 책정되어 TLS1.1, 1.2가 있다

# 8장. 누가 엑세스하고 있는지 확인하는 인증
### HTTP에서의 인증
Basic 인증
- 웹서버와 대응하고 있는 클라이언트에서 이루어지는 인증
- 순서
   1. [클라이언트] 리퀘스트 송신
   2. [서버] 401로 응답해서 인증이 필요하다는 것을 알려준다
   3. [클라이언트] ID와 패스워드를 Base64형식으로 인코딩한 값을 송신
   4. [서버] 인증 성공시에는 200으로 응답하고, 실패시에는 401로 응답
- 단점
   - Base64인코딩이 암호화는 아니기 때문에 아무런 부가 정보 없이도 복호화 할 수 있다
   - 한번 Basic 인증을 하면 일반 브라우저에서는 로그아웃 할 수 없는 문제가 있다

Digetst 인증
- Basic 인증의 약점을 보안하며, HTTP/1.1에 소개되어 있다
- 순서
   1. [클라이언트] 리퀘스트 송신
   2. [서버] 401응답과 함께 패스워드와 챌린지 코드(nonce)를 송신
   3. [클라이언트] 패스워드와 챌린지 코드에서 리스폰스 코드(reponse)를 계산해서 송신
   4. [서버] 인증 성공시에는 200으로 응답하고, 실패했을 경우 다시 401로 응답

SSL 클라이언트 인증
- HTTPS의 클라이언트 인증서를 이용한 인증방식. 클라이언트 증명서를 인증할 때 사용함으로써 사전에 등록된 클라이언트로 부터의 액세스인지 확인 가능하다
- 보통 클라이언트 인증 + 추가 인증 정보로 해서 2factor 인증을 진행
- 인증서 관리에 대한 비용이 발생

폼 베이스 인증
- 클라이언트가 서버 상의 웹 애플리케이션에 자격 정보를 송신하여 그 자격정보의 검증 결과에 따라 인증을 하는 방식
- 주로 구글 인증할 때 구글 로그인 창이 뜨는 것을 생각하면 됨
- 인증의 대부분읜 폼 베이스 인증
   - Basic 인증이나 Digest인증은 사용상의 문제와 보안적인 문제로 거의 사용되고 있지 않음
   - SSL 클라이언트 인증도 도입 비용 문제로 널리 사용되고 있지는 않음