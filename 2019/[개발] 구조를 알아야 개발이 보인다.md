# 2. 윈도우 기본 개념 이해하기
## 5가지 기본 요소
### 1. 유저 모드와 커널 모드
유저모드
- 사용자가 이용하는 영역
- 운영체제의 시스템 영역을 제외한 데이터 영역에 접근이 가능
- 하드웨어에 엑세스를 할 수 없다

커널 모드
- 윈도우가 관리하는 시스템 영역
- 커널과 디바이스 드라이버들만 사용
- 모든 시스템 자원에 접근이 가능하다

Ring 권한
- Ring 0: 커널 모드. 최고권한
- Ring 3: 유저 모드. 하드웨러를 이용하기 위한 권한을 요청하고 올바른 요청인지 확인한 후 사용이 가능

### 2. 프로세스
정의
- 하나의 프로그램을 실행하기 위한 자원의 집합

특징
- 크기: 메모리 > 프로세스 > 코드, 리소스 > 스레드가 실행
- PID: 프로세스 ID. 프로세스의 고유 식별 번호

__프로세스 익스프롤러__
- 다운로드: [Link](https://docs.microsoft.com/ko-kr/sysinternals/downloads/process-explorer)
- 프로세스 정보에 대해서 더 자세하기 확인이 가능하다
- 서비스 프로세스
   - 윈도우에서 사용자 화면이 필요 없이 실행되는 프로세스
   - __svchost__
      - 서비스를 운영해주는 프로세스
      - 윈도우에서 기본적으로 제공하는 기능들을 관리하는 프로세스
- 옵션
   - Lowel Pane View: Handle이나 DLL의 정보에 대해서 추가 표시

### 3. 스레드
정의
- 프로그램의 실행 코드를 커널에서 처리하는 역할
- CPU에서 수행되기 때문에 CPU 상태 정보를 가지고 있으며, CPU를 나누어 쓰기 위한 스케줄링과 관련된 정보를 가지고 있다
- TID라는 고유 아이디를 가지고 있다

확인
- `프로세스 익스프롤러`에서 Properties -> Thread 에서 확인이 가능하다

### 4. 가상 메모리
정의
- 물리 메모리와 디스크를 이용한 메모리를 모두 통합하여 관리해서 프로세스들이 메모리를 의식하지 않고 사용할 수 있도록 도와주는 역할
- 실제로 저장된 공간이 떨어져 있더라도 프로세스 입장에서는 같은 저장 공간에 저장되어 있는 형태로 관리해주는 것

메모리 관리자
- 프로세스는 메모리 관리자를 통해서 메모리를 이용
- MAP이라는 프로세스별로 연결된 저장 위치 정보를 가지고 있어서 이를 통해 현재 프로세스가 사용하는 물리적 메모리 혹은 디스크 저장 위치를 관리하게 된다

특징
- 모든 프로세스를 메모리를 최대 각각 128TB의 용량으로 가질 수 있다
- 0x000000000000 ~ 0x00007FFFFFFF (커널에서 0xFFFF80000000 ~ 0xFFFFFFFFFFFF)

작업 관리자
- 메모리(활성 개인 작업 집합): 실제 물리적 메모리. 공유되지 않는 공간
- 커밋 크기(Commit Size): 운영체제에서 프로세스에 예약한 가상 메모리 양
   - 프로세스 익스플로러에서는 `Private Byte`로 표시

VMMap
- 메모리 분석 도구
- 다운로드: [Link](https://docs.microsoft.com/ko-kr/sysinternals/downloads/vmmap)
- 탭 설명
   - Committed: 물리와 가상이 포함된 전체 메모리 크기

### 5. 객체와 핸들
객체
- 하나의 기능을 위해 사용되는 묶음, 구조체들을 객체. (프로세스도 스레드도 객체)
- 윈도우 객체는 커널 메모리 공간에 위치
   - 커널 메모리라고 부르는 이유는 프로세스들이 직접 접근하지 못하고 윈도우의 관리하에 접근하도록 되어 있기 때문이다
- 객체에 접근하기 위해서는 조정자가 있어야 하는데 이 조정자가 바로 핸들(Handle)이다

핸들
- 핸들은 객체를 사용하기 위해 존재한다
- 유저모드에서는 핸들을 통해서 객체에 접근해야 한다
- 커널모드에서(동작하는 프로그램은) 바로 객체에 접근 가능하다
- 예: 유저모드 프로그램이 파일에 접근해야 한다면
   1. 접근하고자 하는 파일의 핸들을 통해서 윈도우에게 해당 파일에 접근하겠다고 요청을 보낸다
   2. 윈도우에서 요청을 확인
   3. 시스템 드라이버인 디스크 드라이버를 통해서 파일 객체에 접근하여 요청을 처리
- 핸들을 종료해서 특정 기능을 중단시키는 것이 가능하다
   - 예를 들어서 뮤텍스 관련 핸들을 종료하면 동일 프로그램이 2개가 실행될 수 있도록 처리도 할 수 있다

핸들 정보 확인 -> 프로세스 익스프롤러에서 확인 가능
- Handle: 현재 프로세스의 핸들 정보가 위치한 주소
   - 모든 프로세스는 핸들 테이블이라는 자신이 사용하는 핸들의 주소를 따로 가지고 있다
- Object Address: 객체가 실제로 저장된 메모리 주소


뮤텍스와 세마포어
- 자원의 접근을 허용하기 위해 사용되는 방법 중 하나
- 뮤텍스
   - 공유 자원에 접근할 수 있는 키를 접근하고자 하는 주체가 가지고 갔다가 다 사용했을 때 키를 돌려 놓는 방식
   - 단일 접근 제어에 유리
- 세마포어
   - 관리자가 숫자를 카운트하여 현재 공유 자원이 있는지를 카운트하는 방식
   - 다중 접근 제어에 유용


## 멀티 프로세싱
SMP(Symmetric multiprocessing)
- 대칭형 다중 처리
- 다수의 프로세서가 하나의 메모리 영역과 하드웨어 자원들을 공유하는 것

물리 프로세서와 논리 프로세서(코어)
- 2개의 물리 프로세서와 각각이 4개의 논리 프로세서를 가진다면, 8개의 작업을 동시에 처리 가능하다
- 논리 프로세서인 코어마다 작업 스레드를 처리할 수 있다

프로세서 확인
- 작업관리자에서 성능탭에서 확인 가능
   - CPU 그래프를 `논리 프로세서`로 변경
- 값 설명
   - 소켓: 물리적 프로세서 개수
   - 가상 프로세서: 논리적 프로세서 개수
   - 물리 프로세서 > 코어 > 논리 프로세서
- 하이퍼스레딩
   - 윈도우에서 논리적 프로세서 개수는 코어수에 x2로 보인다
   - 이는 인텔의 하이퍼스레딩 기술인데, 1갱 코어에 2개의 스레드를 실행시키는 기술\
   - 인코딩, 디코딩 같은 멀티미디어 작업에만 한정

## 유니코드
윈도우에서 사용하는 대표 문자세트
- 아스키코드 (1바이트)
- 유니코드 (2바이트)

## 서브시스템
환경 서브시스템(Environment SubSystem)
- 윈도우에서 실행 중인 응용 프로그램들의 환경을 지원해주는 기능
- 응용 프로그램의 실행을 위한 환경 부분과 프로세스 관리만 담당
- 처음 프로세스를 실행하게 되면 환경 서브시스템이 프로세스의 자원들을 받아서 메모리에 로드하고 실행할 준비를 한 다음에 초기 스레드(메인함수)를 실행해주는 역할을 한다

종류
- 윈도우 서비시스템: Csrss.exe
- UNIX용 POSIX 서브시스템: Psxss.exe

PE(Portable Execution) 파일 구조
- 윈도우에서 사용하는 실행 파일 구조
- [관련 정보](https://asecurity.dev/2016/12/peview-%ec%8b%a4%ed%96%89-%ed%8c%8c%ec%9d%bc-%ea%b5%ac%ec%a1%b0-pe-header-%eb%b6%84%ec%84%9d/)

서브시스템 DLL
- 시스템 자원 영역은 커널 모드(=커널)
- 응용프로그램에서 커널 영역을 사용을 요청할 때 이용하는 것이 서브시스템 DLL
   - 응용 프로그램 -> 서브시스템 DLL -> Kernel
- 종류
   1. Kernel32.dll: 파일 생성과 같은 하드웨어 요청에 주로 사용
   2. Advapi32.dll: 보안 구성이나 확인 등 추가적으로 윈도우에서 제공하는 기능적인 부분들에 사용
   3. User32.dll: 사용자에게 제공하는 창이나 메뉴 등의 화면을 생성하는데 필요한 요소를 요청할 때
   4. Gdi32.dll: User32.dll과 다르게 직접 그림을 그릴 수 있는 부분에 사용

### 1. 서브시스템 DLL
기능
- 프로그램을 실행하면, 프로그램은 자신이 윈도우에 요청할 때 피룡한 기능을 찾아서 연결하게 된다
- 이때 윈도우에 직접 연결하지 않고 중간에 연결해주는 역할을 하는 다리가 서브시스템 DLL

Dependency Walker
- 서비시스템을 화면으로 관찰하기 쉽게 구현한 프로그램
- Dependency Walker로 프로그램을 열어보면 사용하는 서브시스템 DLL을 알 수 있다
- [Link](http://www.dependencywalker.com/)

동작
- 서비시스템 DLL은 `Ntdll.dll`을 통해서 요청
- 프로그램 -> SubSystemDLL(ex: Kernel32.dll) -> NTDLL (Ntdll.dll)

### 2. NTDLL
기능
- 서브시스템 바로 하단에서 동작
- 유저모드에서 동작 중이던 프로그램들을 위해 커널 모드의 요청을 대신 처리한 후 결과 값을 반환해주는 역할
- 서브시스템 DLL들은 사용자의 응용 프로그램 혹시 서비스의 실행을 돕고, 실질적인 커널 요청은 Ntdll.dll을 통해서 진행된다

데이터 흐름
1. WINAPI CreateFile <windows.h>
2. Kernel32.CreateFile <kernel32.dll>
3. Ntdll.NtCreateFile <ntdll.dll>
4. Sysenter - kernel model

Disassembly
- Breakpoint에서 `Go To Disassembly` 기능 이용

### 3. 환경 서브시스템
기능
- 프로그램이 현재 실행되고 있는 영역을 관리

Process Exproler에서 `csrss.exe`가 2개인 이유
- 윈도우 보안을 위해서 서비스를 실행하는 영역과 사용자 영역을 분리해서 세션을 2개로 관리


### 4. 세션
정의
- 윈도우는 다중 사용자를 지원하기 때문에 프로세스들도 사용자마다 영역을 나누어서 실행해야 한다
- 이를 윈도우에서는 세션이라고 한다

기능
- 프로그램을 실행시킨 사용자만이 해등 프로그램의 입력과 출력을 보장받고 제어할 수 있도록 구분해주는 역할
- 구성 요소
   - Windows Station
   - Desktop
   - 하나의 세션은 1개 혹은 n 개의 Windows Station으로 구성
   - 하나의 Windows Station은 1개 혹은 n개의 Desktop으로 구성

csrss.exe (Window Station 설명)
- 서비스가 실행되는 csrss.exe
   - 사용자가 로그인을 하던 안하던 윈도우의 기능을 제공 (네트워크, 음악 등)하기 위해 사용되는 서비스 실행 공간
   - `services.msc`를 입력하는 나오는 서비스 관리자들이 대상
   - `\Windows\WindowStations\WinSta0` (윈도우가 실행되면 무조건 생성되는 세션)
- 사용자 기능이 실행되는 csrss.exe
   - `\Sessions\1\Windows\WindowStations\WinSta0` (사용자가 로그인 할 수록 1, 2 식으로 증가)
- 다른 서비스프로세스를 하나 선택해보면 windows station이 다른 것을 알 수 있다
   - `\Windows\WindowStations\Service-0x0-3e7$`
   - `WinSta0`이 사용자의 입력 및 화면 출력과 같은 화면과 상호작용을 할 수 있는 세션 내에서 유일한 Window Station이기 때문이다
   - `WinSta0`은 세션을 만들면 기본적으로 만들어지는 Window Station

Desktop
- 우리가 화면에 실제 보는 화면에 표시하는 리소스
- Virtual Desktop
   - 윈도우 10에서 제공하는 새로운 기능
   - Desktop 하위에 존재하는 개념
   - %SystemRoot%\system32\csrss.exe ObjectDirectory=\Windows SharedSection=1024,20480,768 Windows=On SubSystemType=Windows ServerDll=basesrv,1 ServerDll=winsrv:UserServerDllInitialization,3 ServerDll=sxssrv,4 ProfileControl=Off MaxRequestThreads=16
      - 컴퓨터\HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\SubSystems
      - SharedSection=1024,20480,768
         - 1024: 공유 데스크톱 힙 (Shared Desktop Heap)
         - 20480: WinSta0의 테스트톱 힙
         - 768: 상호 동작하지 않는 테스크톱 힙


Linux 서브 시스템
- 윈도우10의 서브시스템은 기존 윈도우와 다르게 Linux 명령부터 패키지 설치까지 지원된다



# 3. 프로세스
프로세스 종류
- 시스템 프로세스 (System support process)
   - 운영체제에서 생성하고 반드시 존재해야 하는 프로세스
   - 네이티브 API를 사용
   - 예: 로그온 프로세스, 세션 매니저(SMSS) 등
- 서비스 프로세스 (Service process)
   - Win32 Services에 의지하여 서비스 형태로 실행되는 서비스들
   - 예: 작업스케쥴러, MSSQL 
   - 시작메뉴의 실행에서 'Services.msc'를 입력하면 실행되는 리스트
- 응용 프로그램 (User application)
   - 유저모드에서 실행되는 프로그램
   - 메모장, 명령 프롬프트 등
- 환경 서비시스템 (Environment subsystem)
   - 프로그램의 실행 환경에 맞게 실행해주는 역할

## 1. 프로세스 관련 API
프로세스 실행 과정
1. 실행 파일을 더블클릭하거나 CreateProcess를 이용하여 프로세스 생성을 요청하면, 파일의 PE Header를 읽어서 프로세스 생성 작업을 시작
2. [커널모드] 프로세스 객체 생성
3. [커널모드] 스레드 초기화
4. [커널모드] 메인스레드 객체 생성
   - 메인스레드는 스레드를 실행하기 위한 스케줄링과 같은 정보와 처리 중인 내용의 위치에 대한 정보들이 포함
5. 환경 서비시스템인 CSRSS에게 프로세스와 스레드 핸들 및 ID를 알림과 함께 전달
6. 알림을 받은 CSRSS는 프로세스와 스레드의 핸들을 복제하고 초기화화여 여러 응용 프로그램이 동작할 수 있도록 관리
7. 첫번째 스레드 메인 함수 실행

컨텍스트
- 스레드는 실행될 때 모든 작업을 처리할 수 없기 때문에, 대기모드로 전환하여 자신의 차례를 기다렸다가 다시 실행 상태가 되었을 때 자신이 실행했던 지점을 기억하는 공간이 필요한데 이를 컨텍스트라고 한다. 
- 컨텍스트에는 실행하던 스택의 위치와 CPU 레지스터 값이 저장된다

프로세스의 핸들을 가져오면 다른 프로세스를 조정할 수도 있다


