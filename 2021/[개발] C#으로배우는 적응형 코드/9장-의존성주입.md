의존성 주입은 프로젝트의 시작 시점에 계획하고 도입해얗나다. 이미 완성된 프로젝트에 의존성 주입을 적용하는 것은 어렵기도하고 많은 시간을 필요로하다.

# 간편한 예제
예제 설명
- 사용자들이 할 일 목록(to-do list)를 관리할 수 있는 애플리케이션을 개발한다
- WPF 사용, MVVM 패턴을 도입
- 의존성 주입을 사용하지는 않았다

의존성 주입을 사용하지 않은 코드의 샘플
```csharp
public class TaskListController : INotifyPropertyChanged
    public event PropertyChangedEventHandler PropertyChanged = delegate { };
    private readonly ITaskService taskService;
    private readonly IObjectMapper mapper;
    private ObservableCollection<TaskViewModel> allTasks;

    public TaskListController()
    {
        // taskService와 mapper의 인스턴스를 생성자에서 직접 생성한다
        this.taskService = new TaskServiceAdo();
        this.mapper = new MapperAutoMapper();

        var taskDtos = taskService.GetAllTasks();
        AllTasks = new ObservableCollection<TaskViewModel>(mapper.Map<IEnumerable<TaskViewModel>>(taskDtos));
    } 
```

코드의 문제점
- 구현코드 내에 존재하는 의존성 때문에 컨트롤러에 대한 단위 테스트가 어렵다
- 소스코드를 읽어보기 전까지는 이 뷰모델이 어떤 것을 필요로하는지(=어떤 의존성을 가지고 있는지) 알기 어렵다
   - 어떤 클래스가 메서드 내에서 필요한 클래스들의 인스턴스를 임의로 생성한다면, 메서드 외부에서는 메서드가 올바르게 동작하기 위해 어떤 객체들이 필요한지 알 수 없다
- 서비스 객체가 가진 의존성이 이 클래스의 잠재적인 의존성으로 포함된다
- 서비스 객체를 다른 방법으로 대체할 유연성이 떨어진다

의존성 주입을 통해서 리팩토링된 코드
```csharp
public TaskListController(ITaskService taskService, IObjectMapper mapper)
{
    this.taskService = taskService;
    this.mapper = mapper;
} 
```

# 할 일 목록 애플리케이션

# 객체 그래프의 생성
인터페이스의 실제 구현체를 전달하는 방법
1. 필요한 객체를 생성하여 전달하는 방법
2. IoC(Inversion of Control) 컨테이너를 사용하는 방법

## 객체 생성을 통한 의존성 주입
개념
- 컨트롤러를 생성하기 전에 필요한 객체 그래프를 미리 만드는 방식

샘플 코드
```csharp
private void OnApplicationStartup(object sender, StartupEventArgs e)
{
    CreateMappings();
    // 의존성을 직접 생성
    var settings = new ApplicationSettings();
    var taskService = new TaskServiceAdo(settings);
    var objectMapper = new MapperAutoMapper();

    // 직접 생성한 객체를 주입
    controller = new TaskListController(taskService, objectMapper);
    MainWindow = new TaskListView(controller);
    MainWindow.Show();
    controller.OnLoad();
}
```

장점
- 객체 그래프가 복잡해도 직접 생성하기 때문에 유연하고 명확하다
- 필요한 객체를 세밀하게 조정해서 사용할 수 있다

단점
- 작성할 코드가 많아진다. 새로운 기능이 추가되면 초기화 코드가 방대해진다
- 코드가 많아짐에 따라 코드를 이해하는게 어려워 질 수 있다.

### 의존성 주입 방법
의존성 주입 방법
- 생성자 주입
- 메서드 주입
   ```csharp
    public void OnLoad()
    {
        // taskService가 필요로하는 ISetting의존성을 메서드를 통해서 주입
        var taskDtos = taskService.GetAllTasks(settings);
        AllTasks = new ObservableCollection<TaskViewModel>(mapper.Map<IEnumerable<TaskViewModel>>(taskDtos));
    }
   ```
   - 호출되는 메서드가 각 의존성을 필요로하는 유일한 부분일 때 유용하다
   - 생성자 매개변수가 클래스가 필요로하는 의존성을 명확히 할 수 있는 장점이 있지만 의존 주입된 객체들이 일부 메서드에서만 사용된다면 메서드를 통한 주입이 더 좋을 수 있다.
- 속성 주입
   ```csharp
    public void OnLoad()
    {
        // taskService가 필요로하는 ISetting의존성을 속성을 통해서 주입
        taskService.Settings = settings;
        var taskDtos = taskService.GetAllTasks(); 
        AllTasks = new ObservableCollection<TaskViewModel>(mapper.Map<IEnumerable<TaskViewModel>>(taskDtos));
    }
   ```
   - 속성을 런타임에 교체할 수 있다는 장점
   - _어느시점에나 변경할 수 있기 때문에 좋은 것인지는 잘 모르겠고, 잘 고려해서 사용해야할 것 같다_

# 제어의 역행
IoC 컨테이너
- 애플리케이션에 정의된 인터페이스와 그들의 실체 구현체들을 연결하여 클래스의 인스턴스를 생성할 때 필요한 의존성을 모두 해석해준다
- 객체 생성을 런타임에 진행한다

### [Unity](http://unitycontainer.org/index.html) 컨테이너 예시
```csharp
public partial class App : Application
{
    private IUnityContainer container;
    private void OnApplicationStartup(object sender, StartupEventArgs e)
    {
        CreateMappings();
        // 컨테이너를 생성하고, 추상타입과 구현타입을 등록해준다
        container = new UnityContainer();
        container.RegisterType<ISettings, ApplicationSettings>();
        container.RegisterType<IObjectMapper, MapperAutoMapper>();
        container.RegisterType<ITaskService, TaskServiceAdo>();
        container.RegisterType<TaskListController>();
        container.RegisterType<TaskListView>();
        MainWindow = container.Resolve<TaskListView>();
        MainWindow.Show();
        ((TaskListController)MainWindow.DataContext).OnLoad();
    }
    private void CreateMappings()
    {
        AutoMapper.Mapper.CreateMap<TaskDto, TaskViewModel>();
    }
}
```

직접 생성과의 차이점
- 인스턴스를 생성해서 객체의 생성자에 전달하는 방법은 동일하지만, 이 과정이 자동화되어 있다는 차이점이 있다

### 등록,해석,해체 패턴
등록(Register)
- IoC 컨테이너에 추상타입(=인터페이스)과 구현체를 등록하는 메서드
- 초기화 시점에 호출되는 메서드

해석(Resolve)
- 주로 객체 그래프의 최상위에 위치한 클래스를 해석하고자 할 때 사용된다
- 애플리케이션이 실행되는 동안 호출된다

해제(Release)
- 클래스를 더이상 사용하지 않는 시점에 자원을 해제하는 것
- 보통 애플리케이션이 종료되는 시점에 생성되지만, HTTP 요청 같이 개별적으로 생성되고 해제되는 자원은 처리의 마무리시점에 Release를 호출할 수 있다

폐기(Dispose)
- 애플리케이션이 완전히 종료될 때 한번 호출
- IoC 컨테이너에 등록된 모든 객체를 해제하기 때문에 더 이상 해석작업을 수행할 수 없게된다.

컨테이너 설정 분리
- IoC 컨테이너에 등록해야하는 객체가 늘어날 수록 애플리케이션 진입점에 코드가 복잡해질 수 있다. 
- 이 경우에는 Container 설정을 별도의 클래스로 분리해서 진입 코드를 깔끔하게 유지하고, 가독성을 높일 수 있다
   ```csharp
   public class IocConfiguration
   {
    private readonly IUnityContainer container;
    public IocConfiguration()
    {
        container = new UnityContainer();
    }
    public void Register()
    {
        container.RegisterType<ISettings, ApplicationSettings>();
        // 생략
    }
    public Window Resolve()
    {
        return container.Resolve<TaskListView>();
    }
    public void Release()
    {
        container.Dispose();
    }
    }
   ```

### 의무적 등록, 선언적 등록
의무적 등록
- 코드를 통해서 컨테이너의 객체를 생성
- 읽기가 쉽고, 상대적으로 간결허며, 컴파일 시점에 오류를 찾을 수 있는 장점이 있지만, 반대로 컴파일 시점에 구현 클래스의 타입을 제공해야하는 단점도 존재한다

선언적 등록
- XML을 이용해서 선언적으로 객체를 등록하는 방식
   ```xml
   <unity xmlns="http://schemas.microsoft.com/practices/2010/unity">
       <typeAliases>
         <typeAlias alias="ISettings" type="ServiceInterfaces.ISettings, ServiceInterfaces"/>
         <typeAlias alias="ApplicationSettings" type="UI.ApplicationSettings, UI" />
         <typeAlias alias="IObjectMapper" type="ServiceInterfaces.IObjectMapper, ServiceInterfaces" />
   ```
- 설정을 통해서 매핑정보를 관리할 수 있다는 장점이 있지만, 실용성이 떨어진다는 단점이 있다.
   - 코드의 양이 많아지고, 런타임에 에러가 발견된다
   - 객체를 등록하는 방법에 제약이 있다. 예를 들어서 인터페이스를 해석할 때마다 호출되는 람다 메서드를 이용해서 객체를 등록할 수도 있는데, 이런 방법은 선언적 XML로는 구현이 불가능하다

### 객체의 생명 주기
닷넷의 관리되는 환경에서는 `IDisposable` 인터페이스를 구현하는 경우, `Dispose()` 메서드를 통해서 객체가 사용하는 리소스의 반환 요청을 할 수는 있다.

