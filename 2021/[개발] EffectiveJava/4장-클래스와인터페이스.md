# 아이템 15: 클래스와 멤버의 접근 권한을 최소화하라
잘 설계된 컴포넌트와 그렇지 않은 컴포넌트의 차이는 내부 데이터와 내부 구현 정보를 얼마나 잘 숨겼느냐이다.
- 오직 API를 통해서만 다른 컴포넌트와 소통하며 서로의 내부 동작 방식에는 전혀 개의치 않는다
- 내부 구현이 숨겨져있기 때문에 재사용성을 높일 수 있다

클래스의 접근성
- 패키지 외부에서 사용할 이유가 없으면 package private 선언 -> API가 아닌 내부 구현이 되어서 언제든지 수정할 수 있다
- public은 API가 되어 외부에 공개되기 때문에 하위 호환을 위해서 영원히 관리 되어야 한다. 

멤버의 접근 권한
- private: 멤버를 선언한 클래스 안에서만 접근할 수 있다
- package-priave: 멤버가 속한 같은 패키지안의 멤버에서 접근 가능
- protected: package-private을 포함하면서, 하위 클래스에서 접근할 수 있다
- public: 모든 곳에서 접근 가능하다

클래스가 표현하는 추상 개념을 완성하는데 필요한 상수라면 '`public static final`' 로 사용 가능하다.

배열에 대한 불변 처리
- `public static final String[] VALUES = {..}` 와 같이 선언하면 외부에서 수정이 가능하기 때문에 피해야한다.
- 방법 1. 불변 객체를 리턴
   - 예: List라면 아래와 같이 수정 가능하다. 
   ```java
   private static final String[] PRIVATE_VALUES = {...};
   public static final List<String> VALUES = List.of(PRIVATE_VALUES);
   ```
- 방법 2. 복사 (clone)을 이용하는 방식
 
 # 아이템 16: public 클래스에서는 public 필드가 아닌 접근자 메서드를 이용하라
 package-private, private 중첩 클래스라면 데이터필드를 노출한다고 해도 문제가 없다.
 - 그 클래스가 표현하려는 추상 개념만 올바르게 표현해주면 된다
 - 클라이언트 코드 면에서도 접근자 방식보다 깔금하다
 - _결국 변경이 패키지 내부로 제한되기 때문에 그런듯하다_

 public 클래스의 필드가 불변이라면 단점은 조금 줄어들지만 결코 좋은 생각은 아니다
 - 필드를 읽을 때 부수 작업을 수행할 수 없다. (= _필드를 읽을 수 있지만 작업은 할 수 없다. 이건 잘 모르겠다._)

 