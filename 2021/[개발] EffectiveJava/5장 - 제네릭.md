# 아이템 26: 로 타입은 사용하지 말라
로 타입(raw type)
- 제네릭 타입에서 타입 매개변수를 사용하지 않은 것. 예: `List<String>` -> `List`
- 아무 값을 넣어도 컴파일 타임에 예외를 던지지 않지만, 런타임 오류가 발생할 수 있다
- 제네릭이 도입되기 전 코드와 호환을 위해서 추가한 타입

임의 객체를 사용하는 매개변수화 타입
- 예: `List<Object>`
- 모든 타입을 허용한다는 것을 컴파일러에게 전달하는 목적

List를 사용하면 `List<String>`에 integer 값을 넣을 수 있지만, 값을 꺼내려고 할 때 에러가 발생한다
```java
public static void main(String[] args) {
  List unSafeStrings = new ArrayList();
  unSafeStrings.add("hihi");
  unSafeStrings.add(1234);

  List<String> strings = new ArrayList<>();
  unsafeAdd(strings, 42);
  unsafeAdd(strings, "hi");
  String firstItem = strings.get(0);
}

private static void unsafeAdd(List list, Object o) {
  list.add(o);
}
```

비 한정적 와일드 타입
- 예: Set<?>
- null 이외에는 어떤 원소도 넣을 수 없다

로 타입을 써야아할 대
- class 리터럴: `List.class`, `int.class`, `String[].class`
   - 자바 명세에 class 리터럴에 매개변수화 타입을 사용하지 못하게 되어 있다
   - `List<String>.class`는 허용하지 않는다
- instanceof 연산자
   - 런타임에는 제네릭 타입 정보가 지워지므로 로타입과 비한정적 와일드 카드 외에는 사용할 수 없다
   ```java
   if (o instanceof Set) {
     Set<?> s = (Set<?>)o
   }
   ```

# 아이템 27: 비검사 경고를 제거하라
컴파일러가 보여주는 비 검사 경고는 무시하지 말자. 안전함이 증명된다면 `@SuppressWarnings("unchecked")`을 붙여서 경고를 숨기자.
- 샘플
   ```java
   // 코드
   T[] result = (T[]) Arrays.copyOf(elements, size, a.getClass());

   // 컴파일러 경고
   // Unchecked cast: 'java.lang.Object[]' to 'T[]'

   // 수정 코드
   @SuppressWarnings("unchecked")
   T[] result = (T[]) Arrays.copyOf(elements, size, a.getClass());
   ```
- 수정 코드에는 왜 그 경고를 무시해도 안전한 이유를 설명해야한다.

# 아이템 28: 배열보다는 리스트를 사용하라
배열보다 리스트를 사용해야하는 이유
1. 배열은 공변이다
   - 공변이라는 Sub가 Super의 하위 타입이면 Sub[]도 Super[]의 하위 타입이다.
   - 제네릭은 불공변이라서 Type1, Type2가 있을 때 `List<Type1>` 은 `List<Type2>` 의 하위 타입도 아니고 상위 타입도 아니다
   - 이 때문에 배열은 런타임에 데이터를 가져오는 시점에 문제가 발생할 수 있다
      ```java
      // 아래의 코드는 runtime에 ArrayStoreException을 발생시킨다
      Object[] objectArray = new Long[1];
      objectArray[0] = "hihi";  // 예외 발생
      ```
2. 배열은 실체화 된다
   - 배열은 런타임에도 자신이 담기로 한 타입을 인지하고 확인단다
   - 제네릭은 타입 정보가 런타임 시점에는 사라진다. 원소타입을 컴파일 시점에만 검사한다. 

배열을 List<T>로 변경할 수 있다면 컴파일 시점에 타입 안정성을 확보할 수 있다
- 배열만 사용한 샘플 코드
   ```java
   public class ChooserArray {
      private final Object[] choiceArray;
      public ChooserArray(Collection choices) {
        choiceArray = choices.toArray();
      }
      public Object choose() {
        Random random = ThreadLocalRandom.current();
        return choiceArray[random.nextInt(choiceArray.length)];
      }
   }
   ```
- 제네릭을 적용한 샘플 코드
  ```java
  public class ChooserArrayGeneric<T> {
    private final T[] choiceArray;
    @SuppressWarnings("unchecked")
    public ChooserArrayGeneric(Collection<T> choices) {
      choiceArray = (T[])choices.toArray();
    }
    public T choose() {
      Random random = ThreadLocalRandom.current();
      return choiceArray[random.nextInt(choiceArray.length)];
    }
  }
  ```
- List<T>를 적용한 샘플 코드
  ```java
  public class ChooserListGeneric<T> {
    private final List<T> choiceArray;
    public ChooserListGeneric(Collection<T> choices) {
      choiceArray = new ArrayList<>(choices);
    }
    public T choose() {
      Random random = ThreadLocalRandom.current();
      return choiceArray.get(random.nextInt(choiceArray.size()));
    }
  }
  ```

# 아이템 29: 이왕이면 제네릭 타입으로 만들라
클라이언트에서 직접 형변환을 해야하는 타입보다는 제네릭 타입이 더 안전하고 쓰기 편하다. 

기본타입(int, double)은 제네릭타입으로 사용할 수 없는데, 이는 자바 제네릭 시스템의 근본적인 문제이다. 박싱 타입으로 생성해서 우회할 수 있다.