# 아이템 26: 로 타입은 사용하지 말라
로 타입(raw type)
- 제네릭 타입에서 타입 매개변수를 사용하지 않은 것. 예: `List<String>` -> `List`
- 아무 값을 넣어도 컴파일 타임에 예외를 던지지 않지만, 런타임 오류가 발생할 수 있다
- 제네릭이 도입되기 전 코드와 호환을 위해서 추가한 타입

임의 객체를 사용하는 매개변수화 타입
- 예: `List<Object>`
- 모든 타입을 허용한다는 것을 컴파일러에게 전달하는 목적

List를 사용하면 `List<String>`에 integer 값을 넣을 수 있지만, 값을 꺼내려고 할 때 에러가 발생한다
```java
public static void main(String[] args) {
  List unSafeStrings = new ArrayList();
  unSafeStrings.add("hihi");
  unSafeStrings.add(1234);

  List<String> strings = new ArrayList<>();
  unsafeAdd(strings, 42);
  unsafeAdd(strings, "hi");
  String firstItem = strings.get(0);
}

private static void unsafeAdd(List list, Object o) {
  list.add(o);
}
```

비 한정적 와일드 타입
- 예: Set<?>
- null 이외에는 어떤 원소도 넣을 수 없다

로 타입을 써야아할 대
- class 리터럴: `List.class`, `int.class`, `String[].class`
   - 자바 명세에 class 리터럴에 매개변수화 타입을 사용하지 못하게 되어 있다
   - `List<String>.class`는 허용하지 않는다
- instanceof 연산자
   - 런타임에는 제네릭 타입 정보가 지워지므로 로타입과 비한정적 와일드 카드 외에는 사용할 수 없다
   ```java
   if (o instanceof Set) {
     Set<?> s = (Set<?>)o
   }
   ```

# 아이템 27: 비검사 경고를 제거하라
컴파일러가 보여주는 비 검사 경고는 무시하지 말자. 안전함이 증명된다면 `@SuppressWarnings("unchecked")`을 붙여서 경고를 숨기자.
- 샘플
   ```java
   // 코드
   T[] result = (T[]) Arrays.copyOf(elements, size, a.getClass());

   // 컴파일러 경고
   // Unchecked cast: 'java.lang.Object[]' to 'T[]'

   // 수정 코드
   @SuppressWarnings("unchecked")
   T[] result = (T[]) Arrays.copyOf(elements, size, a.getClass());
   ```
- 수정 코드에는 왜 그 경고를 무시해도 안전한 이유를 설명해야한다.


