# 1장. 구조적인 접근
효과적인 디버깅의 단계
1. 소프트웨어가 왜 이상하게 작동하는지 알아낸다
2. 문제를 수정한다
3. 다른 곳이 깨지지 않게 한다
4. 코드의 전반적인 품질(가독성, 구조, 테스트 커버리지, 성능 등)을 유지하거나 향상시킨다
5. 같은 문제가 다른 부분에는 없는지 살펴보고, 재발 방지책을 마련한다
- __근본 원인을 찾아내는 것이 제일 중요하다__

핵심 디버깅 과정
- 과정
   - 재현: 해결하려는 문제를 재현할 수 있는, 신뢰할 수 있으면서도 쉬운 방법 찾기
   - 진단: 가설을 세우고, 버그를 발생시키는 원인을 찾았다고 확신할 수 있을 때까지 실험으로 테스트하기
   - 수정: 문제를 고치기 위해 어떻게 코드를 수정할지 설계하고 구현.<br>
   회귀를 만들지 않으면서도, 소프트웨어 전반적인 품질은 유지하거나 향상시켜야 함
   - 반영: 버그에서 교훈얻기. 어디에서 잘못됐나? 다른 곳에는 같은 문제가 없을까?
- 위 과정이 순차적으로 일어나지는 않는다. 반복의 연속이다.

'무엇을'에 대해서 알고 있어야 한다
- 문제를 재현하거나 원인에 대한 가설을 세우기 전에 먼저 어떤일이 발생했는지를 정확하게 알아야 한다. 
- 마찬가지로 어떤 일이 벌어져야 하는지를 아는 것도 중요하다
- 어떻게 작동해야 하는지 명확하지 않다면 정확하게 알기 전까지는 아무런 변경도 하지 말라.

간단한 것부터 살펴보기
- 많은 버그는 실수로 부터 생긴다
- 미묘한 버그도 있겠지만 간단한 것이라고 그냥 지나치지 말자

'이건 내가 만든게 아냐(Not Invented Here)' 증후군
- 어째서인지 개발자들은 모든 것을 직접 확인해야 한다는 강박관념에 시달리는 것 같다. 
- 이런 현상은 훨씬 멋진 해결책이 이미 있음에도 불구하고 직접 구현해야 직성이 풀리는 '이건 내가 만든게 아냐' 증후군에서도 잘 나타난다.
- 디버깅에서 모든 문제를 내가 직접 디버깅해야 한다고 느낄 때 같은 실수를 하게 된다. 
- __다른 팀원들에게 '혹시 전에 이런 거 본 사람?' 이라고 물어보는 데 드는 비용은 거의 안들지만 엄청난 삽질을 막아줄 수 있다.__ 

# 2장. 재현
__디버깅을 하려면 먼저 문제 재현 방법을 찾아야 한다. 재현 할 수 없으면 진도를 나갈 수 없기 때문이다.__

재현을 시작하기
1. 분명한 것부터 시작하기
   - 버그 리포트에 있는 것부터 따라해보기
2. 노력 집중하기
   - 먼저 개발 환경과 버그 발생 환경을 동일하게 구성해야 한다
      1. 소프트웨어 그 자체(=동일한 버전)
      2. 실행 환경
      3. 입력 값

환경 제어
- 가능하면 모든 환경에 편리하게 접근할 수 있도록 테스트 환경을 구축해야 한다. (예: 가상머신)

입력 제어
- 입력 형태와는 상관없이 가장 중요한 것은 어떤 입력을 받았는지 파악한 후 똑같이 재생하는 것이다
- 고객이 어떤 것을 했는지를 성심껏 알려줬더라도 충분하지 않을 수 있다. 중요한 상세정보는 최종 고객에게 잘 보이지 않거나 전혀 볼 수 없는 경우가 대부분이다. 예를 들어 버그가 미묘한 타이밍 때문에 생긴다거나, 서드파티 시스템에서 받은 입력 때문에 생길수도 있다.
- 필요한 정보가 부족하다면 아래 2가지 방법을 선택할 수 있다. 하나는 어떤 입력을 받았는지 추론하는 것이고, 다른 하나는 입력을 기록하는 것이다. 
   1. 입력 추론하기
      - 거꾸로 작업해보기(찾아가보기)
      - 탐색하기: 버그 리포트에 적혀있는 방법과 비슷하게 이것저것 해보기
         - __사고 방식을 180도 바꿔보는 것도 하나의 방법이다. 우리는 문제가 없음을 증명하려는 것이 아니라, 문제가 있음을 증명해야 한다__
      - 억지로 에러 상태 만들기
      - 임의성 도입하기: 랜덤 값을 추가해 보는 방법
   2. 입력 값 기록: 로그로 입력을 직접 기록하는 것
      - 로그
         - 로그 프레임워크를 이용해서 도움을 받는다
         - 로그가 항상 최신 로그를 반영하도록 하고, 로그를 위한 로그는 남기지 말자 
      - 외부 로그
         - 디버깅 시점에 로깅 프록시를 이용하는 방법
         - '클라이언트' <-> 로깅 프록시(로그 기록) <-> 서버
         - 심(shim): 큰 라이브러리와 클라이언트 코드 사이를 연결해주는 간단한 라이브러리

재현 방법 다듬기
- 피드백 루프 최소화하기
   - 가장 짧으면서도 에러가 없는 수정-컴파일-실행-재현 주기를 만들어야 한다
   - 여타 소프트웨어 개발 영역과 마찬가지로 피드백 루프를 최소화하는 게 가장 중요하다
- 최대한 단순하게
   - 불필요한 부분을 찾아서 제거하는 작업을 먼저 해야 한다
   - 예를 들어서 100줄의 코드에서 50줄이 디버깅과 상관없다면 50줄을 제거하고 디버깅해야 한다
- 필요 시간 최소화 하기
   - 어떤 버그는 재현하는 데 시간이 걸린다.
   - 수 천 번 요청을 받고 나서야 크래시 되는 경우도 있는데, 보통은 메모리 누수 문제다. 
   - 이 부분이 의심스럽다면 메모리 양을 제한하거나, 메모리 누수를 만드는 임의 기능을 추가해서 검토한다
- 비결정적인 버그를 결정적인 것으로 만들기
   - 내부 상태를 초기화하지 않은 채로 사용
   - 외부 시스템과 상호 작용: 외부 시스템을 직접 제어하기 보다는, 외부 시스템을 디버깅용 하위 시스템이나 테스트 대역 같이 우리가 제어할 수 있는 것으로 바꿔보자
   - 일부러 넣은 임의성: 동일한 난수 값으로 테스트 한다
   - 다중 스레드
   - __로그 파일 재생__
      - 에뮬레이트 서드파티 서버가 로그를 읽어 똑같이 순서대로 작업을 재현할 수 있음을 보여준다
- __반복: 재현 과정을 끊음없이 다음을 수 있고, 또 그래야 한다__
   1. 어떤 모듈이 연관돼 있는지를 알고 나년 입력 파일 요소 중 어디에서 버그가 생기는지 끄집어 낼 수 있다
   2. 서드파티 서버와 통신하는 서브시스템을 항상 정해놓은 응답만 리턴하는 스텁으로 바꾸면 문제를 100% 재현할 수 있다
   3. 어느 함수가 문제를 일으키는지 알았다. 특정 인자로 이 함수를 호출해서 버그를 재현할 수 있는 단위 테스트를 만든다

정말로 버그를 재현할 수 없으면?
- __실제로 버그가 없을 수도 있다__
   - 하지만 모든 상황을 다 파악했는지 주의해야 한다. 개발자들은 너무 쉽게 이런 결론에 도달하는 경향이 있다
   - 사용자들이 악감정으로 버그 리포트를 보내지 않는다. 뭔가 잘못된 게 있을 가능성이 높은 것이다. 사용자가 원했던 것보다 불명확하게 설명했을 수도 있고, 소프트웨어의 어떤 부분을 잘못 이해했을 수도 있다. 시간을 내서 자신이 해본 것을 설명하면서 사용자가 실제로 겪은 일을 알 수 있게 해줄 추가 정보는 없을지 찾아보자. 
- __다른 사람 끌어들이기__
   - 다른 시각으로 문제를 따져볼 수 있는 사람을 데려올 수 있으면 좋다.
   - 예를 들어 고객 지원 팀 사람이라면 사용자에 대해서 잘 알 것이다. 
   - 할 수만 있다면 버그를 가장 먼저 알려준 사람을 데려오는게 가장 좋다. 

데드 레커닝 (dead reckoning)
- 보통 경험에 기댄 디버깅 방식이 좋지만 방법이 이것만 있는 것은 아니다
- 소프트웨어가 왜 이렇게 실행되는지를 순전히 논리만으로 증명하는 방법이 있다. 
   - 설명서를 확인해보거나, Spec.을 기준으로 하나하나 다 확인해보거나

# 3장. 진단

디버깅 방법
1. 소프트웨어 작동에 대해 알고 있는 것을 검토하고, 버그 원인에 대한 가설을 세운다
2. 가설을 검증할 수 있는 실험을 설계한다
3. 실험으로 가설이 실패했다면 다시 가설을 만든다
4. 시험으로 가설이 성공했다면 또 다른 증거가 있는지 확인한다. 또 다른 증거가 필요하다면 다른 실험을 계속 해본다.<br>그게 아니라면 종료한다



# 4장. 수정
소스를 수정을 할 때는 형사가 아닌 소프트웨어 엔지니어가 되어야 한다
- 형사
   - 다양한 가설을 증명/반증하면서 자유롭게 생각의 나래를 펼혔다
- 소프트웨어 엔지니어
   - '우마거나 되는 대로' 방식이 아니라 좀더 엄격하고 구조적으로 접근해 품질을 높이고 신뢰할 수 있도록 소스를 수정해야 한다

수정의 목표
- 문제 수정
- 회귀 방지
- 코드의 전반적인 품질을 유지하거나 향상시키기

__수정 과정__
- 수정 준비
   - 소스코드가 깨끗한 상태에서 시작해야 한다
   - 재현, 진단 과정에서 수정된 소스가 있으면 잠시 다른 곳에 옮겨두더라도 깨끗한 상태에서 진해해야 한다
- 테스트
   - 모든 테스트가 통과하는 것을 확인하고 진행한다
   - TDD 접근 방식
      1. 기존 테스트를 실행해보고 모두 통과하는지 확인한다
      2. 새로운 테스트를 추가하거나 기존 테스트를 수정해 버그가 있는 것을 보여준다(=실패시킨다)
      3. 버그를 수정한다
      4. 제대로 수정했는지 확인한다. (=테스트가 성공한다)
      5. 회귀가 생기지 않았음을 확인한다. (= 이전에 성공했던 테스트가 실패하지 않는다)
   - TDD를 안하고 있다면?
      - 자동이 아닌 수동 테스트가 있다는 점, 테스트가 끝나도 남는게 없다는 점이 차이가 있다.
      - 회귀 테스트가 없기 때문에 회귀가 생기지 않도록 조심해야 한다
- 증상이 아닌 원인을 고친다
   - 원인을 고쳐야지 증상인 버그를 고치는데 집중하면 안된다
      ~~~c
      int process_items(item* item_array, int array_size) 
      {
         int i;

         // 이유는 모르겠지만 array_size에 하나 모자람 문제가 있어 수정한
         array_size++;

         // 이후 처리
      }
      ~~~ 
   - 근본 문제를 제대로 해결했는가는 개발자 스스로가 보통 잘 안다. 정직성과 연결되어 있다.<br>
   근본 원인을 찾지 못했다면 이를 인정하는 용기가 필요하다.
- 리팩토링
   - 리팩토링의 핵심 통찰
      - 광범위한 단위 테스트 스위트가 안전망 역할을 해 줄 때에만 기존 코드를 안전하게 수정할 수 있다
      - 절대로 코드의 작동을 변경하면서 동시에 리팩토링하면 안 된다
- 체크인
   - 디버깅 관점에서는 변경 사항에 대해서 추적할 수 있는 기회를 제공한다
   - '로직을 하나 바꿀 때마다 체크인하기' 규칙
   - 체크인을 하기 전에는 어떤 것을 체크인하는지 `Diff` 등을 통해서 확인해보는 것이 좋다
- 코드 리뷰 받기
   - 누구에게?: 작업에 익숙한 사람에 물어보는 것이 좋지만, 그렇지 않은 사람에게 물어본다고 해도 신선한 시각에서 리뷰를 받을 수 있다
   - 언제?: (저자의 경험적으로) 분명하지 않거나 위험하다고 생각되는 부분에 왔을 때마다 코드 리뷰를 고려해보는 것이 좋다

# 5장. 반영
"이게 어떻게 지금껏 실행되고 있었지?" 라는 생각이 든다면
- 잠시 멈추고, 코드에 대한 이해를 더 높이자
- 가끔 실패할 것으로 예상되는 코드가 성공하는 경우가 있는데, 이런 테스트 코드는 더 중요하게 봐야 한다

무엇이 잘못되었는가?
- 비난하려는 문화는 팀워크를 갉아먹는다
- 문제를 찾은 후에 이를 어떻게 처리할 것인가가 그 문제가 있었다는 사실보다 훨씬 더 중요하다

__동료에게 이야기해주기__
- 동료에게 그가 한 실수를 알려주는 것은 지뢰밭을 걷는 것과 같다
- 몇가지 방법을 알아보자
   - 좋은 의도로 피드백을 주는게 가장 중요하다. 뻐기고 싶은 마음에 그 사람의 실수를 예기하려 한다면 닥치고 가만히 있자
   - 대화를 하기 전에 어떤 얘기를 할 지 먼저 계획하고 생각하자. 똑같은 이야기를 다른 사람이 나한테 한다면 어떨지 생각해보자. 
   - 개인적인 의견은 달지 말자. '너가', '당신이'라고 이야기하는 것보다, '내가', '우리가' 라고 예갸히는게 좋다
   - 생산적이 되자
   - 우리가 실수하는 것일수도 있다는 점을 잊지 말자. 단순히 누구에게 실수했다고 이야기하는게 아니라, 그 사람과 함께 가능성을 찾아보자.