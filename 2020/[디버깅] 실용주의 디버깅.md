# 1장. 구조적인 접근
효과적인 디버깅의 단계
1. 소프트웨어가 왜 이상하게 작동하는지 알아낸다
2. 문제를 수정한다
3. 다른 곳이 깨지지 않게 한다
4. 코드의 전반적인 품질(가독성, 구조, 테스트 커버리지, 성능 등)을 유지하거나 향상시킨다
5. 같은 문제가 다른 부분에는 없는지 살펴보고, 재발 방지책을 마련한다
- __근본 원인을 찾아내는 것이 제일 중요하다__

핵심 디버깅 과정
- 과정
   - 재현: 해결하려는 문제를 재현할 수 있는, 신뢰할 수 있으면서도 쉬운 방법 찾기
   - 진단: 가설을 세우고, 버그를 발생시키는 원인을 찾았다고 확신할 수 있을 때까지 실험으로 테스트하기
   - 수정: 문제를 고치기 위해 어떻게 코드를 수정할지 설계하고 구현.<br>
   회귀를 만들지 않으면서도, 소프트웨어 전반적인 품질은 유지하거나 향상시켜야 함
   - 반영: 버그에서 교훈얻기. 어디에서 잘못됐나? 다른 곳에는 같은 문제가 없을까?
- 위 과정이 순차적으로 일어나지는 않는다. 반복의 연속이다.

'무엇을'에 대해서 알고 있어야 한다
- 문제를 재현하거나 원인에 대한 가설을 세우기 전에 먼저 어떤일이 발생했는지를 정확하게 알아야 한다. 
- 마찬가지로 어떤 일이 벌어져야 하는지를 아는 것도 중요하다
- 어떻게 작동해야 하는지 명확하지 않다면 정확하게 알기 전까지는 아무런 변경도 하지 말라.

간단한 것부터 살펴보기
- 많은 버그는 실수로 부터 생긴다
- 미묘한 버그도 있겠지만 간단한 것이라고 그냥 지나치지 말자

'이건 내가 만든게 아냐(Not Invented Here)' 증후군
- 어째서인지 개발자들은 모든 것을 직접 확인해야 한다는 강박관념에 시달리는 것 같다. 
- 이런 현상은 훨씬 멋진 해결책이 이미 있음에도 불구하고 직접 구현해야 직성이 풀리는 '이건 내가 만든게 아냐' 증후군에서도 잘 나타난다.
- 디버깅에서 모든 문제를 내가 직접 디버깅해야 한다고 느낄 때 같은 실수를 하게 된다. 
- __다른 팀원들에게 '혹시 전에 이런 거 본 사람?' 이라고 물어보는 데 드는 비용은 거의 안들지만 엄청난 삽질을 막아줄 수 있다.__ 

# 2장. 재현
__디버깅을 하려면 먼저 문제 재현 방법을 찾아야 한다. 재현 할 수 없으면 진도를 나갈 수 없기 때문이다.__

재현을 시작하기
1. 분명한 것부터 시작하기
   - 버그 리포트에 있는 것부터 따라해보기
2. 노력 집중하기
   - 먼저 개발 환경과 버그 발생 환경을 동일하게 구성해야 한다
      1. 소프트웨어 그 자체(=동일한 버전)
      2. 실행 환경
      3. 입력 값

환경 제어
- 가능하면 모든 환경에 편리하게 접근할 수 있도록 테스트 환경을 구축해야 한다. (예: 가상머신)

입력 제어
- 입력 형태와는 상관없이 가장 중요한 것은 어떤 입력을 받았는지 파악한 후 똑같이 재생하는 것이다
- 고객이 어떤 것을 했는지를 성심껏 알려줬더라도 충분하지 않을 수 있다. 중요한 상세정보는 최종 고객에게 잘 보이지 않거나 전혀 볼 수 없는 경우가 대부분이다. 예를 들어 버그가 미묘한 타이밍 때문에 생긴다거나, 서드파티 시스템에서 받은 입력 때문에 생길수도 있다.
- 필요한 정보가 부족하다면 아래 2가지 방법을 선택할 수 있다. 하나는 어떤 입력을 받았는지 추론하는 것이고, 다른 하나는 입력을 기록하는 것이다. 
   1. 입력 추론하기
      - 거꾸로 작업해보기(찾아가보기)
      - 탐색하기: 버그 리포트에 적혀있는 방법과 비슷하게 이것저것 해보기
         - __사고 방식을 180도 바꿔보는 것도 하나의 방법이다. 우리는 문제가 없음을 증명하려는 것이 아니라, 문제가 있음을 증명해야 한다__
      - 억지로 에러 상태 만들기
      - 임의성 도입하기: 랜덤 값을 추가해 보는 방법
   2. 입력 값 기록: 로그로 입력을 직접 기록하는 것
      - 로그
         - 로그 프레임워크를 이용해서 도움을 받는다
         - 로그가 항상 최신 로그를 반영하도록 하고, 로그를 위한 로그는 남기지 말자 
      - 외부 로그
         - 디버깅 시점에 로깅 프록시를 이용하는 방법
         - '클라이언트' <-> 로깅 프록시(로그 기록) <-> 서버
         - 심(shim): 큰 라이브러리와 클라이언트 코드 사이를 연결해주는 간단한 라이브러리

재현 방법 다듬기
- 피드백 루프 최소화하기
   - 가장 짧으면서도 에러가 없는 수정-컴파일-실행-재현 주기를 만들어야 한다
   - 여타 소프트웨어 개발 영역과 마찬가지로 피드백 루프를 최소화하는 게 가장 중요하다
- 최대한 단순하게
   - 불필요한 부분을 찾아서 제거하는 작업을 먼저 해야 한다
   - 예를 들어서 100줄의 코드에서 50줄이 디버깅과 상관없다면 50줄을 제거하고 디버깅해야 한다
- 필요 시간 최소화 하기
   - 어떤 버그는 재현하는 데 시간이 걸린다.
   - 수 천 번 요청을 받고 나서야 크래시 되는 경우도 있는데, 보통은 메모리 누수 문제다. 
   - 이 부분이 의심스럽다면 메모리 양을 제한하거나, 메모리 누수를 만드는 임의 기능을 추가해서 검토한다
- 비결정적인 버그를 결정적인 것으로 만들기
   - 내부 상태를 초기화하지 않은 채로 사용
   - 외부 시스템과 상호 작용: 외부 시스템을 직접 제어하기 보다는, 외부 시스템을 디버깅용 하위 시스템이나 테스트 대역 같이 우리가 제어할 수 있는 것으로 바꿔보자
   - 일부러 넣은 임의성: 동일한 난수 값으로 테스트 한다
   - 다중 스레드
   - __로그 파일 재생__
      - 에뮬레이트 서드파티 서버가 로그를 읽어 똑같이 순서대로 작업을 재현할 수 있음을 보여준다
- __반복: 재현 과정을 끊음없이 다음을 수 있고, 또 그래야 한다__
   1. 어떤 모듈이 연관돼 있는지를 알고 나년 입력 파일 요소 중 어디에서 버그가 생기는지 끄집어 낼 수 있다
   2. 서드파티 서버와 통신하는 서브시스템을 항상 정해놓은 응답만 리턴하는 스텁으로 바꾸면 문제를 100% 재현할 수 있다
   3. 어느 함수가 문제를 일으키는지 알았다. 특정 인자로 이 함수를 호출해서 버그를 재현할 수 있는 단위 테스트를 만든다

정말로 버그를 재현할 수 없으면?
- __실제로 버그가 없을 수도 있다__
   - 하지만 모든 상황을 다 파악했는지 주의해야 한다. 개발자들은 너무 쉽게 이런 결론에 도달하는 경향이 있다
   - 사용자들이 악감정으로 버그 리포트를 보내지 않는다. 뭔가 잘못된 게 있을 가능성이 높은 것이다. 사용자가 원했던 것보다 불명확하게 설명했을 수도 있고, 소프트웨어의 어떤 부분을 잘못 이해했을 수도 있다. 시간을 내서 자신이 해본 것을 설명하면서 사용자가 실제로 겪은 일을 알 수 있게 해줄 추가 정보는 없을지 찾아보자. 
- __다른 사람 끌어들이기__
   - 다른 시각으로 문제를 따져볼 수 있는 사람을 데려올 수 있으면 좋다.
   - 예를 들어 고객 지원 팀 사람이라면 사용자에 대해서 잘 알 것이다. 
   - 할 수만 있다면 버그를 가장 먼저 알려준 사람을 데려오는게 가장 좋다. 

데드 레커닝 (dead reckoning)
- 보통 경험에 기댄 디버깅 방식이 좋지만 방법이 이것만 있는 것은 아니다
- 소프트웨어가 왜 이렇게 실행되는지를 순전히 논리만으로 증명하는 방법이 있다. 
   - 설명서를 확인해보거나, Spec.을 기준으로 하나하나 다 확인해보거나